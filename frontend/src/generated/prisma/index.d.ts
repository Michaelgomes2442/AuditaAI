
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model TeamMember
 * 
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>
/**
 * Model SharedTestCollection
 * 
 */
export type SharedTestCollection = $Result.DefaultSelection<Prisma.$SharedTestCollectionPayload>
/**
 * Model RateLimitQuota
 * 
 */
export type RateLimitQuota = $Result.DefaultSelection<Prisma.$RateLimitQuotaPayload>
/**
 * Model TestTemplate
 * 
 */
export type TestTemplate = $Result.DefaultSelection<Prisma.$TestTemplatePayload>
/**
 * Model Webhook
 * 
 */
export type Webhook = $Result.DefaultSelection<Prisma.$WebhookPayload>
/**
 * Model WebhookLog
 * 
 */
export type WebhookLog = $Result.DefaultSelection<Prisma.$WebhookLogPayload>
/**
 * Model ApiRateLimit
 * 
 */
export type ApiRateLimit = $Result.DefaultSelection<Prisma.$ApiRateLimitPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model AuditRecord
 * 
 */
export type AuditRecord = $Result.DefaultSelection<Prisma.$AuditRecordPayload>
/**
 * Model LamportState
 * 
 */
export type LamportState = $Result.DefaultSelection<Prisma.$LamportStatePayload>
/**
 * Model Budget
 * 
 */
export type Budget = $Result.DefaultSelection<Prisma.$BudgetPayload>
/**
 * Model RegressionBaseline
 * 
 */
export type RegressionBaseline = $Result.DefaultSelection<Prisma.$RegressionBaselinePayload>
/**
 * Model Feedback
 * 
 */
export type Feedback = $Result.DefaultSelection<Prisma.$FeedbackPayload>
/**
 * Model IpWhitelist
 * 
 */
export type IpWhitelist = $Result.DefaultSelection<Prisma.$IpWhitelistPayload>
/**
 * Model SecurityEvent
 * 
 */
export type SecurityEvent = $Result.DefaultSelection<Prisma.$SecurityEventPayload>
/**
 * Model TwoFactorBackup
 * 
 */
export type TwoFactorBackup = $Result.DefaultSelection<Prisma.$TwoFactorBackupPayload>
/**
 * Model SSOConfiguration
 * 
 */
export type SSOConfiguration = $Result.DefaultSelection<Prisma.$SSOConfigurationPayload>
/**
 * Model SSOSession
 * 
 */
export type SSOSession = $Result.DefaultSelection<Prisma.$SSOSessionPayload>
/**
 * Model SSOAuditLog
 * 
 */
export type SSOAuditLog = $Result.DefaultSelection<Prisma.$SSOAuditLogPayload>
/**
 * Model NotificationPreference
 * 
 */
export type NotificationPreference = $Result.DefaultSelection<Prisma.$NotificationPreferencePayload>
/**
 * Model TestResult
 * 
 */
export type TestResult = $Result.DefaultSelection<Prisma.$TestResultPayload>
/**
 * Model LamportCounter
 * 
 */
export type LamportCounter = $Result.DefaultSelection<Prisma.$LamportCounterPayload>
/**
 * Model BENReceipt
 * 
 */
export type BENReceipt = $Result.DefaultSelection<Prisma.$BENReceiptPayload>
/**
 * Model BENSession
 * 
 */
export type BENSession = $Result.DefaultSelection<Prisma.$BENSessionPayload>
/**
 * Model TriTrackHandoff
 * 
 */
export type TriTrackHandoff = $Result.DefaultSelection<Prisma.$TriTrackHandoffPayload>
/**
 * Model WitnessSignature
 * 
 */
export type WitnessSignature = $Result.DefaultSelection<Prisma.$WitnessSignaturePayload>
/**
 * Model CRIESComputation
 * 
 */
export type CRIESComputation = $Result.DefaultSelection<Prisma.$CRIESComputationPayload>
/**
 * Model ZScanVerification
 * 
 */
export type ZScanVerification = $Result.DefaultSelection<Prisma.$ZScanVerificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  USER: 'USER',
  ADMIN: 'ADMIN',
  ARCHITECT: 'ARCHITECT',
  AUDITOR: 'AUDITOR',
  WITNESS: 'WITNESS'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Permission: {
  READ_LOGS: 'READ_LOGS',
  WRITE_LOGS: 'WRITE_LOGS',
  MANAGE_USERS: 'MANAGE_USERS',
  MANAGE_TEAMS: 'MANAGE_TEAMS',
  VERIFY_RECORDS: 'VERIFY_RECORDS',
  EXPORT_DATA: 'EXPORT_DATA',
  VIEW_ANALYTICS: 'VIEW_ANALYTICS',
  MANAGE_SETTINGS: 'MANAGE_SETTINGS'
};

export type Permission = (typeof Permission)[keyof typeof Permission]


export const TeamRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  MEMBER: 'MEMBER',
  VIEWER: 'VIEWER'
};

export type TeamRole = (typeof TeamRole)[keyof typeof TeamRole]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const UserTier: {
  FREE: 'FREE',
  PAID: 'PAID',
  ARCHITECT: 'ARCHITECT'
};

export type UserTier = (typeof UserTier)[keyof typeof UserTier]


export const OrgStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED',
  TRIAL: 'TRIAL'
};

export type OrgStatus = (typeof OrgStatus)[keyof typeof OrgStatus]


export const PlanType: {
  TRIAL: 'TRIAL',
  BASIC: 'BASIC',
  PRO: 'PRO',
  ENTERPRISE: 'ENTERPRISE'
};

export type PlanType = (typeof PlanType)[keyof typeof PlanType]


export const AuditCategory: {
  AUTH: 'AUTH',
  ACCESS: 'ACCESS',
  DATA: 'DATA',
  CONFIG: 'CONFIG',
  VERIFICATION: 'VERIFICATION',
  SYSTEM: 'SYSTEM'
};

export type AuditCategory = (typeof AuditCategory)[keyof typeof AuditCategory]


export const AuditStatus: {
  SUCCESS: 'SUCCESS',
  FAILURE: 'FAILURE',
  WARNING: 'WARNING',
  INFO: 'INFO'
};

export type AuditStatus = (typeof AuditStatus)[keyof typeof AuditStatus]


export const FeedbackType: {
  BUG: 'BUG',
  FEATURE: 'FEATURE',
  IMPROVEMENT: 'IMPROVEMENT',
  QUESTION: 'QUESTION',
  OTHER: 'OTHER'
};

export type FeedbackType = (typeof FeedbackType)[keyof typeof FeedbackType]


export const FeedbackCategory: {
  UI_UX: 'UI_UX',
  PERFORMANCE: 'PERFORMANCE',
  ACCURACY: 'ACCURACY',
  DOCUMENTATION: 'DOCUMENTATION',
  API: 'API',
  BILLING: 'BILLING',
  SECURITY: 'SECURITY',
  GENERAL: 'GENERAL'
};

export type FeedbackCategory = (typeof FeedbackCategory)[keyof typeof FeedbackCategory]


export const FeedbackPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type FeedbackPriority = (typeof FeedbackPriority)[keyof typeof FeedbackPriority]


export const FeedbackStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED',
  WONT_FIX: 'WONT_FIX'
};

export type FeedbackStatus = (typeof FeedbackStatus)[keyof typeof FeedbackStatus]


export const SecurityEventType: {
  LOGIN_SUCCESS: 'LOGIN_SUCCESS',
  LOGIN_FAILED: 'LOGIN_FAILED',
  LOGOUT: 'LOGOUT',
  PASSWORD_CHANGE: 'PASSWORD_CHANGE',
  PASSWORD_RESET: 'PASSWORD_RESET',
  TWO_FACTOR_ENABLED: 'TWO_FACTOR_ENABLED',
  TWO_FACTOR_DISABLED: 'TWO_FACTOR_DISABLED',
  TWO_FACTOR_VERIFIED: 'TWO_FACTOR_VERIFIED',
  TWO_FACTOR_FAILED: 'TWO_FACTOR_FAILED',
  ACCOUNT_LOCKED: 'ACCOUNT_LOCKED',
  ACCOUNT_UNLOCKED: 'ACCOUNT_UNLOCKED',
  IP_WHITELIST_ADDED: 'IP_WHITELIST_ADDED',
  IP_WHITELIST_REMOVED: 'IP_WHITELIST_REMOVED',
  IP_BLOCKED: 'IP_BLOCKED',
  SESSION_CREATED: 'SESSION_CREATED',
  SESSION_TERMINATED: 'SESSION_TERMINATED',
  PERMISSION_CHANGED: 'PERMISSION_CHANGED',
  SUSPICIOUS_ACTIVITY: 'SUSPICIOUS_ACTIVITY'
};

export type SecurityEventType = (typeof SecurityEventType)[keyof typeof SecurityEventType]


export const SecuritySeverity: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type SecuritySeverity = (typeof SecuritySeverity)[keyof typeof SecuritySeverity]


export const SSOProvider: {
  SAML: 'SAML',
  AZURE_AD: 'AZURE_AD',
  GOOGLE: 'GOOGLE',
  OKTA: 'OKTA',
  GENERIC_OAUTH: 'GENERIC_OAUTH'
};

export type SSOProvider = (typeof SSOProvider)[keyof typeof SSOProvider]


export const SSOEventType: {
  SSO_LOGIN_SUCCESS: 'SSO_LOGIN_SUCCESS',
  SSO_LOGIN_FAILED: 'SSO_LOGIN_FAILED',
  SSO_LOGOUT: 'SSO_LOGOUT',
  SSO_CONFIG_CREATED: 'SSO_CONFIG_CREATED',
  SSO_CONFIG_UPDATED: 'SSO_CONFIG_UPDATED',
  SSO_CONFIG_DELETED: 'SSO_CONFIG_DELETED',
  SSO_CONFIG_ENABLED: 'SSO_CONFIG_ENABLED',
  SSO_CONFIG_DISABLED: 'SSO_CONFIG_DISABLED',
  JIT_USER_CREATED: 'JIT_USER_CREATED',
  JIT_USER_UPDATED: 'JIT_USER_UPDATED',
  SSO_SESSION_EXPIRED: 'SSO_SESSION_EXPIRED',
  SSO_CALLBACK_ERROR: 'SSO_CALLBACK_ERROR',
  SAML_ASSERTION_ERROR: 'SAML_ASSERTION_ERROR',
  OAUTH_TOKEN_ERROR: 'OAUTH_TOKEN_ERROR'
};

export type SSOEventType = (typeof SSOEventType)[keyof typeof SSOEventType]


export const BENPersona: {
  USER: 'USER',
  VERIFIER: 'VERIFIER',
  ANALYST: 'ANALYST',
  GOVERNOR: 'GOVERNOR',
  ARCHITECT: 'ARCHITECT'
};

export type BENPersona = (typeof BENPersona)[keyof typeof BENPersona]


export const ReceiptType: {
  BOOT_CONFIRM: 'BOOT_CONFIRM',
  ANALYSIS: 'ANALYSIS',
  DIRECTIVE: 'DIRECTIVE',
  RESULT: 'RESULT',
  APPEND: 'APPEND',
  SYNC_POINT: 'SYNC_POINT'
};

export type ReceiptType = (typeof ReceiptType)[keyof typeof ReceiptType]


export const TrackType: {
  BEN_CORE: 'BEN_CORE',
  AUDITAAI: 'AUDITAAI',
  HUMAN: 'HUMAN'
};

export type TrackType = (typeof TrackType)[keyof typeof TrackType]


export const HandoffStatus: {
  INITIATED: 'INITIATED',
  IN_TRANSIT: 'IN_TRANSIT',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  TIMEOUT: 'TIMEOUT'
};

export type HandoffStatus = (typeof HandoffStatus)[keyof typeof HandoffStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Permission = $Enums.Permission

export const Permission: typeof $Enums.Permission

export type TeamRole = $Enums.TeamRole

export const TeamRole: typeof $Enums.TeamRole

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type UserTier = $Enums.UserTier

export const UserTier: typeof $Enums.UserTier

export type OrgStatus = $Enums.OrgStatus

export const OrgStatus: typeof $Enums.OrgStatus

export type PlanType = $Enums.PlanType

export const PlanType: typeof $Enums.PlanType

export type AuditCategory = $Enums.AuditCategory

export const AuditCategory: typeof $Enums.AuditCategory

export type AuditStatus = $Enums.AuditStatus

export const AuditStatus: typeof $Enums.AuditStatus

export type FeedbackType = $Enums.FeedbackType

export const FeedbackType: typeof $Enums.FeedbackType

export type FeedbackCategory = $Enums.FeedbackCategory

export const FeedbackCategory: typeof $Enums.FeedbackCategory

export type FeedbackPriority = $Enums.FeedbackPriority

export const FeedbackPriority: typeof $Enums.FeedbackPriority

export type FeedbackStatus = $Enums.FeedbackStatus

export const FeedbackStatus: typeof $Enums.FeedbackStatus

export type SecurityEventType = $Enums.SecurityEventType

export const SecurityEventType: typeof $Enums.SecurityEventType

export type SecuritySeverity = $Enums.SecuritySeverity

export const SecuritySeverity: typeof $Enums.SecuritySeverity

export type SSOProvider = $Enums.SSOProvider

export const SSOProvider: typeof $Enums.SSOProvider

export type SSOEventType = $Enums.SSOEventType

export const SSOEventType: typeof $Enums.SSOEventType

export type BENPersona = $Enums.BENPersona

export const BENPersona: typeof $Enums.BENPersona

export type ReceiptType = $Enums.ReceiptType

export const ReceiptType: typeof $Enums.ReceiptType

export type TrackType = $Enums.TrackType

export const TrackType: typeof $Enums.TrackType

export type HandoffStatus = $Enums.HandoffStatus

export const HandoffStatus: typeof $Enums.HandoffStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sharedTestCollection`: Exposes CRUD operations for the **SharedTestCollection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SharedTestCollections
    * const sharedTestCollections = await prisma.sharedTestCollection.findMany()
    * ```
    */
  get sharedTestCollection(): Prisma.SharedTestCollectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rateLimitQuota`: Exposes CRUD operations for the **RateLimitQuota** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RateLimitQuotas
    * const rateLimitQuotas = await prisma.rateLimitQuota.findMany()
    * ```
    */
  get rateLimitQuota(): Prisma.RateLimitQuotaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testTemplate`: Exposes CRUD operations for the **TestTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestTemplates
    * const testTemplates = await prisma.testTemplate.findMany()
    * ```
    */
  get testTemplate(): Prisma.TestTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhook`: Exposes CRUD operations for the **Webhook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webhooks
    * const webhooks = await prisma.webhook.findMany()
    * ```
    */
  get webhook(): Prisma.WebhookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhookLog`: Exposes CRUD operations for the **WebhookLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookLogs
    * const webhookLogs = await prisma.webhookLog.findMany()
    * ```
    */
  get webhookLog(): Prisma.WebhookLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiRateLimit`: Exposes CRUD operations for the **ApiRateLimit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiRateLimits
    * const apiRateLimits = await prisma.apiRateLimit.findMany()
    * ```
    */
  get apiRateLimit(): Prisma.ApiRateLimitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditRecord`: Exposes CRUD operations for the **AuditRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditRecords
    * const auditRecords = await prisma.auditRecord.findMany()
    * ```
    */
  get auditRecord(): Prisma.AuditRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lamportState`: Exposes CRUD operations for the **LamportState** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LamportStates
    * const lamportStates = await prisma.lamportState.findMany()
    * ```
    */
  get lamportState(): Prisma.LamportStateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budget`: Exposes CRUD operations for the **Budget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Budgets
    * const budgets = await prisma.budget.findMany()
    * ```
    */
  get budget(): Prisma.BudgetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.regressionBaseline`: Exposes CRUD operations for the **RegressionBaseline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RegressionBaselines
    * const regressionBaselines = await prisma.regressionBaseline.findMany()
    * ```
    */
  get regressionBaseline(): Prisma.RegressionBaselineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **Feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.FeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ipWhitelist`: Exposes CRUD operations for the **IpWhitelist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IpWhitelists
    * const ipWhitelists = await prisma.ipWhitelist.findMany()
    * ```
    */
  get ipWhitelist(): Prisma.IpWhitelistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.securityEvent`: Exposes CRUD operations for the **SecurityEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityEvents
    * const securityEvents = await prisma.securityEvent.findMany()
    * ```
    */
  get securityEvent(): Prisma.SecurityEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.twoFactorBackup`: Exposes CRUD operations for the **TwoFactorBackup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwoFactorBackups
    * const twoFactorBackups = await prisma.twoFactorBackup.findMany()
    * ```
    */
  get twoFactorBackup(): Prisma.TwoFactorBackupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sSOConfiguration`: Exposes CRUD operations for the **SSOConfiguration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SSOConfigurations
    * const sSOConfigurations = await prisma.sSOConfiguration.findMany()
    * ```
    */
  get sSOConfiguration(): Prisma.SSOConfigurationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sSOSession`: Exposes CRUD operations for the **SSOSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SSOSessions
    * const sSOSessions = await prisma.sSOSession.findMany()
    * ```
    */
  get sSOSession(): Prisma.SSOSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sSOAuditLog`: Exposes CRUD operations for the **SSOAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SSOAuditLogs
    * const sSOAuditLogs = await prisma.sSOAuditLog.findMany()
    * ```
    */
  get sSOAuditLog(): Prisma.SSOAuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPreference`: Exposes CRUD operations for the **NotificationPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPreferences
    * const notificationPreferences = await prisma.notificationPreference.findMany()
    * ```
    */
  get notificationPreference(): Prisma.NotificationPreferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testResult`: Exposes CRUD operations for the **TestResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestResults
    * const testResults = await prisma.testResult.findMany()
    * ```
    */
  get testResult(): Prisma.TestResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lamportCounter`: Exposes CRUD operations for the **LamportCounter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LamportCounters
    * const lamportCounters = await prisma.lamportCounter.findMany()
    * ```
    */
  get lamportCounter(): Prisma.LamportCounterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bENReceipt`: Exposes CRUD operations for the **BENReceipt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BENReceipts
    * const bENReceipts = await prisma.bENReceipt.findMany()
    * ```
    */
  get bENReceipt(): Prisma.BENReceiptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bENSession`: Exposes CRUD operations for the **BENSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BENSessions
    * const bENSessions = await prisma.bENSession.findMany()
    * ```
    */
  get bENSession(): Prisma.BENSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.triTrackHandoff`: Exposes CRUD operations for the **TriTrackHandoff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TriTrackHandoffs
    * const triTrackHandoffs = await prisma.triTrackHandoff.findMany()
    * ```
    */
  get triTrackHandoff(): Prisma.TriTrackHandoffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.witnessSignature`: Exposes CRUD operations for the **WitnessSignature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WitnessSignatures
    * const witnessSignatures = await prisma.witnessSignature.findMany()
    * ```
    */
  get witnessSignature(): Prisma.WitnessSignatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cRIESComputation`: Exposes CRUD operations for the **CRIESComputation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CRIESComputations
    * const cRIESComputations = await prisma.cRIESComputation.findMany()
    * ```
    */
  get cRIESComputation(): Prisma.CRIESComputationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zScanVerification`: Exposes CRUD operations for the **ZScanVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ZScanVerifications
    * const zScanVerifications = await prisma.zScanVerification.findMany()
    * ```
    */
  get zScanVerification(): Prisma.ZScanVerificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Organization: 'Organization',
    Team: 'Team',
    TeamMember: 'TeamMember',
    SharedTestCollection: 'SharedTestCollection',
    RateLimitQuota: 'RateLimitQuota',
    TestTemplate: 'TestTemplate',
    Webhook: 'Webhook',
    WebhookLog: 'WebhookLog',
    ApiRateLimit: 'ApiRateLimit',
    Session: 'Session',
    AuditRecord: 'AuditRecord',
    LamportState: 'LamportState',
    Budget: 'Budget',
    RegressionBaseline: 'RegressionBaseline',
    Feedback: 'Feedback',
    IpWhitelist: 'IpWhitelist',
    SecurityEvent: 'SecurityEvent',
    TwoFactorBackup: 'TwoFactorBackup',
    SSOConfiguration: 'SSOConfiguration',
    SSOSession: 'SSOSession',
    SSOAuditLog: 'SSOAuditLog',
    NotificationPreference: 'NotificationPreference',
    TestResult: 'TestResult',
    LamportCounter: 'LamportCounter',
    BENReceipt: 'BENReceipt',
    BENSession: 'BENSession',
    TriTrackHandoff: 'TriTrackHandoff',
    WitnessSignature: 'WitnessSignature',
    CRIESComputation: 'CRIESComputation',
    ZScanVerification: 'ZScanVerification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "organization" | "team" | "teamMember" | "sharedTestCollection" | "rateLimitQuota" | "testTemplate" | "webhook" | "webhookLog" | "apiRateLimit" | "session" | "auditRecord" | "lamportState" | "budget" | "regressionBaseline" | "feedback" | "ipWhitelist" | "securityEvent" | "twoFactorBackup" | "sSOConfiguration" | "sSOSession" | "sSOAuditLog" | "notificationPreference" | "testResult" | "lamportCounter" | "bENReceipt" | "bENSession" | "triTrackHandoff" | "witnessSignature" | "cRIESComputation" | "zScanVerification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>
        fields: Prisma.TeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      SharedTestCollection: {
        payload: Prisma.$SharedTestCollectionPayload<ExtArgs>
        fields: Prisma.SharedTestCollectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SharedTestCollectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedTestCollectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SharedTestCollectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedTestCollectionPayload>
          }
          findFirst: {
            args: Prisma.SharedTestCollectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedTestCollectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SharedTestCollectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedTestCollectionPayload>
          }
          findMany: {
            args: Prisma.SharedTestCollectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedTestCollectionPayload>[]
          }
          create: {
            args: Prisma.SharedTestCollectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedTestCollectionPayload>
          }
          createMany: {
            args: Prisma.SharedTestCollectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SharedTestCollectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedTestCollectionPayload>[]
          }
          delete: {
            args: Prisma.SharedTestCollectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedTestCollectionPayload>
          }
          update: {
            args: Prisma.SharedTestCollectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedTestCollectionPayload>
          }
          deleteMany: {
            args: Prisma.SharedTestCollectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SharedTestCollectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SharedTestCollectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedTestCollectionPayload>[]
          }
          upsert: {
            args: Prisma.SharedTestCollectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedTestCollectionPayload>
          }
          aggregate: {
            args: Prisma.SharedTestCollectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSharedTestCollection>
          }
          groupBy: {
            args: Prisma.SharedTestCollectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SharedTestCollectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SharedTestCollectionCountArgs<ExtArgs>
            result: $Utils.Optional<SharedTestCollectionCountAggregateOutputType> | number
          }
        }
      }
      RateLimitQuota: {
        payload: Prisma.$RateLimitQuotaPayload<ExtArgs>
        fields: Prisma.RateLimitQuotaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RateLimitQuotaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitQuotaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RateLimitQuotaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitQuotaPayload>
          }
          findFirst: {
            args: Prisma.RateLimitQuotaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitQuotaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RateLimitQuotaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitQuotaPayload>
          }
          findMany: {
            args: Prisma.RateLimitQuotaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitQuotaPayload>[]
          }
          create: {
            args: Prisma.RateLimitQuotaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitQuotaPayload>
          }
          createMany: {
            args: Prisma.RateLimitQuotaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RateLimitQuotaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitQuotaPayload>[]
          }
          delete: {
            args: Prisma.RateLimitQuotaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitQuotaPayload>
          }
          update: {
            args: Prisma.RateLimitQuotaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitQuotaPayload>
          }
          deleteMany: {
            args: Prisma.RateLimitQuotaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RateLimitQuotaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RateLimitQuotaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitQuotaPayload>[]
          }
          upsert: {
            args: Prisma.RateLimitQuotaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitQuotaPayload>
          }
          aggregate: {
            args: Prisma.RateLimitQuotaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRateLimitQuota>
          }
          groupBy: {
            args: Prisma.RateLimitQuotaGroupByArgs<ExtArgs>
            result: $Utils.Optional<RateLimitQuotaGroupByOutputType>[]
          }
          count: {
            args: Prisma.RateLimitQuotaCountArgs<ExtArgs>
            result: $Utils.Optional<RateLimitQuotaCountAggregateOutputType> | number
          }
        }
      }
      TestTemplate: {
        payload: Prisma.$TestTemplatePayload<ExtArgs>
        fields: Prisma.TestTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTemplatePayload>
          }
          findFirst: {
            args: Prisma.TestTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTemplatePayload>
          }
          findMany: {
            args: Prisma.TestTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTemplatePayload>[]
          }
          create: {
            args: Prisma.TestTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTemplatePayload>
          }
          createMany: {
            args: Prisma.TestTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTemplatePayload>[]
          }
          delete: {
            args: Prisma.TestTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTemplatePayload>
          }
          update: {
            args: Prisma.TestTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTemplatePayload>
          }
          deleteMany: {
            args: Prisma.TestTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTemplatePayload>[]
          }
          upsert: {
            args: Prisma.TestTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTemplatePayload>
          }
          aggregate: {
            args: Prisma.TestTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestTemplate>
          }
          groupBy: {
            args: Prisma.TestTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<TestTemplateCountAggregateOutputType> | number
          }
        }
      }
      Webhook: {
        payload: Prisma.$WebhookPayload<ExtArgs>
        fields: Prisma.WebhookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findFirst: {
            args: Prisma.WebhookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findMany: {
            args: Prisma.WebhookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          create: {
            args: Prisma.WebhookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          createMany: {
            args: Prisma.WebhookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          update: {
            args: Prisma.WebhookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebhookUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          upsert: {
            args: Prisma.WebhookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          aggregate: {
            args: Prisma.WebhookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhook>
          }
          groupBy: {
            args: Prisma.WebhookGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookCountAggregateOutputType> | number
          }
        }
      }
      WebhookLog: {
        payload: Prisma.$WebhookLogPayload<ExtArgs>
        fields: Prisma.WebhookLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          findFirst: {
            args: Prisma.WebhookLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          findMany: {
            args: Prisma.WebhookLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>[]
          }
          create: {
            args: Prisma.WebhookLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          createMany: {
            args: Prisma.WebhookLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>[]
          }
          delete: {
            args: Prisma.WebhookLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          update: {
            args: Prisma.WebhookLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          deleteMany: {
            args: Prisma.WebhookLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebhookLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>[]
          }
          upsert: {
            args: Prisma.WebhookLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          aggregate: {
            args: Prisma.WebhookLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookLog>
          }
          groupBy: {
            args: Prisma.WebhookLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookLogCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookLogCountAggregateOutputType> | number
          }
        }
      }
      ApiRateLimit: {
        payload: Prisma.$ApiRateLimitPayload<ExtArgs>
        fields: Prisma.ApiRateLimitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiRateLimitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRateLimitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiRateLimitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRateLimitPayload>
          }
          findFirst: {
            args: Prisma.ApiRateLimitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRateLimitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiRateLimitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRateLimitPayload>
          }
          findMany: {
            args: Prisma.ApiRateLimitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRateLimitPayload>[]
          }
          create: {
            args: Prisma.ApiRateLimitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRateLimitPayload>
          }
          createMany: {
            args: Prisma.ApiRateLimitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiRateLimitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRateLimitPayload>[]
          }
          delete: {
            args: Prisma.ApiRateLimitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRateLimitPayload>
          }
          update: {
            args: Prisma.ApiRateLimitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRateLimitPayload>
          }
          deleteMany: {
            args: Prisma.ApiRateLimitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiRateLimitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiRateLimitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRateLimitPayload>[]
          }
          upsert: {
            args: Prisma.ApiRateLimitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiRateLimitPayload>
          }
          aggregate: {
            args: Prisma.ApiRateLimitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiRateLimit>
          }
          groupBy: {
            args: Prisma.ApiRateLimitGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiRateLimitGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiRateLimitCountArgs<ExtArgs>
            result: $Utils.Optional<ApiRateLimitCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      AuditRecord: {
        payload: Prisma.$AuditRecordPayload<ExtArgs>
        fields: Prisma.AuditRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>
          }
          findFirst: {
            args: Prisma.AuditRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>
          }
          findMany: {
            args: Prisma.AuditRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>[]
          }
          create: {
            args: Prisma.AuditRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>
          }
          createMany: {
            args: Prisma.AuditRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>[]
          }
          delete: {
            args: Prisma.AuditRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>
          }
          update: {
            args: Prisma.AuditRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>
          }
          deleteMany: {
            args: Prisma.AuditRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>[]
          }
          upsert: {
            args: Prisma.AuditRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>
          }
          aggregate: {
            args: Prisma.AuditRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditRecord>
          }
          groupBy: {
            args: Prisma.AuditRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditRecordCountArgs<ExtArgs>
            result: $Utils.Optional<AuditRecordCountAggregateOutputType> | number
          }
        }
      }
      LamportState: {
        payload: Prisma.$LamportStatePayload<ExtArgs>
        fields: Prisma.LamportStateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LamportStateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportStatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LamportStateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportStatePayload>
          }
          findFirst: {
            args: Prisma.LamportStateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportStatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LamportStateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportStatePayload>
          }
          findMany: {
            args: Prisma.LamportStateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportStatePayload>[]
          }
          create: {
            args: Prisma.LamportStateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportStatePayload>
          }
          createMany: {
            args: Prisma.LamportStateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LamportStateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportStatePayload>[]
          }
          delete: {
            args: Prisma.LamportStateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportStatePayload>
          }
          update: {
            args: Prisma.LamportStateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportStatePayload>
          }
          deleteMany: {
            args: Prisma.LamportStateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LamportStateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LamportStateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportStatePayload>[]
          }
          upsert: {
            args: Prisma.LamportStateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportStatePayload>
          }
          aggregate: {
            args: Prisma.LamportStateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLamportState>
          }
          groupBy: {
            args: Prisma.LamportStateGroupByArgs<ExtArgs>
            result: $Utils.Optional<LamportStateGroupByOutputType>[]
          }
          count: {
            args: Prisma.LamportStateCountArgs<ExtArgs>
            result: $Utils.Optional<LamportStateCountAggregateOutputType> | number
          }
        }
      }
      Budget: {
        payload: Prisma.$BudgetPayload<ExtArgs>
        fields: Prisma.BudgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findFirst: {
            args: Prisma.BudgetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findMany: {
            args: Prisma.BudgetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          create: {
            args: Prisma.BudgetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          createMany: {
            args: Prisma.BudgetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          delete: {
            args: Prisma.BudgetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          update: {
            args: Prisma.BudgetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          deleteMany: {
            args: Prisma.BudgetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BudgetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          upsert: {
            args: Prisma.BudgetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          aggregate: {
            args: Prisma.BudgetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudget>
          }
          groupBy: {
            args: Prisma.BudgetGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetCountAggregateOutputType> | number
          }
        }
      }
      RegressionBaseline: {
        payload: Prisma.$RegressionBaselinePayload<ExtArgs>
        fields: Prisma.RegressionBaselineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegressionBaselineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegressionBaselineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload>
          }
          findFirst: {
            args: Prisma.RegressionBaselineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegressionBaselineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload>
          }
          findMany: {
            args: Prisma.RegressionBaselineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload>[]
          }
          create: {
            args: Prisma.RegressionBaselineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload>
          }
          createMany: {
            args: Prisma.RegressionBaselineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegressionBaselineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload>[]
          }
          delete: {
            args: Prisma.RegressionBaselineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload>
          }
          update: {
            args: Prisma.RegressionBaselineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload>
          }
          deleteMany: {
            args: Prisma.RegressionBaselineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegressionBaselineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RegressionBaselineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload>[]
          }
          upsert: {
            args: Prisma.RegressionBaselineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload>
          }
          aggregate: {
            args: Prisma.RegressionBaselineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegressionBaseline>
          }
          groupBy: {
            args: Prisma.RegressionBaselineGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegressionBaselineGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegressionBaselineCountArgs<ExtArgs>
            result: $Utils.Optional<RegressionBaselineCountAggregateOutputType> | number
          }
        }
      }
      Feedback: {
        payload: Prisma.$FeedbackPayload<ExtArgs>
        fields: Prisma.FeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findFirst: {
            args: Prisma.FeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findMany: {
            args: Prisma.FeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          create: {
            args: Prisma.FeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          createMany: {
            args: Prisma.FeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          delete: {
            args: Prisma.FeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          update: {
            args: Prisma.FeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeedbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          upsert: {
            args: Prisma.FeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.FeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
      IpWhitelist: {
        payload: Prisma.$IpWhitelistPayload<ExtArgs>
        fields: Prisma.IpWhitelistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IpWhitelistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IpWhitelistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload>
          }
          findFirst: {
            args: Prisma.IpWhitelistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IpWhitelistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload>
          }
          findMany: {
            args: Prisma.IpWhitelistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload>[]
          }
          create: {
            args: Prisma.IpWhitelistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload>
          }
          createMany: {
            args: Prisma.IpWhitelistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IpWhitelistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload>[]
          }
          delete: {
            args: Prisma.IpWhitelistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload>
          }
          update: {
            args: Prisma.IpWhitelistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload>
          }
          deleteMany: {
            args: Prisma.IpWhitelistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IpWhitelistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IpWhitelistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload>[]
          }
          upsert: {
            args: Prisma.IpWhitelistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload>
          }
          aggregate: {
            args: Prisma.IpWhitelistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIpWhitelist>
          }
          groupBy: {
            args: Prisma.IpWhitelistGroupByArgs<ExtArgs>
            result: $Utils.Optional<IpWhitelistGroupByOutputType>[]
          }
          count: {
            args: Prisma.IpWhitelistCountArgs<ExtArgs>
            result: $Utils.Optional<IpWhitelistCountAggregateOutputType> | number
          }
        }
      }
      SecurityEvent: {
        payload: Prisma.$SecurityEventPayload<ExtArgs>
        fields: Prisma.SecurityEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecurityEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecurityEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          findFirst: {
            args: Prisma.SecurityEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecurityEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          findMany: {
            args: Prisma.SecurityEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>[]
          }
          create: {
            args: Prisma.SecurityEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          createMany: {
            args: Prisma.SecurityEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SecurityEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>[]
          }
          delete: {
            args: Prisma.SecurityEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          update: {
            args: Prisma.SecurityEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          deleteMany: {
            args: Prisma.SecurityEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecurityEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SecurityEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>[]
          }
          upsert: {
            args: Prisma.SecurityEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          aggregate: {
            args: Prisma.SecurityEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurityEvent>
          }
          groupBy: {
            args: Prisma.SecurityEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecurityEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecurityEventCountArgs<ExtArgs>
            result: $Utils.Optional<SecurityEventCountAggregateOutputType> | number
          }
        }
      }
      TwoFactorBackup: {
        payload: Prisma.$TwoFactorBackupPayload<ExtArgs>
        fields: Prisma.TwoFactorBackupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TwoFactorBackupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorBackupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TwoFactorBackupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorBackupPayload>
          }
          findFirst: {
            args: Prisma.TwoFactorBackupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorBackupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TwoFactorBackupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorBackupPayload>
          }
          findMany: {
            args: Prisma.TwoFactorBackupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorBackupPayload>[]
          }
          create: {
            args: Prisma.TwoFactorBackupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorBackupPayload>
          }
          createMany: {
            args: Prisma.TwoFactorBackupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TwoFactorBackupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorBackupPayload>[]
          }
          delete: {
            args: Prisma.TwoFactorBackupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorBackupPayload>
          }
          update: {
            args: Prisma.TwoFactorBackupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorBackupPayload>
          }
          deleteMany: {
            args: Prisma.TwoFactorBackupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TwoFactorBackupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TwoFactorBackupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorBackupPayload>[]
          }
          upsert: {
            args: Prisma.TwoFactorBackupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorBackupPayload>
          }
          aggregate: {
            args: Prisma.TwoFactorBackupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTwoFactorBackup>
          }
          groupBy: {
            args: Prisma.TwoFactorBackupGroupByArgs<ExtArgs>
            result: $Utils.Optional<TwoFactorBackupGroupByOutputType>[]
          }
          count: {
            args: Prisma.TwoFactorBackupCountArgs<ExtArgs>
            result: $Utils.Optional<TwoFactorBackupCountAggregateOutputType> | number
          }
        }
      }
      SSOConfiguration: {
        payload: Prisma.$SSOConfigurationPayload<ExtArgs>
        fields: Prisma.SSOConfigurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SSOConfigurationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SSOConfigurationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload>
          }
          findFirst: {
            args: Prisma.SSOConfigurationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SSOConfigurationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload>
          }
          findMany: {
            args: Prisma.SSOConfigurationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload>[]
          }
          create: {
            args: Prisma.SSOConfigurationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload>
          }
          createMany: {
            args: Prisma.SSOConfigurationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SSOConfigurationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload>[]
          }
          delete: {
            args: Prisma.SSOConfigurationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload>
          }
          update: {
            args: Prisma.SSOConfigurationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload>
          }
          deleteMany: {
            args: Prisma.SSOConfigurationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SSOConfigurationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SSOConfigurationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload>[]
          }
          upsert: {
            args: Prisma.SSOConfigurationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload>
          }
          aggregate: {
            args: Prisma.SSOConfigurationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSSOConfiguration>
          }
          groupBy: {
            args: Prisma.SSOConfigurationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SSOConfigurationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SSOConfigurationCountArgs<ExtArgs>
            result: $Utils.Optional<SSOConfigurationCountAggregateOutputType> | number
          }
        }
      }
      SSOSession: {
        payload: Prisma.$SSOSessionPayload<ExtArgs>
        fields: Prisma.SSOSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SSOSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SSOSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOSessionPayload>
          }
          findFirst: {
            args: Prisma.SSOSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SSOSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOSessionPayload>
          }
          findMany: {
            args: Prisma.SSOSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOSessionPayload>[]
          }
          create: {
            args: Prisma.SSOSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOSessionPayload>
          }
          createMany: {
            args: Prisma.SSOSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SSOSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOSessionPayload>[]
          }
          delete: {
            args: Prisma.SSOSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOSessionPayload>
          }
          update: {
            args: Prisma.SSOSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOSessionPayload>
          }
          deleteMany: {
            args: Prisma.SSOSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SSOSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SSOSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOSessionPayload>[]
          }
          upsert: {
            args: Prisma.SSOSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOSessionPayload>
          }
          aggregate: {
            args: Prisma.SSOSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSSOSession>
          }
          groupBy: {
            args: Prisma.SSOSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SSOSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SSOSessionCountArgs<ExtArgs>
            result: $Utils.Optional<SSOSessionCountAggregateOutputType> | number
          }
        }
      }
      SSOAuditLog: {
        payload: Prisma.$SSOAuditLogPayload<ExtArgs>
        fields: Prisma.SSOAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SSOAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SSOAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOAuditLogPayload>
          }
          findFirst: {
            args: Prisma.SSOAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SSOAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOAuditLogPayload>
          }
          findMany: {
            args: Prisma.SSOAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOAuditLogPayload>[]
          }
          create: {
            args: Prisma.SSOAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOAuditLogPayload>
          }
          createMany: {
            args: Prisma.SSOAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SSOAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOAuditLogPayload>[]
          }
          delete: {
            args: Prisma.SSOAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOAuditLogPayload>
          }
          update: {
            args: Prisma.SSOAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.SSOAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SSOAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SSOAuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOAuditLogPayload>[]
          }
          upsert: {
            args: Prisma.SSOAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOAuditLogPayload>
          }
          aggregate: {
            args: Prisma.SSOAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSSOAuditLog>
          }
          groupBy: {
            args: Prisma.SSOAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SSOAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SSOAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<SSOAuditLogCountAggregateOutputType> | number
          }
        }
      }
      NotificationPreference: {
        payload: Prisma.$NotificationPreferencePayload<ExtArgs>
        fields: Prisma.NotificationPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findFirst: {
            args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findMany: {
            args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          create: {
            args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          createMany: {
            args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          delete: {
            args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          update: {
            args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          deleteMany: {
            args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          upsert: {
            args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          aggregate: {
            args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPreference>
          }
          groupBy: {
            args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceCountAggregateOutputType> | number
          }
        }
      }
      TestResult: {
        payload: Prisma.$TestResultPayload<ExtArgs>
        fields: Prisma.TestResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>
          }
          findFirst: {
            args: Prisma.TestResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>
          }
          findMany: {
            args: Prisma.TestResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>[]
          }
          create: {
            args: Prisma.TestResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>
          }
          createMany: {
            args: Prisma.TestResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>[]
          }
          delete: {
            args: Prisma.TestResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>
          }
          update: {
            args: Prisma.TestResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>
          }
          deleteMany: {
            args: Prisma.TestResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>[]
          }
          upsert: {
            args: Prisma.TestResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>
          }
          aggregate: {
            args: Prisma.TestResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestResult>
          }
          groupBy: {
            args: Prisma.TestResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestResultCountArgs<ExtArgs>
            result: $Utils.Optional<TestResultCountAggregateOutputType> | number
          }
        }
      }
      LamportCounter: {
        payload: Prisma.$LamportCounterPayload<ExtArgs>
        fields: Prisma.LamportCounterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LamportCounterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportCounterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LamportCounterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportCounterPayload>
          }
          findFirst: {
            args: Prisma.LamportCounterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportCounterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LamportCounterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportCounterPayload>
          }
          findMany: {
            args: Prisma.LamportCounterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportCounterPayload>[]
          }
          create: {
            args: Prisma.LamportCounterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportCounterPayload>
          }
          createMany: {
            args: Prisma.LamportCounterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LamportCounterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportCounterPayload>[]
          }
          delete: {
            args: Prisma.LamportCounterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportCounterPayload>
          }
          update: {
            args: Prisma.LamportCounterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportCounterPayload>
          }
          deleteMany: {
            args: Prisma.LamportCounterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LamportCounterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LamportCounterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportCounterPayload>[]
          }
          upsert: {
            args: Prisma.LamportCounterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LamportCounterPayload>
          }
          aggregate: {
            args: Prisma.LamportCounterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLamportCounter>
          }
          groupBy: {
            args: Prisma.LamportCounterGroupByArgs<ExtArgs>
            result: $Utils.Optional<LamportCounterGroupByOutputType>[]
          }
          count: {
            args: Prisma.LamportCounterCountArgs<ExtArgs>
            result: $Utils.Optional<LamportCounterCountAggregateOutputType> | number
          }
        }
      }
      BENReceipt: {
        payload: Prisma.$BENReceiptPayload<ExtArgs>
        fields: Prisma.BENReceiptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BENReceiptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BENReceiptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload>
          }
          findFirst: {
            args: Prisma.BENReceiptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BENReceiptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload>
          }
          findMany: {
            args: Prisma.BENReceiptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload>[]
          }
          create: {
            args: Prisma.BENReceiptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload>
          }
          createMany: {
            args: Prisma.BENReceiptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BENReceiptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload>[]
          }
          delete: {
            args: Prisma.BENReceiptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload>
          }
          update: {
            args: Prisma.BENReceiptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload>
          }
          deleteMany: {
            args: Prisma.BENReceiptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BENReceiptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BENReceiptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload>[]
          }
          upsert: {
            args: Prisma.BENReceiptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload>
          }
          aggregate: {
            args: Prisma.BENReceiptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBENReceipt>
          }
          groupBy: {
            args: Prisma.BENReceiptGroupByArgs<ExtArgs>
            result: $Utils.Optional<BENReceiptGroupByOutputType>[]
          }
          count: {
            args: Prisma.BENReceiptCountArgs<ExtArgs>
            result: $Utils.Optional<BENReceiptCountAggregateOutputType> | number
          }
        }
      }
      BENSession: {
        payload: Prisma.$BENSessionPayload<ExtArgs>
        fields: Prisma.BENSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BENSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BENSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload>
          }
          findFirst: {
            args: Prisma.BENSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BENSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload>
          }
          findMany: {
            args: Prisma.BENSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload>[]
          }
          create: {
            args: Prisma.BENSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload>
          }
          createMany: {
            args: Prisma.BENSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BENSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload>[]
          }
          delete: {
            args: Prisma.BENSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload>
          }
          update: {
            args: Prisma.BENSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload>
          }
          deleteMany: {
            args: Prisma.BENSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BENSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BENSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload>[]
          }
          upsert: {
            args: Prisma.BENSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload>
          }
          aggregate: {
            args: Prisma.BENSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBENSession>
          }
          groupBy: {
            args: Prisma.BENSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BENSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BENSessionCountArgs<ExtArgs>
            result: $Utils.Optional<BENSessionCountAggregateOutputType> | number
          }
        }
      }
      TriTrackHandoff: {
        payload: Prisma.$TriTrackHandoffPayload<ExtArgs>
        fields: Prisma.TriTrackHandoffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TriTrackHandoffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TriTrackHandoffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload>
          }
          findFirst: {
            args: Prisma.TriTrackHandoffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TriTrackHandoffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload>
          }
          findMany: {
            args: Prisma.TriTrackHandoffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload>[]
          }
          create: {
            args: Prisma.TriTrackHandoffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload>
          }
          createMany: {
            args: Prisma.TriTrackHandoffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TriTrackHandoffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload>[]
          }
          delete: {
            args: Prisma.TriTrackHandoffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload>
          }
          update: {
            args: Prisma.TriTrackHandoffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload>
          }
          deleteMany: {
            args: Prisma.TriTrackHandoffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TriTrackHandoffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TriTrackHandoffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload>[]
          }
          upsert: {
            args: Prisma.TriTrackHandoffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload>
          }
          aggregate: {
            args: Prisma.TriTrackHandoffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTriTrackHandoff>
          }
          groupBy: {
            args: Prisma.TriTrackHandoffGroupByArgs<ExtArgs>
            result: $Utils.Optional<TriTrackHandoffGroupByOutputType>[]
          }
          count: {
            args: Prisma.TriTrackHandoffCountArgs<ExtArgs>
            result: $Utils.Optional<TriTrackHandoffCountAggregateOutputType> | number
          }
        }
      }
      WitnessSignature: {
        payload: Prisma.$WitnessSignaturePayload<ExtArgs>
        fields: Prisma.WitnessSignatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WitnessSignatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessSignaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WitnessSignatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessSignaturePayload>
          }
          findFirst: {
            args: Prisma.WitnessSignatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessSignaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WitnessSignatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessSignaturePayload>
          }
          findMany: {
            args: Prisma.WitnessSignatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessSignaturePayload>[]
          }
          create: {
            args: Prisma.WitnessSignatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessSignaturePayload>
          }
          createMany: {
            args: Prisma.WitnessSignatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WitnessSignatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessSignaturePayload>[]
          }
          delete: {
            args: Prisma.WitnessSignatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessSignaturePayload>
          }
          update: {
            args: Prisma.WitnessSignatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessSignaturePayload>
          }
          deleteMany: {
            args: Prisma.WitnessSignatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WitnessSignatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WitnessSignatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessSignaturePayload>[]
          }
          upsert: {
            args: Prisma.WitnessSignatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WitnessSignaturePayload>
          }
          aggregate: {
            args: Prisma.WitnessSignatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWitnessSignature>
          }
          groupBy: {
            args: Prisma.WitnessSignatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<WitnessSignatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.WitnessSignatureCountArgs<ExtArgs>
            result: $Utils.Optional<WitnessSignatureCountAggregateOutputType> | number
          }
        }
      }
      CRIESComputation: {
        payload: Prisma.$CRIESComputationPayload<ExtArgs>
        fields: Prisma.CRIESComputationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CRIESComputationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CRIESComputationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CRIESComputationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CRIESComputationPayload>
          }
          findFirst: {
            args: Prisma.CRIESComputationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CRIESComputationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CRIESComputationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CRIESComputationPayload>
          }
          findMany: {
            args: Prisma.CRIESComputationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CRIESComputationPayload>[]
          }
          create: {
            args: Prisma.CRIESComputationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CRIESComputationPayload>
          }
          createMany: {
            args: Prisma.CRIESComputationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CRIESComputationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CRIESComputationPayload>[]
          }
          delete: {
            args: Prisma.CRIESComputationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CRIESComputationPayload>
          }
          update: {
            args: Prisma.CRIESComputationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CRIESComputationPayload>
          }
          deleteMany: {
            args: Prisma.CRIESComputationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CRIESComputationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CRIESComputationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CRIESComputationPayload>[]
          }
          upsert: {
            args: Prisma.CRIESComputationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CRIESComputationPayload>
          }
          aggregate: {
            args: Prisma.CRIESComputationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCRIESComputation>
          }
          groupBy: {
            args: Prisma.CRIESComputationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CRIESComputationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CRIESComputationCountArgs<ExtArgs>
            result: $Utils.Optional<CRIESComputationCountAggregateOutputType> | number
          }
        }
      }
      ZScanVerification: {
        payload: Prisma.$ZScanVerificationPayload<ExtArgs>
        fields: Prisma.ZScanVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZScanVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZScanVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload>
          }
          findFirst: {
            args: Prisma.ZScanVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZScanVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload>
          }
          findMany: {
            args: Prisma.ZScanVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload>[]
          }
          create: {
            args: Prisma.ZScanVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload>
          }
          createMany: {
            args: Prisma.ZScanVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZScanVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload>[]
          }
          delete: {
            args: Prisma.ZScanVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload>
          }
          update: {
            args: Prisma.ZScanVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload>
          }
          deleteMany: {
            args: Prisma.ZScanVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZScanVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ZScanVerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload>[]
          }
          upsert: {
            args: Prisma.ZScanVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload>
          }
          aggregate: {
            args: Prisma.ZScanVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZScanVerification>
          }
          groupBy: {
            args: Prisma.ZScanVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZScanVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZScanVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<ZScanVerificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    organization?: OrganizationOmit
    team?: TeamOmit
    teamMember?: TeamMemberOmit
    sharedTestCollection?: SharedTestCollectionOmit
    rateLimitQuota?: RateLimitQuotaOmit
    testTemplate?: TestTemplateOmit
    webhook?: WebhookOmit
    webhookLog?: WebhookLogOmit
    apiRateLimit?: ApiRateLimitOmit
    session?: SessionOmit
    auditRecord?: AuditRecordOmit
    lamportState?: LamportStateOmit
    budget?: BudgetOmit
    regressionBaseline?: RegressionBaselineOmit
    feedback?: FeedbackOmit
    ipWhitelist?: IpWhitelistOmit
    securityEvent?: SecurityEventOmit
    twoFactorBackup?: TwoFactorBackupOmit
    sSOConfiguration?: SSOConfigurationOmit
    sSOSession?: SSOSessionOmit
    sSOAuditLog?: SSOAuditLogOmit
    notificationPreference?: NotificationPreferenceOmit
    testResult?: TestResultOmit
    lamportCounter?: LamportCounterOmit
    bENReceipt?: BENReceiptOmit
    bENSession?: BENSessionOmit
    triTrackHandoff?: TriTrackHandoffOmit
    witnessSignature?: WitnessSignatureOmit
    cRIESComputation?: CRIESComputationOmit
    zScanVerification?: ZScanVerificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    audits: number
    teams: number
    budgets: number
    regressionBaselines: number
    feedbacks: number
    benReceipts: number
    benSessions: number
    zscans: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    audits?: boolean | UserCountOutputTypeCountAuditsArgs
    teams?: boolean | UserCountOutputTypeCountTeamsArgs
    budgets?: boolean | UserCountOutputTypeCountBudgetsArgs
    regressionBaselines?: boolean | UserCountOutputTypeCountRegressionBaselinesArgs
    feedbacks?: boolean | UserCountOutputTypeCountFeedbacksArgs
    benReceipts?: boolean | UserCountOutputTypeCountBenReceiptsArgs
    benSessions?: boolean | UserCountOutputTypeCountBenSessionsArgs
    zscans?: boolean | UserCountOutputTypeCountZscansArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBudgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRegressionBaselinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegressionBaselineWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBenReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BENReceiptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBenSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BENSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountZscansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZScanVerificationWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    users: number
    teams: number
    ssoConfigs: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | OrganizationCountOutputTypeCountUsersArgs
    teams?: boolean | OrganizationCountOutputTypeCountTeamsArgs
    ssoConfigs?: boolean | OrganizationCountOutputTypeCountSsoConfigsArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountSsoConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SSOConfigurationWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    members: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | TeamCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }


  /**
   * Count Type BENReceiptCountOutputType
   */

  export type BENReceiptCountOutputType = {
    handoffsFrom: number
    handoffsTo: number
  }

  export type BENReceiptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    handoffsFrom?: boolean | BENReceiptCountOutputTypeCountHandoffsFromArgs
    handoffsTo?: boolean | BENReceiptCountOutputTypeCountHandoffsToArgs
  }

  // Custom InputTypes
  /**
   * BENReceiptCountOutputType without action
   */
  export type BENReceiptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceiptCountOutputType
     */
    select?: BENReceiptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BENReceiptCountOutputType without action
   */
  export type BENReceiptCountOutputTypeCountHandoffsFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TriTrackHandoffWhereInput
  }

  /**
   * BENReceiptCountOutputType without action
   */
  export type BENReceiptCountOutputTypeCountHandoffsToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TriTrackHandoffWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    orgId: number | null
    failedLoginAttempts: number | null
    lamportCounter: number | null
    lastReceiptId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    orgId: number | null
    failedLoginAttempts: number | null
    lamportCounter: number | null
    lastReceiptId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.Role | null
    tier: $Enums.UserTier | null
    orgId: number | null
    status: $Enums.UserStatus | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    failedLoginAttempts: number | null
    lockedUntil: Date | null
    passwordChangedAt: Date | null
    ssoProvider: string | null
    ssoId: string | null
    currentPersona: $Enums.BENPersona | null
    personaLocked: boolean | null
    lamportCounter: number | null
    lastReceiptId: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.Role | null
    tier: $Enums.UserTier | null
    orgId: number | null
    status: $Enums.UserStatus | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    failedLoginAttempts: number | null
    lockedUntil: Date | null
    passwordChangedAt: Date | null
    ssoProvider: string | null
    ssoId: string | null
    currentPersona: $Enums.BENPersona | null
    personaLocked: boolean | null
    lamportCounter: number | null
    lastReceiptId: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    role: number
    tier: number
    permissions: number
    orgId: number
    status: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    twoFactorEnabled: number
    twoFactorSecret: number
    backupCodes: number
    failedLoginAttempts: number
    lockedUntil: number
    passwordChangedAt: number
    ssoProvider: number
    ssoId: number
    ssoMetadata: number
    currentPersona: number
    personaLocked: number
    lamportCounter: number
    lastReceiptId: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    orgId?: true
    failedLoginAttempts?: true
    lamportCounter?: true
    lastReceiptId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    orgId?: true
    failedLoginAttempts?: true
    lamportCounter?: true
    lastReceiptId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    tier?: true
    orgId?: true
    status?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    passwordChangedAt?: true
    ssoProvider?: true
    ssoId?: true
    currentPersona?: true
    personaLocked?: true
    lamportCounter?: true
    lastReceiptId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    tier?: true
    orgId?: true
    status?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    passwordChangedAt?: true
    ssoProvider?: true
    ssoId?: true
    currentPersona?: true
    personaLocked?: true
    lamportCounter?: true
    lastReceiptId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    tier?: true
    permissions?: true
    orgId?: true
    status?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    backupCodes?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    passwordChangedAt?: true
    ssoProvider?: true
    ssoId?: true
    ssoMetadata?: true
    currentPersona?: true
    personaLocked?: true
    lamportCounter?: true
    lastReceiptId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    name: string | null
    role: $Enums.Role
    tier: $Enums.UserTier
    permissions: $Enums.Permission[]
    orgId: number | null
    status: $Enums.UserStatus
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    twoFactorEnabled: boolean
    twoFactorSecret: string | null
    backupCodes: string[]
    failedLoginAttempts: number
    lockedUntil: Date | null
    passwordChangedAt: Date | null
    ssoProvider: string | null
    ssoId: string | null
    ssoMetadata: JsonValue | null
    currentPersona: $Enums.BENPersona
    personaLocked: boolean
    lamportCounter: number
    lastReceiptId: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    tier?: boolean
    permissions?: boolean
    orgId?: boolean
    status?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    backupCodes?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    passwordChangedAt?: boolean
    ssoProvider?: boolean
    ssoId?: boolean
    ssoMetadata?: boolean
    currentPersona?: boolean
    personaLocked?: boolean
    lamportCounter?: boolean
    lastReceiptId?: boolean
    organization?: boolean | User$organizationArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    audits?: boolean | User$auditsArgs<ExtArgs>
    teams?: boolean | User$teamsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    budgets?: boolean | User$budgetsArgs<ExtArgs>
    regressionBaselines?: boolean | User$regressionBaselinesArgs<ExtArgs>
    feedbacks?: boolean | User$feedbacksArgs<ExtArgs>
    benReceipts?: boolean | User$benReceiptsArgs<ExtArgs>
    benSessions?: boolean | User$benSessionsArgs<ExtArgs>
    zscans?: boolean | User$zscansArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    tier?: boolean
    permissions?: boolean
    orgId?: boolean
    status?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    backupCodes?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    passwordChangedAt?: boolean
    ssoProvider?: boolean
    ssoId?: boolean
    ssoMetadata?: boolean
    currentPersona?: boolean
    personaLocked?: boolean
    lamportCounter?: boolean
    lastReceiptId?: boolean
    organization?: boolean | User$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    tier?: boolean
    permissions?: boolean
    orgId?: boolean
    status?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    backupCodes?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    passwordChangedAt?: boolean
    ssoProvider?: boolean
    ssoId?: boolean
    ssoMetadata?: boolean
    currentPersona?: boolean
    personaLocked?: boolean
    lamportCounter?: boolean
    lastReceiptId?: boolean
    organization?: boolean | User$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    tier?: boolean
    permissions?: boolean
    orgId?: boolean
    status?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    backupCodes?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    passwordChangedAt?: boolean
    ssoProvider?: boolean
    ssoId?: boolean
    ssoMetadata?: boolean
    currentPersona?: boolean
    personaLocked?: boolean
    lamportCounter?: boolean
    lastReceiptId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "role" | "tier" | "permissions" | "orgId" | "status" | "lastLoginAt" | "createdAt" | "updatedAt" | "twoFactorEnabled" | "twoFactorSecret" | "backupCodes" | "failedLoginAttempts" | "lockedUntil" | "passwordChangedAt" | "ssoProvider" | "ssoId" | "ssoMetadata" | "currentPersona" | "personaLocked" | "lamportCounter" | "lastReceiptId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | User$organizationArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    audits?: boolean | User$auditsArgs<ExtArgs>
    teams?: boolean | User$teamsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    budgets?: boolean | User$budgetsArgs<ExtArgs>
    regressionBaselines?: boolean | User$regressionBaselinesArgs<ExtArgs>
    feedbacks?: boolean | User$feedbacksArgs<ExtArgs>
    benReceipts?: boolean | User$benReceiptsArgs<ExtArgs>
    benSessions?: boolean | User$benSessionsArgs<ExtArgs>
    zscans?: boolean | User$zscansArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | User$organizationArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | User$organizationArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      audits: Prisma.$AuditRecordPayload<ExtArgs>[]
      teams: Prisma.$TeamMemberPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPreferencePayload<ExtArgs> | null
      budgets: Prisma.$BudgetPayload<ExtArgs>[]
      regressionBaselines: Prisma.$RegressionBaselinePayload<ExtArgs>[]
      feedbacks: Prisma.$FeedbackPayload<ExtArgs>[]
      benReceipts: Prisma.$BENReceiptPayload<ExtArgs>[]
      benSessions: Prisma.$BENSessionPayload<ExtArgs>[]
      zscans: Prisma.$ZScanVerificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      name: string | null
      role: $Enums.Role
      tier: $Enums.UserTier
      permissions: $Enums.Permission[]
      orgId: number | null
      status: $Enums.UserStatus
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
      twoFactorEnabled: boolean
      twoFactorSecret: string | null
      backupCodes: string[]
      failedLoginAttempts: number
      lockedUntil: Date | null
      passwordChangedAt: Date | null
      ssoProvider: string | null
      ssoId: string | null
      ssoMetadata: Prisma.JsonValue | null
      currentPersona: $Enums.BENPersona
      personaLocked: boolean
      lamportCounter: number
      lastReceiptId: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends User$organizationArgs<ExtArgs> = {}>(args?: Subset<T, User$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    audits<T extends User$auditsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teams<T extends User$teamsArgs<ExtArgs> = {}>(args?: Subset<T, User$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    budgets<T extends User$budgetsArgs<ExtArgs> = {}>(args?: Subset<T, User$budgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    regressionBaselines<T extends User$regressionBaselinesArgs<ExtArgs> = {}>(args?: Subset<T, User$regressionBaselinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbacks<T extends User$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, User$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    benReceipts<T extends User$benReceiptsArgs<ExtArgs> = {}>(args?: Subset<T, User$benReceiptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    benSessions<T extends User$benSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$benSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zscans<T extends User$zscansArgs<ExtArgs> = {}>(args?: Subset<T, User$zscansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly tier: FieldRef<"User", 'UserTier'>
    readonly permissions: FieldRef<"User", 'Permission[]'>
    readonly orgId: FieldRef<"User", 'Int'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly backupCodes: FieldRef<"User", 'String[]'>
    readonly failedLoginAttempts: FieldRef<"User", 'Int'>
    readonly lockedUntil: FieldRef<"User", 'DateTime'>
    readonly passwordChangedAt: FieldRef<"User", 'DateTime'>
    readonly ssoProvider: FieldRef<"User", 'String'>
    readonly ssoId: FieldRef<"User", 'String'>
    readonly ssoMetadata: FieldRef<"User", 'Json'>
    readonly currentPersona: FieldRef<"User", 'BENPersona'>
    readonly personaLocked: FieldRef<"User", 'Boolean'>
    readonly lamportCounter: FieldRef<"User", 'Int'>
    readonly lastReceiptId: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.organization
   */
  export type User$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.audits
   */
  export type User$auditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    where?: AuditRecordWhereInput
    orderBy?: AuditRecordOrderByWithRelationInput | AuditRecordOrderByWithRelationInput[]
    cursor?: AuditRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditRecordScalarFieldEnum | AuditRecordScalarFieldEnum[]
  }

  /**
   * User.teams
   */
  export type User$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    where?: NotificationPreferenceWhereInput
  }

  /**
   * User.budgets
   */
  export type User$budgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    cursor?: BudgetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * User.regressionBaselines
   */
  export type User$regressionBaselinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
    where?: RegressionBaselineWhereInput
    orderBy?: RegressionBaselineOrderByWithRelationInput | RegressionBaselineOrderByWithRelationInput[]
    cursor?: RegressionBaselineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegressionBaselineScalarFieldEnum | RegressionBaselineScalarFieldEnum[]
  }

  /**
   * User.feedbacks
   */
  export type User$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * User.benReceipts
   */
  export type User$benReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    where?: BENReceiptWhereInput
    orderBy?: BENReceiptOrderByWithRelationInput | BENReceiptOrderByWithRelationInput[]
    cursor?: BENReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BENReceiptScalarFieldEnum | BENReceiptScalarFieldEnum[]
  }

  /**
   * User.benSessions
   */
  export type User$benSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
    where?: BENSessionWhereInput
    orderBy?: BENSessionOrderByWithRelationInput | BENSessionOrderByWithRelationInput[]
    cursor?: BENSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BENSessionScalarFieldEnum | BENSessionScalarFieldEnum[]
  }

  /**
   * User.zscans
   */
  export type User$zscansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
    where?: ZScanVerificationWhereInput
    orderBy?: ZScanVerificationOrderByWithRelationInput | ZScanVerificationOrderByWithRelationInput[]
    cursor?: ZScanVerificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZScanVerificationScalarFieldEnum | ZScanVerificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationAvgAggregateOutputType = {
    id: number | null
  }

  export type OrganizationSumAggregateOutputType = {
    id: number | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: number | null
    name: string | null
    plan: $Enums.PlanType | null
    status: $Enums.OrgStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: number | null
    name: string | null
    plan: $Enums.PlanType | null
    status: $Enums.OrgStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    plan: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationAvgAggregateInputType = {
    id?: true
  }

  export type OrganizationSumAggregateInputType = {
    id?: true
  }

  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    plan?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    plan?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    plan?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _avg?: OrganizationAvgAggregateInputType
    _sum?: OrganizationSumAggregateInputType
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: number
    name: string
    plan: $Enums.PlanType
    status: $Enums.OrgStatus
    createdAt: Date
    updatedAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    plan?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Organization$usersArgs<ExtArgs>
    teams?: boolean | Organization$teamsArgs<ExtArgs>
    ssoConfigs?: boolean | Organization$ssoConfigsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    plan?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    plan?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    plan?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "plan" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Organization$usersArgs<ExtArgs>
    teams?: boolean | Organization$teamsArgs<ExtArgs>
    ssoConfigs?: boolean | Organization$ssoConfigsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      teams: Prisma.$TeamPayload<ExtArgs>[]
      ssoConfigs: Prisma.$SSOConfigurationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      plan: $Enums.PlanType
      status: $Enums.OrgStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Organization$usersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teams<T extends Organization$teamsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ssoConfigs<T extends Organization$ssoConfigsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$ssoConfigsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'Int'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly plan: FieldRef<"Organization", 'PlanType'>
    readonly status: FieldRef<"Organization", 'OrgStatus'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization.users
   */
  export type Organization$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Organization.teams
   */
  export type Organization$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Organization.ssoConfigs
   */
  export type Organization$ssoConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
    where?: SSOConfigurationWhereInput
    orderBy?: SSOConfigurationOrderByWithRelationInput | SSOConfigurationOrderByWithRelationInput[]
    cursor?: SSOConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SSOConfigurationScalarFieldEnum | SSOConfigurationScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    id: number | null
    orgId: number | null
  }

  export type TeamSumAggregateOutputType = {
    id: number | null
    orgId: number | null
  }

  export type TeamMinAggregateOutputType = {
    id: number | null
    name: string | null
    orgId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: number | null
    name: string | null
    orgId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    orgId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    id?: true
    orgId?: true
  }

  export type TeamSumAggregateInputType = {
    id?: true
    orgId?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    orgId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    orgId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    orgId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: number
    name: string
    orgId: number
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "orgId" | "createdAt" | "updatedAt", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      members: Prisma.$TeamMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      orgId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends Team$membersArgs<ExtArgs> = {}>(args?: Subset<T, Team$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'Int'>
    readonly name: FieldRef<"Team", 'String'>
    readonly orgId: FieldRef<"Team", 'Int'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.members
   */
  export type Team$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _avg: TeamMemberAvgAggregateOutputType | null
    _sum: TeamMemberSumAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberAvgAggregateOutputType = {
    id: number | null
    teamId: number | null
    userId: number | null
  }

  export type TeamMemberSumAggregateOutputType = {
    id: number | null
    teamId: number | null
    userId: number | null
  }

  export type TeamMemberMinAggregateOutputType = {
    id: number | null
    teamId: number | null
    userId: number | null
    role: $Enums.TeamRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    id: number | null
    teamId: number | null
    userId: number | null
    role: $Enums.TeamRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMemberCountAggregateOutputType = {
    id: number
    teamId: number
    userId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamMemberAvgAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
  }

  export type TeamMemberSumAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
  }

  export type TeamMemberMinAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMemberCountAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[]
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _avg?: TeamMemberAvgAggregateInputType
    _sum?: TeamMemberSumAggregateInputType
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }

  export type TeamMemberGroupByOutputType = {
    id: number
    teamId: number
    userId: number
    role: $Enums.TeamRole
    createdAt: Date
    updatedAt: Date
    _count: TeamMemberCountAggregateOutputType | null
    _avg: TeamMemberAvgAggregateOutputType | null
    _sum: TeamMemberSumAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectScalar = {
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "userId" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["teamMember"]>
  export type TeamMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMember"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teamId: number
      userId: number
      role: $Enums.TeamRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teamMember"]>
    composites: {}
  }

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> = $Result.GetResult<Prisma.$TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamMemberFindManyArgs>(args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
     */
    create<T extends TeamMemberCreateArgs>(args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMemberCreateManyArgs>(args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamMembers and returns the data saved in the database.
     * @param {TeamMemberCreateManyAndReturnArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
     */
    delete<T extends TeamMemberDeleteArgs>(args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMemberUpdateArgs>(args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers and returns the data updated in the database.
     * @param {TeamMemberUpdateManyAndReturnArgs} args - Arguments to update many TeamMembers.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMember model
   */
  readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMember model
   */
  interface TeamMemberFieldRefs {
    readonly id: FieldRef<"TeamMember", 'Int'>
    readonly teamId: FieldRef<"TeamMember", 'Int'>
    readonly userId: FieldRef<"TeamMember", 'Int'>
    readonly role: FieldRef<"TeamMember", 'TeamRole'>
    readonly createdAt: FieldRef<"TeamMember", 'DateTime'>
    readonly updatedAt: FieldRef<"TeamMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamMember createManyAndReturn
   */
  export type TeamMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
  }

  /**
   * TeamMember updateManyAndReturn
   */
  export type TeamMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to delete.
     */
    limit?: number
  }

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
  }


  /**
   * Model SharedTestCollection
   */

  export type AggregateSharedTestCollection = {
    _count: SharedTestCollectionCountAggregateOutputType | null
    _avg: SharedTestCollectionAvgAggregateOutputType | null
    _sum: SharedTestCollectionSumAggregateOutputType | null
    _min: SharedTestCollectionMinAggregateOutputType | null
    _max: SharedTestCollectionMaxAggregateOutputType | null
  }

  export type SharedTestCollectionAvgAggregateOutputType = {
    id: number | null
    teamId: number | null
    createdBy: number | null
    testIds: number | null
  }

  export type SharedTestCollectionSumAggregateOutputType = {
    id: number | null
    teamId: number | null
    createdBy: number | null
    testIds: number[]
  }

  export type SharedTestCollectionMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    teamId: number | null
    createdBy: number | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SharedTestCollectionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    teamId: number | null
    createdBy: number | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SharedTestCollectionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    teamId: number
    createdBy: number
    isPublic: number
    tags: number
    testIds: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SharedTestCollectionAvgAggregateInputType = {
    id?: true
    teamId?: true
    createdBy?: true
    testIds?: true
  }

  export type SharedTestCollectionSumAggregateInputType = {
    id?: true
    teamId?: true
    createdBy?: true
    testIds?: true
  }

  export type SharedTestCollectionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    teamId?: true
    createdBy?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SharedTestCollectionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    teamId?: true
    createdBy?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SharedTestCollectionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    teamId?: true
    createdBy?: true
    isPublic?: true
    tags?: true
    testIds?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SharedTestCollectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharedTestCollection to aggregate.
     */
    where?: SharedTestCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedTestCollections to fetch.
     */
    orderBy?: SharedTestCollectionOrderByWithRelationInput | SharedTestCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SharedTestCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedTestCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedTestCollections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SharedTestCollections
    **/
    _count?: true | SharedTestCollectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SharedTestCollectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SharedTestCollectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SharedTestCollectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SharedTestCollectionMaxAggregateInputType
  }

  export type GetSharedTestCollectionAggregateType<T extends SharedTestCollectionAggregateArgs> = {
        [P in keyof T & keyof AggregateSharedTestCollection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSharedTestCollection[P]>
      : GetScalarType<T[P], AggregateSharedTestCollection[P]>
  }




  export type SharedTestCollectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedTestCollectionWhereInput
    orderBy?: SharedTestCollectionOrderByWithAggregationInput | SharedTestCollectionOrderByWithAggregationInput[]
    by: SharedTestCollectionScalarFieldEnum[] | SharedTestCollectionScalarFieldEnum
    having?: SharedTestCollectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SharedTestCollectionCountAggregateInputType | true
    _avg?: SharedTestCollectionAvgAggregateInputType
    _sum?: SharedTestCollectionSumAggregateInputType
    _min?: SharedTestCollectionMinAggregateInputType
    _max?: SharedTestCollectionMaxAggregateInputType
  }

  export type SharedTestCollectionGroupByOutputType = {
    id: number
    name: string
    description: string | null
    teamId: number
    createdBy: number
    isPublic: boolean
    tags: string[]
    testIds: number[]
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: SharedTestCollectionCountAggregateOutputType | null
    _avg: SharedTestCollectionAvgAggregateOutputType | null
    _sum: SharedTestCollectionSumAggregateOutputType | null
    _min: SharedTestCollectionMinAggregateOutputType | null
    _max: SharedTestCollectionMaxAggregateOutputType | null
  }

  type GetSharedTestCollectionGroupByPayload<T extends SharedTestCollectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SharedTestCollectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SharedTestCollectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SharedTestCollectionGroupByOutputType[P]>
            : GetScalarType<T[P], SharedTestCollectionGroupByOutputType[P]>
        }
      >
    >


  export type SharedTestCollectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    teamId?: boolean
    createdBy?: boolean
    isPublic?: boolean
    tags?: boolean
    testIds?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sharedTestCollection"]>

  export type SharedTestCollectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    teamId?: boolean
    createdBy?: boolean
    isPublic?: boolean
    tags?: boolean
    testIds?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sharedTestCollection"]>

  export type SharedTestCollectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    teamId?: boolean
    createdBy?: boolean
    isPublic?: boolean
    tags?: boolean
    testIds?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sharedTestCollection"]>

  export type SharedTestCollectionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    teamId?: boolean
    createdBy?: boolean
    isPublic?: boolean
    tags?: boolean
    testIds?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SharedTestCollectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "teamId" | "createdBy" | "isPublic" | "tags" | "testIds" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["sharedTestCollection"]>

  export type $SharedTestCollectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SharedTestCollection"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      teamId: number
      createdBy: number
      isPublic: boolean
      tags: string[]
      testIds: number[]
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sharedTestCollection"]>
    composites: {}
  }

  type SharedTestCollectionGetPayload<S extends boolean | null | undefined | SharedTestCollectionDefaultArgs> = $Result.GetResult<Prisma.$SharedTestCollectionPayload, S>

  type SharedTestCollectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SharedTestCollectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SharedTestCollectionCountAggregateInputType | true
    }

  export interface SharedTestCollectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SharedTestCollection'], meta: { name: 'SharedTestCollection' } }
    /**
     * Find zero or one SharedTestCollection that matches the filter.
     * @param {SharedTestCollectionFindUniqueArgs} args - Arguments to find a SharedTestCollection
     * @example
     * // Get one SharedTestCollection
     * const sharedTestCollection = await prisma.sharedTestCollection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SharedTestCollectionFindUniqueArgs>(args: SelectSubset<T, SharedTestCollectionFindUniqueArgs<ExtArgs>>): Prisma__SharedTestCollectionClient<$Result.GetResult<Prisma.$SharedTestCollectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SharedTestCollection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SharedTestCollectionFindUniqueOrThrowArgs} args - Arguments to find a SharedTestCollection
     * @example
     * // Get one SharedTestCollection
     * const sharedTestCollection = await prisma.sharedTestCollection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SharedTestCollectionFindUniqueOrThrowArgs>(args: SelectSubset<T, SharedTestCollectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SharedTestCollectionClient<$Result.GetResult<Prisma.$SharedTestCollectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SharedTestCollection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedTestCollectionFindFirstArgs} args - Arguments to find a SharedTestCollection
     * @example
     * // Get one SharedTestCollection
     * const sharedTestCollection = await prisma.sharedTestCollection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SharedTestCollectionFindFirstArgs>(args?: SelectSubset<T, SharedTestCollectionFindFirstArgs<ExtArgs>>): Prisma__SharedTestCollectionClient<$Result.GetResult<Prisma.$SharedTestCollectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SharedTestCollection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedTestCollectionFindFirstOrThrowArgs} args - Arguments to find a SharedTestCollection
     * @example
     * // Get one SharedTestCollection
     * const sharedTestCollection = await prisma.sharedTestCollection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SharedTestCollectionFindFirstOrThrowArgs>(args?: SelectSubset<T, SharedTestCollectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SharedTestCollectionClient<$Result.GetResult<Prisma.$SharedTestCollectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SharedTestCollections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedTestCollectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SharedTestCollections
     * const sharedTestCollections = await prisma.sharedTestCollection.findMany()
     * 
     * // Get first 10 SharedTestCollections
     * const sharedTestCollections = await prisma.sharedTestCollection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sharedTestCollectionWithIdOnly = await prisma.sharedTestCollection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SharedTestCollectionFindManyArgs>(args?: SelectSubset<T, SharedTestCollectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedTestCollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SharedTestCollection.
     * @param {SharedTestCollectionCreateArgs} args - Arguments to create a SharedTestCollection.
     * @example
     * // Create one SharedTestCollection
     * const SharedTestCollection = await prisma.sharedTestCollection.create({
     *   data: {
     *     // ... data to create a SharedTestCollection
     *   }
     * })
     * 
     */
    create<T extends SharedTestCollectionCreateArgs>(args: SelectSubset<T, SharedTestCollectionCreateArgs<ExtArgs>>): Prisma__SharedTestCollectionClient<$Result.GetResult<Prisma.$SharedTestCollectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SharedTestCollections.
     * @param {SharedTestCollectionCreateManyArgs} args - Arguments to create many SharedTestCollections.
     * @example
     * // Create many SharedTestCollections
     * const sharedTestCollection = await prisma.sharedTestCollection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SharedTestCollectionCreateManyArgs>(args?: SelectSubset<T, SharedTestCollectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SharedTestCollections and returns the data saved in the database.
     * @param {SharedTestCollectionCreateManyAndReturnArgs} args - Arguments to create many SharedTestCollections.
     * @example
     * // Create many SharedTestCollections
     * const sharedTestCollection = await prisma.sharedTestCollection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SharedTestCollections and only return the `id`
     * const sharedTestCollectionWithIdOnly = await prisma.sharedTestCollection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SharedTestCollectionCreateManyAndReturnArgs>(args?: SelectSubset<T, SharedTestCollectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedTestCollectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SharedTestCollection.
     * @param {SharedTestCollectionDeleteArgs} args - Arguments to delete one SharedTestCollection.
     * @example
     * // Delete one SharedTestCollection
     * const SharedTestCollection = await prisma.sharedTestCollection.delete({
     *   where: {
     *     // ... filter to delete one SharedTestCollection
     *   }
     * })
     * 
     */
    delete<T extends SharedTestCollectionDeleteArgs>(args: SelectSubset<T, SharedTestCollectionDeleteArgs<ExtArgs>>): Prisma__SharedTestCollectionClient<$Result.GetResult<Prisma.$SharedTestCollectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SharedTestCollection.
     * @param {SharedTestCollectionUpdateArgs} args - Arguments to update one SharedTestCollection.
     * @example
     * // Update one SharedTestCollection
     * const sharedTestCollection = await prisma.sharedTestCollection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SharedTestCollectionUpdateArgs>(args: SelectSubset<T, SharedTestCollectionUpdateArgs<ExtArgs>>): Prisma__SharedTestCollectionClient<$Result.GetResult<Prisma.$SharedTestCollectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SharedTestCollections.
     * @param {SharedTestCollectionDeleteManyArgs} args - Arguments to filter SharedTestCollections to delete.
     * @example
     * // Delete a few SharedTestCollections
     * const { count } = await prisma.sharedTestCollection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SharedTestCollectionDeleteManyArgs>(args?: SelectSubset<T, SharedTestCollectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharedTestCollections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedTestCollectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SharedTestCollections
     * const sharedTestCollection = await prisma.sharedTestCollection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SharedTestCollectionUpdateManyArgs>(args: SelectSubset<T, SharedTestCollectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharedTestCollections and returns the data updated in the database.
     * @param {SharedTestCollectionUpdateManyAndReturnArgs} args - Arguments to update many SharedTestCollections.
     * @example
     * // Update many SharedTestCollections
     * const sharedTestCollection = await prisma.sharedTestCollection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SharedTestCollections and only return the `id`
     * const sharedTestCollectionWithIdOnly = await prisma.sharedTestCollection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SharedTestCollectionUpdateManyAndReturnArgs>(args: SelectSubset<T, SharedTestCollectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedTestCollectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SharedTestCollection.
     * @param {SharedTestCollectionUpsertArgs} args - Arguments to update or create a SharedTestCollection.
     * @example
     * // Update or create a SharedTestCollection
     * const sharedTestCollection = await prisma.sharedTestCollection.upsert({
     *   create: {
     *     // ... data to create a SharedTestCollection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SharedTestCollection we want to update
     *   }
     * })
     */
    upsert<T extends SharedTestCollectionUpsertArgs>(args: SelectSubset<T, SharedTestCollectionUpsertArgs<ExtArgs>>): Prisma__SharedTestCollectionClient<$Result.GetResult<Prisma.$SharedTestCollectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SharedTestCollections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedTestCollectionCountArgs} args - Arguments to filter SharedTestCollections to count.
     * @example
     * // Count the number of SharedTestCollections
     * const count = await prisma.sharedTestCollection.count({
     *   where: {
     *     // ... the filter for the SharedTestCollections we want to count
     *   }
     * })
    **/
    count<T extends SharedTestCollectionCountArgs>(
      args?: Subset<T, SharedTestCollectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SharedTestCollectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SharedTestCollection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedTestCollectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SharedTestCollectionAggregateArgs>(args: Subset<T, SharedTestCollectionAggregateArgs>): Prisma.PrismaPromise<GetSharedTestCollectionAggregateType<T>>

    /**
     * Group by SharedTestCollection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedTestCollectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SharedTestCollectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SharedTestCollectionGroupByArgs['orderBy'] }
        : { orderBy?: SharedTestCollectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SharedTestCollectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSharedTestCollectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SharedTestCollection model
   */
  readonly fields: SharedTestCollectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SharedTestCollection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SharedTestCollectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SharedTestCollection model
   */
  interface SharedTestCollectionFieldRefs {
    readonly id: FieldRef<"SharedTestCollection", 'Int'>
    readonly name: FieldRef<"SharedTestCollection", 'String'>
    readonly description: FieldRef<"SharedTestCollection", 'String'>
    readonly teamId: FieldRef<"SharedTestCollection", 'Int'>
    readonly createdBy: FieldRef<"SharedTestCollection", 'Int'>
    readonly isPublic: FieldRef<"SharedTestCollection", 'Boolean'>
    readonly tags: FieldRef<"SharedTestCollection", 'String[]'>
    readonly testIds: FieldRef<"SharedTestCollection", 'Int[]'>
    readonly metadata: FieldRef<"SharedTestCollection", 'Json'>
    readonly createdAt: FieldRef<"SharedTestCollection", 'DateTime'>
    readonly updatedAt: FieldRef<"SharedTestCollection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SharedTestCollection findUnique
   */
  export type SharedTestCollectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedTestCollection
     */
    select?: SharedTestCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedTestCollection
     */
    omit?: SharedTestCollectionOmit<ExtArgs> | null
    /**
     * Filter, which SharedTestCollection to fetch.
     */
    where: SharedTestCollectionWhereUniqueInput
  }

  /**
   * SharedTestCollection findUniqueOrThrow
   */
  export type SharedTestCollectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedTestCollection
     */
    select?: SharedTestCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedTestCollection
     */
    omit?: SharedTestCollectionOmit<ExtArgs> | null
    /**
     * Filter, which SharedTestCollection to fetch.
     */
    where: SharedTestCollectionWhereUniqueInput
  }

  /**
   * SharedTestCollection findFirst
   */
  export type SharedTestCollectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedTestCollection
     */
    select?: SharedTestCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedTestCollection
     */
    omit?: SharedTestCollectionOmit<ExtArgs> | null
    /**
     * Filter, which SharedTestCollection to fetch.
     */
    where?: SharedTestCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedTestCollections to fetch.
     */
    orderBy?: SharedTestCollectionOrderByWithRelationInput | SharedTestCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharedTestCollections.
     */
    cursor?: SharedTestCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedTestCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedTestCollections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharedTestCollections.
     */
    distinct?: SharedTestCollectionScalarFieldEnum | SharedTestCollectionScalarFieldEnum[]
  }

  /**
   * SharedTestCollection findFirstOrThrow
   */
  export type SharedTestCollectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedTestCollection
     */
    select?: SharedTestCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedTestCollection
     */
    omit?: SharedTestCollectionOmit<ExtArgs> | null
    /**
     * Filter, which SharedTestCollection to fetch.
     */
    where?: SharedTestCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedTestCollections to fetch.
     */
    orderBy?: SharedTestCollectionOrderByWithRelationInput | SharedTestCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharedTestCollections.
     */
    cursor?: SharedTestCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedTestCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedTestCollections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharedTestCollections.
     */
    distinct?: SharedTestCollectionScalarFieldEnum | SharedTestCollectionScalarFieldEnum[]
  }

  /**
   * SharedTestCollection findMany
   */
  export type SharedTestCollectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedTestCollection
     */
    select?: SharedTestCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedTestCollection
     */
    omit?: SharedTestCollectionOmit<ExtArgs> | null
    /**
     * Filter, which SharedTestCollections to fetch.
     */
    where?: SharedTestCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedTestCollections to fetch.
     */
    orderBy?: SharedTestCollectionOrderByWithRelationInput | SharedTestCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SharedTestCollections.
     */
    cursor?: SharedTestCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedTestCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedTestCollections.
     */
    skip?: number
    distinct?: SharedTestCollectionScalarFieldEnum | SharedTestCollectionScalarFieldEnum[]
  }

  /**
   * SharedTestCollection create
   */
  export type SharedTestCollectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedTestCollection
     */
    select?: SharedTestCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedTestCollection
     */
    omit?: SharedTestCollectionOmit<ExtArgs> | null
    /**
     * The data needed to create a SharedTestCollection.
     */
    data: XOR<SharedTestCollectionCreateInput, SharedTestCollectionUncheckedCreateInput>
  }

  /**
   * SharedTestCollection createMany
   */
  export type SharedTestCollectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SharedTestCollections.
     */
    data: SharedTestCollectionCreateManyInput | SharedTestCollectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SharedTestCollection createManyAndReturn
   */
  export type SharedTestCollectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedTestCollection
     */
    select?: SharedTestCollectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SharedTestCollection
     */
    omit?: SharedTestCollectionOmit<ExtArgs> | null
    /**
     * The data used to create many SharedTestCollections.
     */
    data: SharedTestCollectionCreateManyInput | SharedTestCollectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SharedTestCollection update
   */
  export type SharedTestCollectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedTestCollection
     */
    select?: SharedTestCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedTestCollection
     */
    omit?: SharedTestCollectionOmit<ExtArgs> | null
    /**
     * The data needed to update a SharedTestCollection.
     */
    data: XOR<SharedTestCollectionUpdateInput, SharedTestCollectionUncheckedUpdateInput>
    /**
     * Choose, which SharedTestCollection to update.
     */
    where: SharedTestCollectionWhereUniqueInput
  }

  /**
   * SharedTestCollection updateMany
   */
  export type SharedTestCollectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SharedTestCollections.
     */
    data: XOR<SharedTestCollectionUpdateManyMutationInput, SharedTestCollectionUncheckedUpdateManyInput>
    /**
     * Filter which SharedTestCollections to update
     */
    where?: SharedTestCollectionWhereInput
    /**
     * Limit how many SharedTestCollections to update.
     */
    limit?: number
  }

  /**
   * SharedTestCollection updateManyAndReturn
   */
  export type SharedTestCollectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedTestCollection
     */
    select?: SharedTestCollectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SharedTestCollection
     */
    omit?: SharedTestCollectionOmit<ExtArgs> | null
    /**
     * The data used to update SharedTestCollections.
     */
    data: XOR<SharedTestCollectionUpdateManyMutationInput, SharedTestCollectionUncheckedUpdateManyInput>
    /**
     * Filter which SharedTestCollections to update
     */
    where?: SharedTestCollectionWhereInput
    /**
     * Limit how many SharedTestCollections to update.
     */
    limit?: number
  }

  /**
   * SharedTestCollection upsert
   */
  export type SharedTestCollectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedTestCollection
     */
    select?: SharedTestCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedTestCollection
     */
    omit?: SharedTestCollectionOmit<ExtArgs> | null
    /**
     * The filter to search for the SharedTestCollection to update in case it exists.
     */
    where: SharedTestCollectionWhereUniqueInput
    /**
     * In case the SharedTestCollection found by the `where` argument doesn't exist, create a new SharedTestCollection with this data.
     */
    create: XOR<SharedTestCollectionCreateInput, SharedTestCollectionUncheckedCreateInput>
    /**
     * In case the SharedTestCollection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SharedTestCollectionUpdateInput, SharedTestCollectionUncheckedUpdateInput>
  }

  /**
   * SharedTestCollection delete
   */
  export type SharedTestCollectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedTestCollection
     */
    select?: SharedTestCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedTestCollection
     */
    omit?: SharedTestCollectionOmit<ExtArgs> | null
    /**
     * Filter which SharedTestCollection to delete.
     */
    where: SharedTestCollectionWhereUniqueInput
  }

  /**
   * SharedTestCollection deleteMany
   */
  export type SharedTestCollectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharedTestCollections to delete
     */
    where?: SharedTestCollectionWhereInput
    /**
     * Limit how many SharedTestCollections to delete.
     */
    limit?: number
  }

  /**
   * SharedTestCollection without action
   */
  export type SharedTestCollectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedTestCollection
     */
    select?: SharedTestCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedTestCollection
     */
    omit?: SharedTestCollectionOmit<ExtArgs> | null
  }


  /**
   * Model RateLimitQuota
   */

  export type AggregateRateLimitQuota = {
    _count: RateLimitQuotaCountAggregateOutputType | null
    _avg: RateLimitQuotaAvgAggregateOutputType | null
    _sum: RateLimitQuotaSumAggregateOutputType | null
    _min: RateLimitQuotaMinAggregateOutputType | null
    _max: RateLimitQuotaMaxAggregateOutputType | null
  }

  export type RateLimitQuotaAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    limit: number | null
    used: number | null
    windowMinutes: number | null
  }

  export type RateLimitQuotaSumAggregateOutputType = {
    id: number | null
    userId: number | null
    limit: number | null
    used: number | null
    windowMinutes: number | null
  }

  export type RateLimitQuotaMinAggregateOutputType = {
    id: number | null
    userId: number | null
    provider: string | null
    endpoint: string | null
    limit: number | null
    used: number | null
    resetAt: Date | null
    windowMinutes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RateLimitQuotaMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    provider: string | null
    endpoint: string | null
    limit: number | null
    used: number | null
    resetAt: Date | null
    windowMinutes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RateLimitQuotaCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    endpoint: number
    limit: number
    used: number
    resetAt: number
    windowMinutes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RateLimitQuotaAvgAggregateInputType = {
    id?: true
    userId?: true
    limit?: true
    used?: true
    windowMinutes?: true
  }

  export type RateLimitQuotaSumAggregateInputType = {
    id?: true
    userId?: true
    limit?: true
    used?: true
    windowMinutes?: true
  }

  export type RateLimitQuotaMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    endpoint?: true
    limit?: true
    used?: true
    resetAt?: true
    windowMinutes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RateLimitQuotaMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    endpoint?: true
    limit?: true
    used?: true
    resetAt?: true
    windowMinutes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RateLimitQuotaCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    endpoint?: true
    limit?: true
    used?: true
    resetAt?: true
    windowMinutes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RateLimitQuotaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RateLimitQuota to aggregate.
     */
    where?: RateLimitQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateLimitQuotas to fetch.
     */
    orderBy?: RateLimitQuotaOrderByWithRelationInput | RateLimitQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RateLimitQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateLimitQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateLimitQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RateLimitQuotas
    **/
    _count?: true | RateLimitQuotaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RateLimitQuotaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RateLimitQuotaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RateLimitQuotaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RateLimitQuotaMaxAggregateInputType
  }

  export type GetRateLimitQuotaAggregateType<T extends RateLimitQuotaAggregateArgs> = {
        [P in keyof T & keyof AggregateRateLimitQuota]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRateLimitQuota[P]>
      : GetScalarType<T[P], AggregateRateLimitQuota[P]>
  }




  export type RateLimitQuotaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RateLimitQuotaWhereInput
    orderBy?: RateLimitQuotaOrderByWithAggregationInput | RateLimitQuotaOrderByWithAggregationInput[]
    by: RateLimitQuotaScalarFieldEnum[] | RateLimitQuotaScalarFieldEnum
    having?: RateLimitQuotaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RateLimitQuotaCountAggregateInputType | true
    _avg?: RateLimitQuotaAvgAggregateInputType
    _sum?: RateLimitQuotaSumAggregateInputType
    _min?: RateLimitQuotaMinAggregateInputType
    _max?: RateLimitQuotaMaxAggregateInputType
  }

  export type RateLimitQuotaGroupByOutputType = {
    id: number
    userId: number
    provider: string
    endpoint: string
    limit: number
    used: number
    resetAt: Date
    windowMinutes: number
    createdAt: Date
    updatedAt: Date
    _count: RateLimitQuotaCountAggregateOutputType | null
    _avg: RateLimitQuotaAvgAggregateOutputType | null
    _sum: RateLimitQuotaSumAggregateOutputType | null
    _min: RateLimitQuotaMinAggregateOutputType | null
    _max: RateLimitQuotaMaxAggregateOutputType | null
  }

  type GetRateLimitQuotaGroupByPayload<T extends RateLimitQuotaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RateLimitQuotaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RateLimitQuotaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RateLimitQuotaGroupByOutputType[P]>
            : GetScalarType<T[P], RateLimitQuotaGroupByOutputType[P]>
        }
      >
    >


  export type RateLimitQuotaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    endpoint?: boolean
    limit?: boolean
    used?: boolean
    resetAt?: boolean
    windowMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["rateLimitQuota"]>

  export type RateLimitQuotaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    endpoint?: boolean
    limit?: boolean
    used?: boolean
    resetAt?: boolean
    windowMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["rateLimitQuota"]>

  export type RateLimitQuotaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    endpoint?: boolean
    limit?: boolean
    used?: boolean
    resetAt?: boolean
    windowMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["rateLimitQuota"]>

  export type RateLimitQuotaSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    endpoint?: boolean
    limit?: boolean
    used?: boolean
    resetAt?: boolean
    windowMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RateLimitQuotaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "provider" | "endpoint" | "limit" | "used" | "resetAt" | "windowMinutes" | "createdAt" | "updatedAt", ExtArgs["result"]["rateLimitQuota"]>

  export type $RateLimitQuotaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RateLimitQuota"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      provider: string
      endpoint: string
      limit: number
      used: number
      resetAt: Date
      windowMinutes: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rateLimitQuota"]>
    composites: {}
  }

  type RateLimitQuotaGetPayload<S extends boolean | null | undefined | RateLimitQuotaDefaultArgs> = $Result.GetResult<Prisma.$RateLimitQuotaPayload, S>

  type RateLimitQuotaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RateLimitQuotaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RateLimitQuotaCountAggregateInputType | true
    }

  export interface RateLimitQuotaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RateLimitQuota'], meta: { name: 'RateLimitQuota' } }
    /**
     * Find zero or one RateLimitQuota that matches the filter.
     * @param {RateLimitQuotaFindUniqueArgs} args - Arguments to find a RateLimitQuota
     * @example
     * // Get one RateLimitQuota
     * const rateLimitQuota = await prisma.rateLimitQuota.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RateLimitQuotaFindUniqueArgs>(args: SelectSubset<T, RateLimitQuotaFindUniqueArgs<ExtArgs>>): Prisma__RateLimitQuotaClient<$Result.GetResult<Prisma.$RateLimitQuotaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RateLimitQuota that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RateLimitQuotaFindUniqueOrThrowArgs} args - Arguments to find a RateLimitQuota
     * @example
     * // Get one RateLimitQuota
     * const rateLimitQuota = await prisma.rateLimitQuota.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RateLimitQuotaFindUniqueOrThrowArgs>(args: SelectSubset<T, RateLimitQuotaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RateLimitQuotaClient<$Result.GetResult<Prisma.$RateLimitQuotaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RateLimitQuota that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitQuotaFindFirstArgs} args - Arguments to find a RateLimitQuota
     * @example
     * // Get one RateLimitQuota
     * const rateLimitQuota = await prisma.rateLimitQuota.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RateLimitQuotaFindFirstArgs>(args?: SelectSubset<T, RateLimitQuotaFindFirstArgs<ExtArgs>>): Prisma__RateLimitQuotaClient<$Result.GetResult<Prisma.$RateLimitQuotaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RateLimitQuota that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitQuotaFindFirstOrThrowArgs} args - Arguments to find a RateLimitQuota
     * @example
     * // Get one RateLimitQuota
     * const rateLimitQuota = await prisma.rateLimitQuota.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RateLimitQuotaFindFirstOrThrowArgs>(args?: SelectSubset<T, RateLimitQuotaFindFirstOrThrowArgs<ExtArgs>>): Prisma__RateLimitQuotaClient<$Result.GetResult<Prisma.$RateLimitQuotaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RateLimitQuotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitQuotaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RateLimitQuotas
     * const rateLimitQuotas = await prisma.rateLimitQuota.findMany()
     * 
     * // Get first 10 RateLimitQuotas
     * const rateLimitQuotas = await prisma.rateLimitQuota.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rateLimitQuotaWithIdOnly = await prisma.rateLimitQuota.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RateLimitQuotaFindManyArgs>(args?: SelectSubset<T, RateLimitQuotaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RateLimitQuotaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RateLimitQuota.
     * @param {RateLimitQuotaCreateArgs} args - Arguments to create a RateLimitQuota.
     * @example
     * // Create one RateLimitQuota
     * const RateLimitQuota = await prisma.rateLimitQuota.create({
     *   data: {
     *     // ... data to create a RateLimitQuota
     *   }
     * })
     * 
     */
    create<T extends RateLimitQuotaCreateArgs>(args: SelectSubset<T, RateLimitQuotaCreateArgs<ExtArgs>>): Prisma__RateLimitQuotaClient<$Result.GetResult<Prisma.$RateLimitQuotaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RateLimitQuotas.
     * @param {RateLimitQuotaCreateManyArgs} args - Arguments to create many RateLimitQuotas.
     * @example
     * // Create many RateLimitQuotas
     * const rateLimitQuota = await prisma.rateLimitQuota.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RateLimitQuotaCreateManyArgs>(args?: SelectSubset<T, RateLimitQuotaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RateLimitQuotas and returns the data saved in the database.
     * @param {RateLimitQuotaCreateManyAndReturnArgs} args - Arguments to create many RateLimitQuotas.
     * @example
     * // Create many RateLimitQuotas
     * const rateLimitQuota = await prisma.rateLimitQuota.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RateLimitQuotas and only return the `id`
     * const rateLimitQuotaWithIdOnly = await prisma.rateLimitQuota.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RateLimitQuotaCreateManyAndReturnArgs>(args?: SelectSubset<T, RateLimitQuotaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RateLimitQuotaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RateLimitQuota.
     * @param {RateLimitQuotaDeleteArgs} args - Arguments to delete one RateLimitQuota.
     * @example
     * // Delete one RateLimitQuota
     * const RateLimitQuota = await prisma.rateLimitQuota.delete({
     *   where: {
     *     // ... filter to delete one RateLimitQuota
     *   }
     * })
     * 
     */
    delete<T extends RateLimitQuotaDeleteArgs>(args: SelectSubset<T, RateLimitQuotaDeleteArgs<ExtArgs>>): Prisma__RateLimitQuotaClient<$Result.GetResult<Prisma.$RateLimitQuotaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RateLimitQuota.
     * @param {RateLimitQuotaUpdateArgs} args - Arguments to update one RateLimitQuota.
     * @example
     * // Update one RateLimitQuota
     * const rateLimitQuota = await prisma.rateLimitQuota.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RateLimitQuotaUpdateArgs>(args: SelectSubset<T, RateLimitQuotaUpdateArgs<ExtArgs>>): Prisma__RateLimitQuotaClient<$Result.GetResult<Prisma.$RateLimitQuotaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RateLimitQuotas.
     * @param {RateLimitQuotaDeleteManyArgs} args - Arguments to filter RateLimitQuotas to delete.
     * @example
     * // Delete a few RateLimitQuotas
     * const { count } = await prisma.rateLimitQuota.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RateLimitQuotaDeleteManyArgs>(args?: SelectSubset<T, RateLimitQuotaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RateLimitQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitQuotaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RateLimitQuotas
     * const rateLimitQuota = await prisma.rateLimitQuota.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RateLimitQuotaUpdateManyArgs>(args: SelectSubset<T, RateLimitQuotaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RateLimitQuotas and returns the data updated in the database.
     * @param {RateLimitQuotaUpdateManyAndReturnArgs} args - Arguments to update many RateLimitQuotas.
     * @example
     * // Update many RateLimitQuotas
     * const rateLimitQuota = await prisma.rateLimitQuota.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RateLimitQuotas and only return the `id`
     * const rateLimitQuotaWithIdOnly = await prisma.rateLimitQuota.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RateLimitQuotaUpdateManyAndReturnArgs>(args: SelectSubset<T, RateLimitQuotaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RateLimitQuotaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RateLimitQuota.
     * @param {RateLimitQuotaUpsertArgs} args - Arguments to update or create a RateLimitQuota.
     * @example
     * // Update or create a RateLimitQuota
     * const rateLimitQuota = await prisma.rateLimitQuota.upsert({
     *   create: {
     *     // ... data to create a RateLimitQuota
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RateLimitQuota we want to update
     *   }
     * })
     */
    upsert<T extends RateLimitQuotaUpsertArgs>(args: SelectSubset<T, RateLimitQuotaUpsertArgs<ExtArgs>>): Prisma__RateLimitQuotaClient<$Result.GetResult<Prisma.$RateLimitQuotaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RateLimitQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitQuotaCountArgs} args - Arguments to filter RateLimitQuotas to count.
     * @example
     * // Count the number of RateLimitQuotas
     * const count = await prisma.rateLimitQuota.count({
     *   where: {
     *     // ... the filter for the RateLimitQuotas we want to count
     *   }
     * })
    **/
    count<T extends RateLimitQuotaCountArgs>(
      args?: Subset<T, RateLimitQuotaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RateLimitQuotaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RateLimitQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitQuotaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RateLimitQuotaAggregateArgs>(args: Subset<T, RateLimitQuotaAggregateArgs>): Prisma.PrismaPromise<GetRateLimitQuotaAggregateType<T>>

    /**
     * Group by RateLimitQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitQuotaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RateLimitQuotaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RateLimitQuotaGroupByArgs['orderBy'] }
        : { orderBy?: RateLimitQuotaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RateLimitQuotaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRateLimitQuotaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RateLimitQuota model
   */
  readonly fields: RateLimitQuotaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RateLimitQuota.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RateLimitQuotaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RateLimitQuota model
   */
  interface RateLimitQuotaFieldRefs {
    readonly id: FieldRef<"RateLimitQuota", 'Int'>
    readonly userId: FieldRef<"RateLimitQuota", 'Int'>
    readonly provider: FieldRef<"RateLimitQuota", 'String'>
    readonly endpoint: FieldRef<"RateLimitQuota", 'String'>
    readonly limit: FieldRef<"RateLimitQuota", 'Int'>
    readonly used: FieldRef<"RateLimitQuota", 'Int'>
    readonly resetAt: FieldRef<"RateLimitQuota", 'DateTime'>
    readonly windowMinutes: FieldRef<"RateLimitQuota", 'Int'>
    readonly createdAt: FieldRef<"RateLimitQuota", 'DateTime'>
    readonly updatedAt: FieldRef<"RateLimitQuota", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RateLimitQuota findUnique
   */
  export type RateLimitQuotaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitQuota
     */
    select?: RateLimitQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimitQuota
     */
    omit?: RateLimitQuotaOmit<ExtArgs> | null
    /**
     * Filter, which RateLimitQuota to fetch.
     */
    where: RateLimitQuotaWhereUniqueInput
  }

  /**
   * RateLimitQuota findUniqueOrThrow
   */
  export type RateLimitQuotaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitQuota
     */
    select?: RateLimitQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimitQuota
     */
    omit?: RateLimitQuotaOmit<ExtArgs> | null
    /**
     * Filter, which RateLimitQuota to fetch.
     */
    where: RateLimitQuotaWhereUniqueInput
  }

  /**
   * RateLimitQuota findFirst
   */
  export type RateLimitQuotaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitQuota
     */
    select?: RateLimitQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimitQuota
     */
    omit?: RateLimitQuotaOmit<ExtArgs> | null
    /**
     * Filter, which RateLimitQuota to fetch.
     */
    where?: RateLimitQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateLimitQuotas to fetch.
     */
    orderBy?: RateLimitQuotaOrderByWithRelationInput | RateLimitQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RateLimitQuotas.
     */
    cursor?: RateLimitQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateLimitQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateLimitQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RateLimitQuotas.
     */
    distinct?: RateLimitQuotaScalarFieldEnum | RateLimitQuotaScalarFieldEnum[]
  }

  /**
   * RateLimitQuota findFirstOrThrow
   */
  export type RateLimitQuotaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitQuota
     */
    select?: RateLimitQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimitQuota
     */
    omit?: RateLimitQuotaOmit<ExtArgs> | null
    /**
     * Filter, which RateLimitQuota to fetch.
     */
    where?: RateLimitQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateLimitQuotas to fetch.
     */
    orderBy?: RateLimitQuotaOrderByWithRelationInput | RateLimitQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RateLimitQuotas.
     */
    cursor?: RateLimitQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateLimitQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateLimitQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RateLimitQuotas.
     */
    distinct?: RateLimitQuotaScalarFieldEnum | RateLimitQuotaScalarFieldEnum[]
  }

  /**
   * RateLimitQuota findMany
   */
  export type RateLimitQuotaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitQuota
     */
    select?: RateLimitQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimitQuota
     */
    omit?: RateLimitQuotaOmit<ExtArgs> | null
    /**
     * Filter, which RateLimitQuotas to fetch.
     */
    where?: RateLimitQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateLimitQuotas to fetch.
     */
    orderBy?: RateLimitQuotaOrderByWithRelationInput | RateLimitQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RateLimitQuotas.
     */
    cursor?: RateLimitQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateLimitQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateLimitQuotas.
     */
    skip?: number
    distinct?: RateLimitQuotaScalarFieldEnum | RateLimitQuotaScalarFieldEnum[]
  }

  /**
   * RateLimitQuota create
   */
  export type RateLimitQuotaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitQuota
     */
    select?: RateLimitQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimitQuota
     */
    omit?: RateLimitQuotaOmit<ExtArgs> | null
    /**
     * The data needed to create a RateLimitQuota.
     */
    data: XOR<RateLimitQuotaCreateInput, RateLimitQuotaUncheckedCreateInput>
  }

  /**
   * RateLimitQuota createMany
   */
  export type RateLimitQuotaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RateLimitQuotas.
     */
    data: RateLimitQuotaCreateManyInput | RateLimitQuotaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RateLimitQuota createManyAndReturn
   */
  export type RateLimitQuotaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitQuota
     */
    select?: RateLimitQuotaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimitQuota
     */
    omit?: RateLimitQuotaOmit<ExtArgs> | null
    /**
     * The data used to create many RateLimitQuotas.
     */
    data: RateLimitQuotaCreateManyInput | RateLimitQuotaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RateLimitQuota update
   */
  export type RateLimitQuotaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitQuota
     */
    select?: RateLimitQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimitQuota
     */
    omit?: RateLimitQuotaOmit<ExtArgs> | null
    /**
     * The data needed to update a RateLimitQuota.
     */
    data: XOR<RateLimitQuotaUpdateInput, RateLimitQuotaUncheckedUpdateInput>
    /**
     * Choose, which RateLimitQuota to update.
     */
    where: RateLimitQuotaWhereUniqueInput
  }

  /**
   * RateLimitQuota updateMany
   */
  export type RateLimitQuotaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RateLimitQuotas.
     */
    data: XOR<RateLimitQuotaUpdateManyMutationInput, RateLimitQuotaUncheckedUpdateManyInput>
    /**
     * Filter which RateLimitQuotas to update
     */
    where?: RateLimitQuotaWhereInput
    /**
     * Limit how many RateLimitQuotas to update.
     */
    limit?: number
  }

  /**
   * RateLimitQuota updateManyAndReturn
   */
  export type RateLimitQuotaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitQuota
     */
    select?: RateLimitQuotaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimitQuota
     */
    omit?: RateLimitQuotaOmit<ExtArgs> | null
    /**
     * The data used to update RateLimitQuotas.
     */
    data: XOR<RateLimitQuotaUpdateManyMutationInput, RateLimitQuotaUncheckedUpdateManyInput>
    /**
     * Filter which RateLimitQuotas to update
     */
    where?: RateLimitQuotaWhereInput
    /**
     * Limit how many RateLimitQuotas to update.
     */
    limit?: number
  }

  /**
   * RateLimitQuota upsert
   */
  export type RateLimitQuotaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitQuota
     */
    select?: RateLimitQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimitQuota
     */
    omit?: RateLimitQuotaOmit<ExtArgs> | null
    /**
     * The filter to search for the RateLimitQuota to update in case it exists.
     */
    where: RateLimitQuotaWhereUniqueInput
    /**
     * In case the RateLimitQuota found by the `where` argument doesn't exist, create a new RateLimitQuota with this data.
     */
    create: XOR<RateLimitQuotaCreateInput, RateLimitQuotaUncheckedCreateInput>
    /**
     * In case the RateLimitQuota was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RateLimitQuotaUpdateInput, RateLimitQuotaUncheckedUpdateInput>
  }

  /**
   * RateLimitQuota delete
   */
  export type RateLimitQuotaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitQuota
     */
    select?: RateLimitQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimitQuota
     */
    omit?: RateLimitQuotaOmit<ExtArgs> | null
    /**
     * Filter which RateLimitQuota to delete.
     */
    where: RateLimitQuotaWhereUniqueInput
  }

  /**
   * RateLimitQuota deleteMany
   */
  export type RateLimitQuotaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RateLimitQuotas to delete
     */
    where?: RateLimitQuotaWhereInput
    /**
     * Limit how many RateLimitQuotas to delete.
     */
    limit?: number
  }

  /**
   * RateLimitQuota without action
   */
  export type RateLimitQuotaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitQuota
     */
    select?: RateLimitQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimitQuota
     */
    omit?: RateLimitQuotaOmit<ExtArgs> | null
  }


  /**
   * Model TestTemplate
   */

  export type AggregateTestTemplate = {
    _count: TestTemplateCountAggregateOutputType | null
    _avg: TestTemplateAvgAggregateOutputType | null
    _sum: TestTemplateSumAggregateOutputType | null
    _min: TestTemplateMinAggregateOutputType | null
    _max: TestTemplateMaxAggregateOutputType | null
  }

  export type TestTemplateAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    teamId: number | null
    sharedWith: number | null
    useCount: number | null
    favoriteCount: number | null
  }

  export type TestTemplateSumAggregateOutputType = {
    id: number | null
    userId: number | null
    teamId: number | null
    sharedWith: number[]
    useCount: number | null
    favoriteCount: number | null
  }

  export type TestTemplateMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    category: string | null
    userId: number | null
    teamId: number | null
    isPublic: boolean | null
    isPredefined: boolean | null
    useCount: number | null
    favoriteCount: number | null
    version: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestTemplateMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    category: string | null
    userId: number | null
    teamId: number | null
    isPublic: boolean | null
    isPredefined: boolean | null
    useCount: number | null
    favoriteCount: number | null
    version: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    userId: number
    teamId: number
    isPublic: number
    isPredefined: number
    tags: number
    config: number
    sharedWith: number
    useCount: number
    favoriteCount: number
    version: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TestTemplateAvgAggregateInputType = {
    id?: true
    userId?: true
    teamId?: true
    sharedWith?: true
    useCount?: true
    favoriteCount?: true
  }

  export type TestTemplateSumAggregateInputType = {
    id?: true
    userId?: true
    teamId?: true
    sharedWith?: true
    useCount?: true
    favoriteCount?: true
  }

  export type TestTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    userId?: true
    teamId?: true
    isPublic?: true
    isPredefined?: true
    useCount?: true
    favoriteCount?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    userId?: true
    teamId?: true
    isPublic?: true
    isPredefined?: true
    useCount?: true
    favoriteCount?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    userId?: true
    teamId?: true
    isPublic?: true
    isPredefined?: true
    tags?: true
    config?: true
    sharedWith?: true
    useCount?: true
    favoriteCount?: true
    version?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestTemplate to aggregate.
     */
    where?: TestTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestTemplates to fetch.
     */
    orderBy?: TestTemplateOrderByWithRelationInput | TestTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestTemplates
    **/
    _count?: true | TestTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestTemplateMaxAggregateInputType
  }

  export type GetTestTemplateAggregateType<T extends TestTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateTestTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestTemplate[P]>
      : GetScalarType<T[P], AggregateTestTemplate[P]>
  }




  export type TestTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestTemplateWhereInput
    orderBy?: TestTemplateOrderByWithAggregationInput | TestTemplateOrderByWithAggregationInput[]
    by: TestTemplateScalarFieldEnum[] | TestTemplateScalarFieldEnum
    having?: TestTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestTemplateCountAggregateInputType | true
    _avg?: TestTemplateAvgAggregateInputType
    _sum?: TestTemplateSumAggregateInputType
    _min?: TestTemplateMinAggregateInputType
    _max?: TestTemplateMaxAggregateInputType
  }

  export type TestTemplateGroupByOutputType = {
    id: number
    name: string
    description: string | null
    category: string
    userId: number
    teamId: number | null
    isPublic: boolean
    isPredefined: boolean
    tags: string[]
    config: JsonValue
    sharedWith: number[]
    useCount: number
    favoriteCount: number
    version: string
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: TestTemplateCountAggregateOutputType | null
    _avg: TestTemplateAvgAggregateOutputType | null
    _sum: TestTemplateSumAggregateOutputType | null
    _min: TestTemplateMinAggregateOutputType | null
    _max: TestTemplateMaxAggregateOutputType | null
  }

  type GetTestTemplateGroupByPayload<T extends TestTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], TestTemplateGroupByOutputType[P]>
        }
      >
    >


  export type TestTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    userId?: boolean
    teamId?: boolean
    isPublic?: boolean
    isPredefined?: boolean
    tags?: boolean
    config?: boolean
    sharedWith?: boolean
    useCount?: boolean
    favoriteCount?: boolean
    version?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["testTemplate"]>

  export type TestTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    userId?: boolean
    teamId?: boolean
    isPublic?: boolean
    isPredefined?: boolean
    tags?: boolean
    config?: boolean
    sharedWith?: boolean
    useCount?: boolean
    favoriteCount?: boolean
    version?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["testTemplate"]>

  export type TestTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    userId?: boolean
    teamId?: boolean
    isPublic?: boolean
    isPredefined?: boolean
    tags?: boolean
    config?: boolean
    sharedWith?: boolean
    useCount?: boolean
    favoriteCount?: boolean
    version?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["testTemplate"]>

  export type TestTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    userId?: boolean
    teamId?: boolean
    isPublic?: boolean
    isPredefined?: boolean
    tags?: boolean
    config?: boolean
    sharedWith?: boolean
    useCount?: boolean
    favoriteCount?: boolean
    version?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TestTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category" | "userId" | "teamId" | "isPublic" | "isPredefined" | "tags" | "config" | "sharedWith" | "useCount" | "favoriteCount" | "version" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["testTemplate"]>

  export type $TestTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestTemplate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      category: string
      userId: number
      teamId: number | null
      isPublic: boolean
      isPredefined: boolean
      tags: string[]
      config: Prisma.JsonValue
      sharedWith: number[]
      useCount: number
      favoriteCount: number
      version: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testTemplate"]>
    composites: {}
  }

  type TestTemplateGetPayload<S extends boolean | null | undefined | TestTemplateDefaultArgs> = $Result.GetResult<Prisma.$TestTemplatePayload, S>

  type TestTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestTemplateCountAggregateInputType | true
    }

  export interface TestTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestTemplate'], meta: { name: 'TestTemplate' } }
    /**
     * Find zero or one TestTemplate that matches the filter.
     * @param {TestTemplateFindUniqueArgs} args - Arguments to find a TestTemplate
     * @example
     * // Get one TestTemplate
     * const testTemplate = await prisma.testTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestTemplateFindUniqueArgs>(args: SelectSubset<T, TestTemplateFindUniqueArgs<ExtArgs>>): Prisma__TestTemplateClient<$Result.GetResult<Prisma.$TestTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestTemplateFindUniqueOrThrowArgs} args - Arguments to find a TestTemplate
     * @example
     * // Get one TestTemplate
     * const testTemplate = await prisma.testTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, TestTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestTemplateClient<$Result.GetResult<Prisma.$TestTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTemplateFindFirstArgs} args - Arguments to find a TestTemplate
     * @example
     * // Get one TestTemplate
     * const testTemplate = await prisma.testTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestTemplateFindFirstArgs>(args?: SelectSubset<T, TestTemplateFindFirstArgs<ExtArgs>>): Prisma__TestTemplateClient<$Result.GetResult<Prisma.$TestTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTemplateFindFirstOrThrowArgs} args - Arguments to find a TestTemplate
     * @example
     * // Get one TestTemplate
     * const testTemplate = await prisma.testTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, TestTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestTemplateClient<$Result.GetResult<Prisma.$TestTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestTemplates
     * const testTemplates = await prisma.testTemplate.findMany()
     * 
     * // Get first 10 TestTemplates
     * const testTemplates = await prisma.testTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testTemplateWithIdOnly = await prisma.testTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestTemplateFindManyArgs>(args?: SelectSubset<T, TestTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestTemplate.
     * @param {TestTemplateCreateArgs} args - Arguments to create a TestTemplate.
     * @example
     * // Create one TestTemplate
     * const TestTemplate = await prisma.testTemplate.create({
     *   data: {
     *     // ... data to create a TestTemplate
     *   }
     * })
     * 
     */
    create<T extends TestTemplateCreateArgs>(args: SelectSubset<T, TestTemplateCreateArgs<ExtArgs>>): Prisma__TestTemplateClient<$Result.GetResult<Prisma.$TestTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestTemplates.
     * @param {TestTemplateCreateManyArgs} args - Arguments to create many TestTemplates.
     * @example
     * // Create many TestTemplates
     * const testTemplate = await prisma.testTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestTemplateCreateManyArgs>(args?: SelectSubset<T, TestTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestTemplates and returns the data saved in the database.
     * @param {TestTemplateCreateManyAndReturnArgs} args - Arguments to create many TestTemplates.
     * @example
     * // Create many TestTemplates
     * const testTemplate = await prisma.testTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestTemplates and only return the `id`
     * const testTemplateWithIdOnly = await prisma.testTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, TestTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TestTemplate.
     * @param {TestTemplateDeleteArgs} args - Arguments to delete one TestTemplate.
     * @example
     * // Delete one TestTemplate
     * const TestTemplate = await prisma.testTemplate.delete({
     *   where: {
     *     // ... filter to delete one TestTemplate
     *   }
     * })
     * 
     */
    delete<T extends TestTemplateDeleteArgs>(args: SelectSubset<T, TestTemplateDeleteArgs<ExtArgs>>): Prisma__TestTemplateClient<$Result.GetResult<Prisma.$TestTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestTemplate.
     * @param {TestTemplateUpdateArgs} args - Arguments to update one TestTemplate.
     * @example
     * // Update one TestTemplate
     * const testTemplate = await prisma.testTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestTemplateUpdateArgs>(args: SelectSubset<T, TestTemplateUpdateArgs<ExtArgs>>): Prisma__TestTemplateClient<$Result.GetResult<Prisma.$TestTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestTemplates.
     * @param {TestTemplateDeleteManyArgs} args - Arguments to filter TestTemplates to delete.
     * @example
     * // Delete a few TestTemplates
     * const { count } = await prisma.testTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestTemplateDeleteManyArgs>(args?: SelectSubset<T, TestTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestTemplates
     * const testTemplate = await prisma.testTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestTemplateUpdateManyArgs>(args: SelectSubset<T, TestTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestTemplates and returns the data updated in the database.
     * @param {TestTemplateUpdateManyAndReturnArgs} args - Arguments to update many TestTemplates.
     * @example
     * // Update many TestTemplates
     * const testTemplate = await prisma.testTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TestTemplates and only return the `id`
     * const testTemplateWithIdOnly = await prisma.testTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, TestTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TestTemplate.
     * @param {TestTemplateUpsertArgs} args - Arguments to update or create a TestTemplate.
     * @example
     * // Update or create a TestTemplate
     * const testTemplate = await prisma.testTemplate.upsert({
     *   create: {
     *     // ... data to create a TestTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestTemplate we want to update
     *   }
     * })
     */
    upsert<T extends TestTemplateUpsertArgs>(args: SelectSubset<T, TestTemplateUpsertArgs<ExtArgs>>): Prisma__TestTemplateClient<$Result.GetResult<Prisma.$TestTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTemplateCountArgs} args - Arguments to filter TestTemplates to count.
     * @example
     * // Count the number of TestTemplates
     * const count = await prisma.testTemplate.count({
     *   where: {
     *     // ... the filter for the TestTemplates we want to count
     *   }
     * })
    **/
    count<T extends TestTemplateCountArgs>(
      args?: Subset<T, TestTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestTemplateAggregateArgs>(args: Subset<T, TestTemplateAggregateArgs>): Prisma.PrismaPromise<GetTestTemplateAggregateType<T>>

    /**
     * Group by TestTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestTemplateGroupByArgs['orderBy'] }
        : { orderBy?: TestTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestTemplate model
   */
  readonly fields: TestTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestTemplate model
   */
  interface TestTemplateFieldRefs {
    readonly id: FieldRef<"TestTemplate", 'Int'>
    readonly name: FieldRef<"TestTemplate", 'String'>
    readonly description: FieldRef<"TestTemplate", 'String'>
    readonly category: FieldRef<"TestTemplate", 'String'>
    readonly userId: FieldRef<"TestTemplate", 'Int'>
    readonly teamId: FieldRef<"TestTemplate", 'Int'>
    readonly isPublic: FieldRef<"TestTemplate", 'Boolean'>
    readonly isPredefined: FieldRef<"TestTemplate", 'Boolean'>
    readonly tags: FieldRef<"TestTemplate", 'String[]'>
    readonly config: FieldRef<"TestTemplate", 'Json'>
    readonly sharedWith: FieldRef<"TestTemplate", 'Int[]'>
    readonly useCount: FieldRef<"TestTemplate", 'Int'>
    readonly favoriteCount: FieldRef<"TestTemplate", 'Int'>
    readonly version: FieldRef<"TestTemplate", 'String'>
    readonly metadata: FieldRef<"TestTemplate", 'Json'>
    readonly createdAt: FieldRef<"TestTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"TestTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TestTemplate findUnique
   */
  export type TestTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTemplate
     */
    select?: TestTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTemplate
     */
    omit?: TestTemplateOmit<ExtArgs> | null
    /**
     * Filter, which TestTemplate to fetch.
     */
    where: TestTemplateWhereUniqueInput
  }

  /**
   * TestTemplate findUniqueOrThrow
   */
  export type TestTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTemplate
     */
    select?: TestTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTemplate
     */
    omit?: TestTemplateOmit<ExtArgs> | null
    /**
     * Filter, which TestTemplate to fetch.
     */
    where: TestTemplateWhereUniqueInput
  }

  /**
   * TestTemplate findFirst
   */
  export type TestTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTemplate
     */
    select?: TestTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTemplate
     */
    omit?: TestTemplateOmit<ExtArgs> | null
    /**
     * Filter, which TestTemplate to fetch.
     */
    where?: TestTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestTemplates to fetch.
     */
    orderBy?: TestTemplateOrderByWithRelationInput | TestTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestTemplates.
     */
    cursor?: TestTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestTemplates.
     */
    distinct?: TestTemplateScalarFieldEnum | TestTemplateScalarFieldEnum[]
  }

  /**
   * TestTemplate findFirstOrThrow
   */
  export type TestTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTemplate
     */
    select?: TestTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTemplate
     */
    omit?: TestTemplateOmit<ExtArgs> | null
    /**
     * Filter, which TestTemplate to fetch.
     */
    where?: TestTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestTemplates to fetch.
     */
    orderBy?: TestTemplateOrderByWithRelationInput | TestTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestTemplates.
     */
    cursor?: TestTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestTemplates.
     */
    distinct?: TestTemplateScalarFieldEnum | TestTemplateScalarFieldEnum[]
  }

  /**
   * TestTemplate findMany
   */
  export type TestTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTemplate
     */
    select?: TestTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTemplate
     */
    omit?: TestTemplateOmit<ExtArgs> | null
    /**
     * Filter, which TestTemplates to fetch.
     */
    where?: TestTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestTemplates to fetch.
     */
    orderBy?: TestTemplateOrderByWithRelationInput | TestTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestTemplates.
     */
    cursor?: TestTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestTemplates.
     */
    skip?: number
    distinct?: TestTemplateScalarFieldEnum | TestTemplateScalarFieldEnum[]
  }

  /**
   * TestTemplate create
   */
  export type TestTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTemplate
     */
    select?: TestTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTemplate
     */
    omit?: TestTemplateOmit<ExtArgs> | null
    /**
     * The data needed to create a TestTemplate.
     */
    data: XOR<TestTemplateCreateInput, TestTemplateUncheckedCreateInput>
  }

  /**
   * TestTemplate createMany
   */
  export type TestTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestTemplates.
     */
    data: TestTemplateCreateManyInput | TestTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestTemplate createManyAndReturn
   */
  export type TestTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTemplate
     */
    select?: TestTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestTemplate
     */
    omit?: TestTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many TestTemplates.
     */
    data: TestTemplateCreateManyInput | TestTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestTemplate update
   */
  export type TestTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTemplate
     */
    select?: TestTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTemplate
     */
    omit?: TestTemplateOmit<ExtArgs> | null
    /**
     * The data needed to update a TestTemplate.
     */
    data: XOR<TestTemplateUpdateInput, TestTemplateUncheckedUpdateInput>
    /**
     * Choose, which TestTemplate to update.
     */
    where: TestTemplateWhereUniqueInput
  }

  /**
   * TestTemplate updateMany
   */
  export type TestTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestTemplates.
     */
    data: XOR<TestTemplateUpdateManyMutationInput, TestTemplateUncheckedUpdateManyInput>
    /**
     * Filter which TestTemplates to update
     */
    where?: TestTemplateWhereInput
    /**
     * Limit how many TestTemplates to update.
     */
    limit?: number
  }

  /**
   * TestTemplate updateManyAndReturn
   */
  export type TestTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTemplate
     */
    select?: TestTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestTemplate
     */
    omit?: TestTemplateOmit<ExtArgs> | null
    /**
     * The data used to update TestTemplates.
     */
    data: XOR<TestTemplateUpdateManyMutationInput, TestTemplateUncheckedUpdateManyInput>
    /**
     * Filter which TestTemplates to update
     */
    where?: TestTemplateWhereInput
    /**
     * Limit how many TestTemplates to update.
     */
    limit?: number
  }

  /**
   * TestTemplate upsert
   */
  export type TestTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTemplate
     */
    select?: TestTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTemplate
     */
    omit?: TestTemplateOmit<ExtArgs> | null
    /**
     * The filter to search for the TestTemplate to update in case it exists.
     */
    where: TestTemplateWhereUniqueInput
    /**
     * In case the TestTemplate found by the `where` argument doesn't exist, create a new TestTemplate with this data.
     */
    create: XOR<TestTemplateCreateInput, TestTemplateUncheckedCreateInput>
    /**
     * In case the TestTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestTemplateUpdateInput, TestTemplateUncheckedUpdateInput>
  }

  /**
   * TestTemplate delete
   */
  export type TestTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTemplate
     */
    select?: TestTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTemplate
     */
    omit?: TestTemplateOmit<ExtArgs> | null
    /**
     * Filter which TestTemplate to delete.
     */
    where: TestTemplateWhereUniqueInput
  }

  /**
   * TestTemplate deleteMany
   */
  export type TestTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestTemplates to delete
     */
    where?: TestTemplateWhereInput
    /**
     * Limit how many TestTemplates to delete.
     */
    limit?: number
  }

  /**
   * TestTemplate without action
   */
  export type TestTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTemplate
     */
    select?: TestTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTemplate
     */
    omit?: TestTemplateOmit<ExtArgs> | null
  }


  /**
   * Model Webhook
   */

  export type AggregateWebhook = {
    _count: WebhookCountAggregateOutputType | null
    _avg: WebhookAvgAggregateOutputType | null
    _sum: WebhookSumAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  export type WebhookAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    teamId: number | null
    maxRetries: number | null
    retryDelay: number | null
    totalCalls: number | null
    successCount: number | null
    failureCount: number | null
  }

  export type WebhookSumAggregateOutputType = {
    id: number | null
    userId: number | null
    teamId: number | null
    maxRetries: number | null
    retryDelay: number | null
    totalCalls: number | null
    successCount: number | null
    failureCount: number | null
  }

  export type WebhookMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    userId: number | null
    teamId: number | null
    url: string | null
    secret: string | null
    method: string | null
    isActive: boolean | null
    retryEnabled: boolean | null
    maxRetries: number | null
    retryDelay: number | null
    totalCalls: number | null
    successCount: number | null
    failureCount: number | null
    lastTriggered: Date | null
    lastSuccess: Date | null
    lastFailure: Date | null
    lastError: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    userId: number | null
    teamId: number | null
    url: string | null
    secret: string | null
    method: string | null
    isActive: boolean | null
    retryEnabled: boolean | null
    maxRetries: number | null
    retryDelay: number | null
    totalCalls: number | null
    successCount: number | null
    failureCount: number | null
    lastTriggered: Date | null
    lastSuccess: Date | null
    lastFailure: Date | null
    lastError: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookCountAggregateOutputType = {
    id: number
    name: number
    description: number
    userId: number
    teamId: number
    url: number
    secret: number
    events: number
    method: number
    headers: number
    payloadTemplate: number
    isActive: number
    retryEnabled: number
    maxRetries: number
    retryDelay: number
    totalCalls: number
    successCount: number
    failureCount: number
    lastTriggered: number
    lastSuccess: number
    lastFailure: number
    lastError: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebhookAvgAggregateInputType = {
    id?: true
    userId?: true
    teamId?: true
    maxRetries?: true
    retryDelay?: true
    totalCalls?: true
    successCount?: true
    failureCount?: true
  }

  export type WebhookSumAggregateInputType = {
    id?: true
    userId?: true
    teamId?: true
    maxRetries?: true
    retryDelay?: true
    totalCalls?: true
    successCount?: true
    failureCount?: true
  }

  export type WebhookMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    teamId?: true
    url?: true
    secret?: true
    method?: true
    isActive?: true
    retryEnabled?: true
    maxRetries?: true
    retryDelay?: true
    totalCalls?: true
    successCount?: true
    failureCount?: true
    lastTriggered?: true
    lastSuccess?: true
    lastFailure?: true
    lastError?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    teamId?: true
    url?: true
    secret?: true
    method?: true
    isActive?: true
    retryEnabled?: true
    maxRetries?: true
    retryDelay?: true
    totalCalls?: true
    successCount?: true
    failureCount?: true
    lastTriggered?: true
    lastSuccess?: true
    lastFailure?: true
    lastError?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    teamId?: true
    url?: true
    secret?: true
    events?: true
    method?: true
    headers?: true
    payloadTemplate?: true
    isActive?: true
    retryEnabled?: true
    maxRetries?: true
    retryDelay?: true
    totalCalls?: true
    successCount?: true
    failureCount?: true
    lastTriggered?: true
    lastSuccess?: true
    lastFailure?: true
    lastError?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebhookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhook to aggregate.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Webhooks
    **/
    _count?: true | WebhookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookMaxAggregateInputType
  }

  export type GetWebhookAggregateType<T extends WebhookAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhook[P]>
      : GetScalarType<T[P], AggregateWebhook[P]>
  }




  export type WebhookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookWhereInput
    orderBy?: WebhookOrderByWithAggregationInput | WebhookOrderByWithAggregationInput[]
    by: WebhookScalarFieldEnum[] | WebhookScalarFieldEnum
    having?: WebhookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookCountAggregateInputType | true
    _avg?: WebhookAvgAggregateInputType
    _sum?: WebhookSumAggregateInputType
    _min?: WebhookMinAggregateInputType
    _max?: WebhookMaxAggregateInputType
  }

  export type WebhookGroupByOutputType = {
    id: number
    name: string
    description: string | null
    userId: number
    teamId: number | null
    url: string
    secret: string | null
    events: string[]
    method: string
    headers: JsonValue | null
    payloadTemplate: JsonValue | null
    isActive: boolean
    retryEnabled: boolean
    maxRetries: number
    retryDelay: number
    totalCalls: number
    successCount: number
    failureCount: number
    lastTriggered: Date | null
    lastSuccess: Date | null
    lastFailure: Date | null
    lastError: string | null
    createdAt: Date
    updatedAt: Date
    _count: WebhookCountAggregateOutputType | null
    _avg: WebhookAvgAggregateOutputType | null
    _sum: WebhookSumAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  type GetWebhookGroupByPayload<T extends WebhookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookGroupByOutputType[P]>
        }
      >
    >


  export type WebhookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    teamId?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    method?: boolean
    headers?: boolean
    payloadTemplate?: boolean
    isActive?: boolean
    retryEnabled?: boolean
    maxRetries?: boolean
    retryDelay?: boolean
    totalCalls?: boolean
    successCount?: boolean
    failureCount?: boolean
    lastTriggered?: boolean
    lastSuccess?: boolean
    lastFailure?: boolean
    lastError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    teamId?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    method?: boolean
    headers?: boolean
    payloadTemplate?: boolean
    isActive?: boolean
    retryEnabled?: boolean
    maxRetries?: boolean
    retryDelay?: boolean
    totalCalls?: boolean
    successCount?: boolean
    failureCount?: boolean
    lastTriggered?: boolean
    lastSuccess?: boolean
    lastFailure?: boolean
    lastError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    teamId?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    method?: boolean
    headers?: boolean
    payloadTemplate?: boolean
    isActive?: boolean
    retryEnabled?: boolean
    maxRetries?: boolean
    retryDelay?: boolean
    totalCalls?: boolean
    successCount?: boolean
    failureCount?: boolean
    lastTriggered?: boolean
    lastSuccess?: boolean
    lastFailure?: boolean
    lastError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    teamId?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    method?: boolean
    headers?: boolean
    payloadTemplate?: boolean
    isActive?: boolean
    retryEnabled?: boolean
    maxRetries?: boolean
    retryDelay?: boolean
    totalCalls?: boolean
    successCount?: boolean
    failureCount?: boolean
    lastTriggered?: boolean
    lastSuccess?: boolean
    lastFailure?: boolean
    lastError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WebhookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "userId" | "teamId" | "url" | "secret" | "events" | "method" | "headers" | "payloadTemplate" | "isActive" | "retryEnabled" | "maxRetries" | "retryDelay" | "totalCalls" | "successCount" | "failureCount" | "lastTriggered" | "lastSuccess" | "lastFailure" | "lastError" | "createdAt" | "updatedAt", ExtArgs["result"]["webhook"]>

  export type $WebhookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Webhook"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      userId: number
      teamId: number | null
      url: string
      secret: string | null
      events: string[]
      method: string
      headers: Prisma.JsonValue | null
      payloadTemplate: Prisma.JsonValue | null
      isActive: boolean
      retryEnabled: boolean
      maxRetries: number
      retryDelay: number
      totalCalls: number
      successCount: number
      failureCount: number
      lastTriggered: Date | null
      lastSuccess: Date | null
      lastFailure: Date | null
      lastError: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["webhook"]>
    composites: {}
  }

  type WebhookGetPayload<S extends boolean | null | undefined | WebhookDefaultArgs> = $Result.GetResult<Prisma.$WebhookPayload, S>

  type WebhookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookCountAggregateInputType | true
    }

  export interface WebhookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Webhook'], meta: { name: 'Webhook' } }
    /**
     * Find zero or one Webhook that matches the filter.
     * @param {WebhookFindUniqueArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookFindUniqueArgs>(args: SelectSubset<T, WebhookFindUniqueArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Webhook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookFindUniqueOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Webhook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookFindFirstArgs>(args?: SelectSubset<T, WebhookFindFirstArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Webhook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Webhooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webhooks
     * const webhooks = await prisma.webhook.findMany()
     * 
     * // Get first 10 Webhooks
     * const webhooks = await prisma.webhook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookWithIdOnly = await prisma.webhook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookFindManyArgs>(args?: SelectSubset<T, WebhookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Webhook.
     * @param {WebhookCreateArgs} args - Arguments to create a Webhook.
     * @example
     * // Create one Webhook
     * const Webhook = await prisma.webhook.create({
     *   data: {
     *     // ... data to create a Webhook
     *   }
     * })
     * 
     */
    create<T extends WebhookCreateArgs>(args: SelectSubset<T, WebhookCreateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Webhooks.
     * @param {WebhookCreateManyArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookCreateManyArgs>(args?: SelectSubset<T, WebhookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Webhooks and returns the data saved in the database.
     * @param {WebhookCreateManyAndReturnArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Webhook.
     * @param {WebhookDeleteArgs} args - Arguments to delete one Webhook.
     * @example
     * // Delete one Webhook
     * const Webhook = await prisma.webhook.delete({
     *   where: {
     *     // ... filter to delete one Webhook
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeleteArgs>(args: SelectSubset<T, WebhookDeleteArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Webhook.
     * @param {WebhookUpdateArgs} args - Arguments to update one Webhook.
     * @example
     * // Update one Webhook
     * const webhook = await prisma.webhook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookUpdateArgs>(args: SelectSubset<T, WebhookUpdateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Webhooks.
     * @param {WebhookDeleteManyArgs} args - Arguments to filter Webhooks to delete.
     * @example
     * // Delete a few Webhooks
     * const { count } = await prisma.webhook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeleteManyArgs>(args?: SelectSubset<T, WebhookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookUpdateManyArgs>(args: SelectSubset<T, WebhookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks and returns the data updated in the database.
     * @param {WebhookUpdateManyAndReturnArgs} args - Arguments to update many Webhooks.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebhookUpdateManyAndReturnArgs>(args: SelectSubset<T, WebhookUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Webhook.
     * @param {WebhookUpsertArgs} args - Arguments to update or create a Webhook.
     * @example
     * // Update or create a Webhook
     * const webhook = await prisma.webhook.upsert({
     *   create: {
     *     // ... data to create a Webhook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webhook we want to update
     *   }
     * })
     */
    upsert<T extends WebhookUpsertArgs>(args: SelectSubset<T, WebhookUpsertArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookCountArgs} args - Arguments to filter Webhooks to count.
     * @example
     * // Count the number of Webhooks
     * const count = await prisma.webhook.count({
     *   where: {
     *     // ... the filter for the Webhooks we want to count
     *   }
     * })
    **/
    count<T extends WebhookCountArgs>(
      args?: Subset<T, WebhookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookAggregateArgs>(args: Subset<T, WebhookAggregateArgs>): Prisma.PrismaPromise<GetWebhookAggregateType<T>>

    /**
     * Group by Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookGroupByArgs['orderBy'] }
        : { orderBy?: WebhookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Webhook model
   */
  readonly fields: WebhookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Webhook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Webhook model
   */
  interface WebhookFieldRefs {
    readonly id: FieldRef<"Webhook", 'Int'>
    readonly name: FieldRef<"Webhook", 'String'>
    readonly description: FieldRef<"Webhook", 'String'>
    readonly userId: FieldRef<"Webhook", 'Int'>
    readonly teamId: FieldRef<"Webhook", 'Int'>
    readonly url: FieldRef<"Webhook", 'String'>
    readonly secret: FieldRef<"Webhook", 'String'>
    readonly events: FieldRef<"Webhook", 'String[]'>
    readonly method: FieldRef<"Webhook", 'String'>
    readonly headers: FieldRef<"Webhook", 'Json'>
    readonly payloadTemplate: FieldRef<"Webhook", 'Json'>
    readonly isActive: FieldRef<"Webhook", 'Boolean'>
    readonly retryEnabled: FieldRef<"Webhook", 'Boolean'>
    readonly maxRetries: FieldRef<"Webhook", 'Int'>
    readonly retryDelay: FieldRef<"Webhook", 'Int'>
    readonly totalCalls: FieldRef<"Webhook", 'Int'>
    readonly successCount: FieldRef<"Webhook", 'Int'>
    readonly failureCount: FieldRef<"Webhook", 'Int'>
    readonly lastTriggered: FieldRef<"Webhook", 'DateTime'>
    readonly lastSuccess: FieldRef<"Webhook", 'DateTime'>
    readonly lastFailure: FieldRef<"Webhook", 'DateTime'>
    readonly lastError: FieldRef<"Webhook", 'String'>
    readonly createdAt: FieldRef<"Webhook", 'DateTime'>
    readonly updatedAt: FieldRef<"Webhook", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Webhook findUnique
   */
  export type WebhookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findUniqueOrThrow
   */
  export type WebhookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findFirst
   */
  export type WebhookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findFirstOrThrow
   */
  export type WebhookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findMany
   */
  export type WebhookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Filter, which Webhooks to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook create
   */
  export type WebhookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * The data needed to create a Webhook.
     */
    data: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
  }

  /**
   * Webhook createMany
   */
  export type WebhookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Webhook createManyAndReturn
   */
  export type WebhookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Webhook update
   */
  export type WebhookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * The data needed to update a Webhook.
     */
    data: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
    /**
     * Choose, which Webhook to update.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook updateMany
   */
  export type WebhookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to update.
     */
    limit?: number
  }

  /**
   * Webhook updateManyAndReturn
   */
  export type WebhookUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to update.
     */
    limit?: number
  }

  /**
   * Webhook upsert
   */
  export type WebhookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * The filter to search for the Webhook to update in case it exists.
     */
    where: WebhookWhereUniqueInput
    /**
     * In case the Webhook found by the `where` argument doesn't exist, create a new Webhook with this data.
     */
    create: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
    /**
     * In case the Webhook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
  }

  /**
   * Webhook delete
   */
  export type WebhookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Filter which Webhook to delete.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook deleteMany
   */
  export type WebhookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhooks to delete
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to delete.
     */
    limit?: number
  }

  /**
   * Webhook without action
   */
  export type WebhookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
  }


  /**
   * Model WebhookLog
   */

  export type AggregateWebhookLog = {
    _count: WebhookLogCountAggregateOutputType | null
    _avg: WebhookLogAvgAggregateOutputType | null
    _sum: WebhookLogSumAggregateOutputType | null
    _min: WebhookLogMinAggregateOutputType | null
    _max: WebhookLogMaxAggregateOutputType | null
  }

  export type WebhookLogAvgAggregateOutputType = {
    id: number | null
    webhookId: number | null
    statusCode: number | null
    responseTime: number | null
    attempt: number | null
  }

  export type WebhookLogSumAggregateOutputType = {
    id: number | null
    webhookId: number | null
    statusCode: number | null
    responseTime: number | null
    attempt: number | null
  }

  export type WebhookLogMinAggregateOutputType = {
    id: number | null
    webhookId: number | null
    event: string | null
    url: string | null
    method: string | null
    statusCode: number | null
    responseBody: string | null
    responseTime: number | null
    attempt: number | null
    success: boolean | null
    error: string | null
    createdAt: Date | null
  }

  export type WebhookLogMaxAggregateOutputType = {
    id: number | null
    webhookId: number | null
    event: string | null
    url: string | null
    method: string | null
    statusCode: number | null
    responseBody: string | null
    responseTime: number | null
    attempt: number | null
    success: boolean | null
    error: string | null
    createdAt: Date | null
  }

  export type WebhookLogCountAggregateOutputType = {
    id: number
    webhookId: number
    event: number
    payload: number
    url: number
    method: number
    headers: number
    statusCode: number
    responseBody: number
    responseTime: number
    attempt: number
    success: number
    error: number
    createdAt: number
    _all: number
  }


  export type WebhookLogAvgAggregateInputType = {
    id?: true
    webhookId?: true
    statusCode?: true
    responseTime?: true
    attempt?: true
  }

  export type WebhookLogSumAggregateInputType = {
    id?: true
    webhookId?: true
    statusCode?: true
    responseTime?: true
    attempt?: true
  }

  export type WebhookLogMinAggregateInputType = {
    id?: true
    webhookId?: true
    event?: true
    url?: true
    method?: true
    statusCode?: true
    responseBody?: true
    responseTime?: true
    attempt?: true
    success?: true
    error?: true
    createdAt?: true
  }

  export type WebhookLogMaxAggregateInputType = {
    id?: true
    webhookId?: true
    event?: true
    url?: true
    method?: true
    statusCode?: true
    responseBody?: true
    responseTime?: true
    attempt?: true
    success?: true
    error?: true
    createdAt?: true
  }

  export type WebhookLogCountAggregateInputType = {
    id?: true
    webhookId?: true
    event?: true
    payload?: true
    url?: true
    method?: true
    headers?: true
    statusCode?: true
    responseBody?: true
    responseTime?: true
    attempt?: true
    success?: true
    error?: true
    createdAt?: true
    _all?: true
  }

  export type WebhookLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookLog to aggregate.
     */
    where?: WebhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookLogs to fetch.
     */
    orderBy?: WebhookLogOrderByWithRelationInput | WebhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookLogs
    **/
    _count?: true | WebhookLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookLogMaxAggregateInputType
  }

  export type GetWebhookLogAggregateType<T extends WebhookLogAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookLog[P]>
      : GetScalarType<T[P], AggregateWebhookLog[P]>
  }




  export type WebhookLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookLogWhereInput
    orderBy?: WebhookLogOrderByWithAggregationInput | WebhookLogOrderByWithAggregationInput[]
    by: WebhookLogScalarFieldEnum[] | WebhookLogScalarFieldEnum
    having?: WebhookLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookLogCountAggregateInputType | true
    _avg?: WebhookLogAvgAggregateInputType
    _sum?: WebhookLogSumAggregateInputType
    _min?: WebhookLogMinAggregateInputType
    _max?: WebhookLogMaxAggregateInputType
  }

  export type WebhookLogGroupByOutputType = {
    id: number
    webhookId: number
    event: string
    payload: JsonValue
    url: string
    method: string
    headers: JsonValue | null
    statusCode: number | null
    responseBody: string | null
    responseTime: number | null
    attempt: number
    success: boolean
    error: string | null
    createdAt: Date
    _count: WebhookLogCountAggregateOutputType | null
    _avg: WebhookLogAvgAggregateOutputType | null
    _sum: WebhookLogSumAggregateOutputType | null
    _min: WebhookLogMinAggregateOutputType | null
    _max: WebhookLogMaxAggregateOutputType | null
  }

  type GetWebhookLogGroupByPayload<T extends WebhookLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookLogGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookLogGroupByOutputType[P]>
        }
      >
    >


  export type WebhookLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhookId?: boolean
    event?: boolean
    payload?: boolean
    url?: boolean
    method?: boolean
    headers?: boolean
    statusCode?: boolean
    responseBody?: boolean
    responseTime?: boolean
    attempt?: boolean
    success?: boolean
    error?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["webhookLog"]>

  export type WebhookLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhookId?: boolean
    event?: boolean
    payload?: boolean
    url?: boolean
    method?: boolean
    headers?: boolean
    statusCode?: boolean
    responseBody?: boolean
    responseTime?: boolean
    attempt?: boolean
    success?: boolean
    error?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["webhookLog"]>

  export type WebhookLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhookId?: boolean
    event?: boolean
    payload?: boolean
    url?: boolean
    method?: boolean
    headers?: boolean
    statusCode?: boolean
    responseBody?: boolean
    responseTime?: boolean
    attempt?: boolean
    success?: boolean
    error?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["webhookLog"]>

  export type WebhookLogSelectScalar = {
    id?: boolean
    webhookId?: boolean
    event?: boolean
    payload?: boolean
    url?: boolean
    method?: boolean
    headers?: boolean
    statusCode?: boolean
    responseBody?: boolean
    responseTime?: boolean
    attempt?: boolean
    success?: boolean
    error?: boolean
    createdAt?: boolean
  }

  export type WebhookLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "webhookId" | "event" | "payload" | "url" | "method" | "headers" | "statusCode" | "responseBody" | "responseTime" | "attempt" | "success" | "error" | "createdAt", ExtArgs["result"]["webhookLog"]>

  export type $WebhookLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      webhookId: number
      event: string
      payload: Prisma.JsonValue
      url: string
      method: string
      headers: Prisma.JsonValue | null
      statusCode: number | null
      responseBody: string | null
      responseTime: number | null
      attempt: number
      success: boolean
      error: string | null
      createdAt: Date
    }, ExtArgs["result"]["webhookLog"]>
    composites: {}
  }

  type WebhookLogGetPayload<S extends boolean | null | undefined | WebhookLogDefaultArgs> = $Result.GetResult<Prisma.$WebhookLogPayload, S>

  type WebhookLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookLogCountAggregateInputType | true
    }

  export interface WebhookLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookLog'], meta: { name: 'WebhookLog' } }
    /**
     * Find zero or one WebhookLog that matches the filter.
     * @param {WebhookLogFindUniqueArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookLogFindUniqueArgs>(args: SelectSubset<T, WebhookLogFindUniqueArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebhookLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookLogFindUniqueOrThrowArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookLogFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogFindFirstArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookLogFindFirstArgs>(args?: SelectSubset<T, WebhookLogFindFirstArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogFindFirstOrThrowArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookLogFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebhookLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookLogs
     * const webhookLogs = await prisma.webhookLog.findMany()
     * 
     * // Get first 10 WebhookLogs
     * const webhookLogs = await prisma.webhookLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookLogWithIdOnly = await prisma.webhookLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookLogFindManyArgs>(args?: SelectSubset<T, WebhookLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebhookLog.
     * @param {WebhookLogCreateArgs} args - Arguments to create a WebhookLog.
     * @example
     * // Create one WebhookLog
     * const WebhookLog = await prisma.webhookLog.create({
     *   data: {
     *     // ... data to create a WebhookLog
     *   }
     * })
     * 
     */
    create<T extends WebhookLogCreateArgs>(args: SelectSubset<T, WebhookLogCreateArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebhookLogs.
     * @param {WebhookLogCreateManyArgs} args - Arguments to create many WebhookLogs.
     * @example
     * // Create many WebhookLogs
     * const webhookLog = await prisma.webhookLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookLogCreateManyArgs>(args?: SelectSubset<T, WebhookLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookLogs and returns the data saved in the database.
     * @param {WebhookLogCreateManyAndReturnArgs} args - Arguments to create many WebhookLogs.
     * @example
     * // Create many WebhookLogs
     * const webhookLog = await prisma.webhookLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookLogs and only return the `id`
     * const webhookLogWithIdOnly = await prisma.webhookLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookLogCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WebhookLog.
     * @param {WebhookLogDeleteArgs} args - Arguments to delete one WebhookLog.
     * @example
     * // Delete one WebhookLog
     * const WebhookLog = await prisma.webhookLog.delete({
     *   where: {
     *     // ... filter to delete one WebhookLog
     *   }
     * })
     * 
     */
    delete<T extends WebhookLogDeleteArgs>(args: SelectSubset<T, WebhookLogDeleteArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebhookLog.
     * @param {WebhookLogUpdateArgs} args - Arguments to update one WebhookLog.
     * @example
     * // Update one WebhookLog
     * const webhookLog = await prisma.webhookLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookLogUpdateArgs>(args: SelectSubset<T, WebhookLogUpdateArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebhookLogs.
     * @param {WebhookLogDeleteManyArgs} args - Arguments to filter WebhookLogs to delete.
     * @example
     * // Delete a few WebhookLogs
     * const { count } = await prisma.webhookLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookLogDeleteManyArgs>(args?: SelectSubset<T, WebhookLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookLogs
     * const webhookLog = await prisma.webhookLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookLogUpdateManyArgs>(args: SelectSubset<T, WebhookLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookLogs and returns the data updated in the database.
     * @param {WebhookLogUpdateManyAndReturnArgs} args - Arguments to update many WebhookLogs.
     * @example
     * // Update many WebhookLogs
     * const webhookLog = await prisma.webhookLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WebhookLogs and only return the `id`
     * const webhookLogWithIdOnly = await prisma.webhookLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebhookLogUpdateManyAndReturnArgs>(args: SelectSubset<T, WebhookLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WebhookLog.
     * @param {WebhookLogUpsertArgs} args - Arguments to update or create a WebhookLog.
     * @example
     * // Update or create a WebhookLog
     * const webhookLog = await prisma.webhookLog.upsert({
     *   create: {
     *     // ... data to create a WebhookLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookLog we want to update
     *   }
     * })
     */
    upsert<T extends WebhookLogUpsertArgs>(args: SelectSubset<T, WebhookLogUpsertArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebhookLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogCountArgs} args - Arguments to filter WebhookLogs to count.
     * @example
     * // Count the number of WebhookLogs
     * const count = await prisma.webhookLog.count({
     *   where: {
     *     // ... the filter for the WebhookLogs we want to count
     *   }
     * })
    **/
    count<T extends WebhookLogCountArgs>(
      args?: Subset<T, WebhookLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookLogAggregateArgs>(args: Subset<T, WebhookLogAggregateArgs>): Prisma.PrismaPromise<GetWebhookLogAggregateType<T>>

    /**
     * Group by WebhookLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookLogGroupByArgs['orderBy'] }
        : { orderBy?: WebhookLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookLog model
   */
  readonly fields: WebhookLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookLog model
   */
  interface WebhookLogFieldRefs {
    readonly id: FieldRef<"WebhookLog", 'Int'>
    readonly webhookId: FieldRef<"WebhookLog", 'Int'>
    readonly event: FieldRef<"WebhookLog", 'String'>
    readonly payload: FieldRef<"WebhookLog", 'Json'>
    readonly url: FieldRef<"WebhookLog", 'String'>
    readonly method: FieldRef<"WebhookLog", 'String'>
    readonly headers: FieldRef<"WebhookLog", 'Json'>
    readonly statusCode: FieldRef<"WebhookLog", 'Int'>
    readonly responseBody: FieldRef<"WebhookLog", 'String'>
    readonly responseTime: FieldRef<"WebhookLog", 'Int'>
    readonly attempt: FieldRef<"WebhookLog", 'Int'>
    readonly success: FieldRef<"WebhookLog", 'Boolean'>
    readonly error: FieldRef<"WebhookLog", 'String'>
    readonly createdAt: FieldRef<"WebhookLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookLog findUnique
   */
  export type WebhookLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * Filter, which WebhookLog to fetch.
     */
    where: WebhookLogWhereUniqueInput
  }

  /**
   * WebhookLog findUniqueOrThrow
   */
  export type WebhookLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * Filter, which WebhookLog to fetch.
     */
    where: WebhookLogWhereUniqueInput
  }

  /**
   * WebhookLog findFirst
   */
  export type WebhookLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * Filter, which WebhookLog to fetch.
     */
    where?: WebhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookLogs to fetch.
     */
    orderBy?: WebhookLogOrderByWithRelationInput | WebhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookLogs.
     */
    cursor?: WebhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookLogs.
     */
    distinct?: WebhookLogScalarFieldEnum | WebhookLogScalarFieldEnum[]
  }

  /**
   * WebhookLog findFirstOrThrow
   */
  export type WebhookLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * Filter, which WebhookLog to fetch.
     */
    where?: WebhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookLogs to fetch.
     */
    orderBy?: WebhookLogOrderByWithRelationInput | WebhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookLogs.
     */
    cursor?: WebhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookLogs.
     */
    distinct?: WebhookLogScalarFieldEnum | WebhookLogScalarFieldEnum[]
  }

  /**
   * WebhookLog findMany
   */
  export type WebhookLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * Filter, which WebhookLogs to fetch.
     */
    where?: WebhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookLogs to fetch.
     */
    orderBy?: WebhookLogOrderByWithRelationInput | WebhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookLogs.
     */
    cursor?: WebhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookLogs.
     */
    skip?: number
    distinct?: WebhookLogScalarFieldEnum | WebhookLogScalarFieldEnum[]
  }

  /**
   * WebhookLog create
   */
  export type WebhookLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * The data needed to create a WebhookLog.
     */
    data: XOR<WebhookLogCreateInput, WebhookLogUncheckedCreateInput>
  }

  /**
   * WebhookLog createMany
   */
  export type WebhookLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookLogs.
     */
    data: WebhookLogCreateManyInput | WebhookLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookLog createManyAndReturn
   */
  export type WebhookLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * The data used to create many WebhookLogs.
     */
    data: WebhookLogCreateManyInput | WebhookLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookLog update
   */
  export type WebhookLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * The data needed to update a WebhookLog.
     */
    data: XOR<WebhookLogUpdateInput, WebhookLogUncheckedUpdateInput>
    /**
     * Choose, which WebhookLog to update.
     */
    where: WebhookLogWhereUniqueInput
  }

  /**
   * WebhookLog updateMany
   */
  export type WebhookLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookLogs.
     */
    data: XOR<WebhookLogUpdateManyMutationInput, WebhookLogUncheckedUpdateManyInput>
    /**
     * Filter which WebhookLogs to update
     */
    where?: WebhookLogWhereInput
    /**
     * Limit how many WebhookLogs to update.
     */
    limit?: number
  }

  /**
   * WebhookLog updateManyAndReturn
   */
  export type WebhookLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * The data used to update WebhookLogs.
     */
    data: XOR<WebhookLogUpdateManyMutationInput, WebhookLogUncheckedUpdateManyInput>
    /**
     * Filter which WebhookLogs to update
     */
    where?: WebhookLogWhereInput
    /**
     * Limit how many WebhookLogs to update.
     */
    limit?: number
  }

  /**
   * WebhookLog upsert
   */
  export type WebhookLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * The filter to search for the WebhookLog to update in case it exists.
     */
    where: WebhookLogWhereUniqueInput
    /**
     * In case the WebhookLog found by the `where` argument doesn't exist, create a new WebhookLog with this data.
     */
    create: XOR<WebhookLogCreateInput, WebhookLogUncheckedCreateInput>
    /**
     * In case the WebhookLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookLogUpdateInput, WebhookLogUncheckedUpdateInput>
  }

  /**
   * WebhookLog delete
   */
  export type WebhookLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * Filter which WebhookLog to delete.
     */
    where: WebhookLogWhereUniqueInput
  }

  /**
   * WebhookLog deleteMany
   */
  export type WebhookLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookLogs to delete
     */
    where?: WebhookLogWhereInput
    /**
     * Limit how many WebhookLogs to delete.
     */
    limit?: number
  }

  /**
   * WebhookLog without action
   */
  export type WebhookLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
  }


  /**
   * Model ApiRateLimit
   */

  export type AggregateApiRateLimit = {
    _count: ApiRateLimitCountAggregateOutputType | null
    _avg: ApiRateLimitAvgAggregateOutputType | null
    _sum: ApiRateLimitSumAggregateOutputType | null
    _min: ApiRateLimitMinAggregateOutputType | null
    _max: ApiRateLimitMaxAggregateOutputType | null
  }

  export type ApiRateLimitAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    maxLimit: number | null
    currentUsage: number | null
    warningThreshold: number | null
  }

  export type ApiRateLimitSumAggregateOutputType = {
    id: number | null
    userId: number | null
    maxLimit: number | null
    currentUsage: number | null
    warningThreshold: number | null
  }

  export type ApiRateLimitMinAggregateOutputType = {
    id: number | null
    userId: number | null
    provider: string | null
    limitType: string | null
    limitPeriod: string | null
    maxLimit: number | null
    currentUsage: number | null
    resetAt: Date | null
    warningThreshold: number | null
    lastWarningAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiRateLimitMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    provider: string | null
    limitType: string | null
    limitPeriod: string | null
    maxLimit: number | null
    currentUsage: number | null
    resetAt: Date | null
    warningThreshold: number | null
    lastWarningAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiRateLimitCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    limitType: number
    limitPeriod: number
    maxLimit: number
    currentUsage: number
    resetAt: number
    warningThreshold: number
    lastWarningAt: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApiRateLimitAvgAggregateInputType = {
    id?: true
    userId?: true
    maxLimit?: true
    currentUsage?: true
    warningThreshold?: true
  }

  export type ApiRateLimitSumAggregateInputType = {
    id?: true
    userId?: true
    maxLimit?: true
    currentUsage?: true
    warningThreshold?: true
  }

  export type ApiRateLimitMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    limitType?: true
    limitPeriod?: true
    maxLimit?: true
    currentUsage?: true
    resetAt?: true
    warningThreshold?: true
    lastWarningAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiRateLimitMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    limitType?: true
    limitPeriod?: true
    maxLimit?: true
    currentUsage?: true
    resetAt?: true
    warningThreshold?: true
    lastWarningAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiRateLimitCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    limitType?: true
    limitPeriod?: true
    maxLimit?: true
    currentUsage?: true
    resetAt?: true
    warningThreshold?: true
    lastWarningAt?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApiRateLimitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiRateLimit to aggregate.
     */
    where?: ApiRateLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiRateLimits to fetch.
     */
    orderBy?: ApiRateLimitOrderByWithRelationInput | ApiRateLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiRateLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiRateLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiRateLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiRateLimits
    **/
    _count?: true | ApiRateLimitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiRateLimitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiRateLimitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiRateLimitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiRateLimitMaxAggregateInputType
  }

  export type GetApiRateLimitAggregateType<T extends ApiRateLimitAggregateArgs> = {
        [P in keyof T & keyof AggregateApiRateLimit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiRateLimit[P]>
      : GetScalarType<T[P], AggregateApiRateLimit[P]>
  }




  export type ApiRateLimitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiRateLimitWhereInput
    orderBy?: ApiRateLimitOrderByWithAggregationInput | ApiRateLimitOrderByWithAggregationInput[]
    by: ApiRateLimitScalarFieldEnum[] | ApiRateLimitScalarFieldEnum
    having?: ApiRateLimitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiRateLimitCountAggregateInputType | true
    _avg?: ApiRateLimitAvgAggregateInputType
    _sum?: ApiRateLimitSumAggregateInputType
    _min?: ApiRateLimitMinAggregateInputType
    _max?: ApiRateLimitMaxAggregateInputType
  }

  export type ApiRateLimitGroupByOutputType = {
    id: number
    userId: number
    provider: string
    limitType: string
    limitPeriod: string
    maxLimit: number
    currentUsage: number
    resetAt: Date
    warningThreshold: number
    lastWarningAt: Date | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ApiRateLimitCountAggregateOutputType | null
    _avg: ApiRateLimitAvgAggregateOutputType | null
    _sum: ApiRateLimitSumAggregateOutputType | null
    _min: ApiRateLimitMinAggregateOutputType | null
    _max: ApiRateLimitMaxAggregateOutputType | null
  }

  type GetApiRateLimitGroupByPayload<T extends ApiRateLimitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiRateLimitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiRateLimitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiRateLimitGroupByOutputType[P]>
            : GetScalarType<T[P], ApiRateLimitGroupByOutputType[P]>
        }
      >
    >


  export type ApiRateLimitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    limitType?: boolean
    limitPeriod?: boolean
    maxLimit?: boolean
    currentUsage?: boolean
    resetAt?: boolean
    warningThreshold?: boolean
    lastWarningAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["apiRateLimit"]>

  export type ApiRateLimitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    limitType?: boolean
    limitPeriod?: boolean
    maxLimit?: boolean
    currentUsage?: boolean
    resetAt?: boolean
    warningThreshold?: boolean
    lastWarningAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["apiRateLimit"]>

  export type ApiRateLimitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    limitType?: boolean
    limitPeriod?: boolean
    maxLimit?: boolean
    currentUsage?: boolean
    resetAt?: boolean
    warningThreshold?: boolean
    lastWarningAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["apiRateLimit"]>

  export type ApiRateLimitSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    limitType?: boolean
    limitPeriod?: boolean
    maxLimit?: boolean
    currentUsage?: boolean
    resetAt?: boolean
    warningThreshold?: boolean
    lastWarningAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApiRateLimitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "provider" | "limitType" | "limitPeriod" | "maxLimit" | "currentUsage" | "resetAt" | "warningThreshold" | "lastWarningAt" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["apiRateLimit"]>

  export type $ApiRateLimitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiRateLimit"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      provider: string
      limitType: string
      limitPeriod: string
      maxLimit: number
      currentUsage: number
      resetAt: Date
      warningThreshold: number
      lastWarningAt: Date | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["apiRateLimit"]>
    composites: {}
  }

  type ApiRateLimitGetPayload<S extends boolean | null | undefined | ApiRateLimitDefaultArgs> = $Result.GetResult<Prisma.$ApiRateLimitPayload, S>

  type ApiRateLimitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiRateLimitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiRateLimitCountAggregateInputType | true
    }

  export interface ApiRateLimitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiRateLimit'], meta: { name: 'ApiRateLimit' } }
    /**
     * Find zero or one ApiRateLimit that matches the filter.
     * @param {ApiRateLimitFindUniqueArgs} args - Arguments to find a ApiRateLimit
     * @example
     * // Get one ApiRateLimit
     * const apiRateLimit = await prisma.apiRateLimit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiRateLimitFindUniqueArgs>(args: SelectSubset<T, ApiRateLimitFindUniqueArgs<ExtArgs>>): Prisma__ApiRateLimitClient<$Result.GetResult<Prisma.$ApiRateLimitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiRateLimit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiRateLimitFindUniqueOrThrowArgs} args - Arguments to find a ApiRateLimit
     * @example
     * // Get one ApiRateLimit
     * const apiRateLimit = await prisma.apiRateLimit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiRateLimitFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiRateLimitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiRateLimitClient<$Result.GetResult<Prisma.$ApiRateLimitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiRateLimit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiRateLimitFindFirstArgs} args - Arguments to find a ApiRateLimit
     * @example
     * // Get one ApiRateLimit
     * const apiRateLimit = await prisma.apiRateLimit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiRateLimitFindFirstArgs>(args?: SelectSubset<T, ApiRateLimitFindFirstArgs<ExtArgs>>): Prisma__ApiRateLimitClient<$Result.GetResult<Prisma.$ApiRateLimitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiRateLimit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiRateLimitFindFirstOrThrowArgs} args - Arguments to find a ApiRateLimit
     * @example
     * // Get one ApiRateLimit
     * const apiRateLimit = await prisma.apiRateLimit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiRateLimitFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiRateLimitFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiRateLimitClient<$Result.GetResult<Prisma.$ApiRateLimitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiRateLimits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiRateLimitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiRateLimits
     * const apiRateLimits = await prisma.apiRateLimit.findMany()
     * 
     * // Get first 10 ApiRateLimits
     * const apiRateLimits = await prisma.apiRateLimit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiRateLimitWithIdOnly = await prisma.apiRateLimit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiRateLimitFindManyArgs>(args?: SelectSubset<T, ApiRateLimitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiRateLimitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiRateLimit.
     * @param {ApiRateLimitCreateArgs} args - Arguments to create a ApiRateLimit.
     * @example
     * // Create one ApiRateLimit
     * const ApiRateLimit = await prisma.apiRateLimit.create({
     *   data: {
     *     // ... data to create a ApiRateLimit
     *   }
     * })
     * 
     */
    create<T extends ApiRateLimitCreateArgs>(args: SelectSubset<T, ApiRateLimitCreateArgs<ExtArgs>>): Prisma__ApiRateLimitClient<$Result.GetResult<Prisma.$ApiRateLimitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiRateLimits.
     * @param {ApiRateLimitCreateManyArgs} args - Arguments to create many ApiRateLimits.
     * @example
     * // Create many ApiRateLimits
     * const apiRateLimit = await prisma.apiRateLimit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiRateLimitCreateManyArgs>(args?: SelectSubset<T, ApiRateLimitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiRateLimits and returns the data saved in the database.
     * @param {ApiRateLimitCreateManyAndReturnArgs} args - Arguments to create many ApiRateLimits.
     * @example
     * // Create many ApiRateLimits
     * const apiRateLimit = await prisma.apiRateLimit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiRateLimits and only return the `id`
     * const apiRateLimitWithIdOnly = await prisma.apiRateLimit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiRateLimitCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiRateLimitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiRateLimitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiRateLimit.
     * @param {ApiRateLimitDeleteArgs} args - Arguments to delete one ApiRateLimit.
     * @example
     * // Delete one ApiRateLimit
     * const ApiRateLimit = await prisma.apiRateLimit.delete({
     *   where: {
     *     // ... filter to delete one ApiRateLimit
     *   }
     * })
     * 
     */
    delete<T extends ApiRateLimitDeleteArgs>(args: SelectSubset<T, ApiRateLimitDeleteArgs<ExtArgs>>): Prisma__ApiRateLimitClient<$Result.GetResult<Prisma.$ApiRateLimitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiRateLimit.
     * @param {ApiRateLimitUpdateArgs} args - Arguments to update one ApiRateLimit.
     * @example
     * // Update one ApiRateLimit
     * const apiRateLimit = await prisma.apiRateLimit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiRateLimitUpdateArgs>(args: SelectSubset<T, ApiRateLimitUpdateArgs<ExtArgs>>): Prisma__ApiRateLimitClient<$Result.GetResult<Prisma.$ApiRateLimitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiRateLimits.
     * @param {ApiRateLimitDeleteManyArgs} args - Arguments to filter ApiRateLimits to delete.
     * @example
     * // Delete a few ApiRateLimits
     * const { count } = await prisma.apiRateLimit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiRateLimitDeleteManyArgs>(args?: SelectSubset<T, ApiRateLimitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiRateLimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiRateLimitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiRateLimits
     * const apiRateLimit = await prisma.apiRateLimit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiRateLimitUpdateManyArgs>(args: SelectSubset<T, ApiRateLimitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiRateLimits and returns the data updated in the database.
     * @param {ApiRateLimitUpdateManyAndReturnArgs} args - Arguments to update many ApiRateLimits.
     * @example
     * // Update many ApiRateLimits
     * const apiRateLimit = await prisma.apiRateLimit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiRateLimits and only return the `id`
     * const apiRateLimitWithIdOnly = await prisma.apiRateLimit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiRateLimitUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiRateLimitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiRateLimitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiRateLimit.
     * @param {ApiRateLimitUpsertArgs} args - Arguments to update or create a ApiRateLimit.
     * @example
     * // Update or create a ApiRateLimit
     * const apiRateLimit = await prisma.apiRateLimit.upsert({
     *   create: {
     *     // ... data to create a ApiRateLimit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiRateLimit we want to update
     *   }
     * })
     */
    upsert<T extends ApiRateLimitUpsertArgs>(args: SelectSubset<T, ApiRateLimitUpsertArgs<ExtArgs>>): Prisma__ApiRateLimitClient<$Result.GetResult<Prisma.$ApiRateLimitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiRateLimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiRateLimitCountArgs} args - Arguments to filter ApiRateLimits to count.
     * @example
     * // Count the number of ApiRateLimits
     * const count = await prisma.apiRateLimit.count({
     *   where: {
     *     // ... the filter for the ApiRateLimits we want to count
     *   }
     * })
    **/
    count<T extends ApiRateLimitCountArgs>(
      args?: Subset<T, ApiRateLimitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiRateLimitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiRateLimit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiRateLimitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiRateLimitAggregateArgs>(args: Subset<T, ApiRateLimitAggregateArgs>): Prisma.PrismaPromise<GetApiRateLimitAggregateType<T>>

    /**
     * Group by ApiRateLimit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiRateLimitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiRateLimitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiRateLimitGroupByArgs['orderBy'] }
        : { orderBy?: ApiRateLimitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiRateLimitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiRateLimitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiRateLimit model
   */
  readonly fields: ApiRateLimitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiRateLimit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiRateLimitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiRateLimit model
   */
  interface ApiRateLimitFieldRefs {
    readonly id: FieldRef<"ApiRateLimit", 'Int'>
    readonly userId: FieldRef<"ApiRateLimit", 'Int'>
    readonly provider: FieldRef<"ApiRateLimit", 'String'>
    readonly limitType: FieldRef<"ApiRateLimit", 'String'>
    readonly limitPeriod: FieldRef<"ApiRateLimit", 'String'>
    readonly maxLimit: FieldRef<"ApiRateLimit", 'Int'>
    readonly currentUsage: FieldRef<"ApiRateLimit", 'Int'>
    readonly resetAt: FieldRef<"ApiRateLimit", 'DateTime'>
    readonly warningThreshold: FieldRef<"ApiRateLimit", 'Int'>
    readonly lastWarningAt: FieldRef<"ApiRateLimit", 'DateTime'>
    readonly metadata: FieldRef<"ApiRateLimit", 'Json'>
    readonly createdAt: FieldRef<"ApiRateLimit", 'DateTime'>
    readonly updatedAt: FieldRef<"ApiRateLimit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiRateLimit findUnique
   */
  export type ApiRateLimitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRateLimit
     */
    select?: ApiRateLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRateLimit
     */
    omit?: ApiRateLimitOmit<ExtArgs> | null
    /**
     * Filter, which ApiRateLimit to fetch.
     */
    where: ApiRateLimitWhereUniqueInput
  }

  /**
   * ApiRateLimit findUniqueOrThrow
   */
  export type ApiRateLimitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRateLimit
     */
    select?: ApiRateLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRateLimit
     */
    omit?: ApiRateLimitOmit<ExtArgs> | null
    /**
     * Filter, which ApiRateLimit to fetch.
     */
    where: ApiRateLimitWhereUniqueInput
  }

  /**
   * ApiRateLimit findFirst
   */
  export type ApiRateLimitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRateLimit
     */
    select?: ApiRateLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRateLimit
     */
    omit?: ApiRateLimitOmit<ExtArgs> | null
    /**
     * Filter, which ApiRateLimit to fetch.
     */
    where?: ApiRateLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiRateLimits to fetch.
     */
    orderBy?: ApiRateLimitOrderByWithRelationInput | ApiRateLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiRateLimits.
     */
    cursor?: ApiRateLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiRateLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiRateLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiRateLimits.
     */
    distinct?: ApiRateLimitScalarFieldEnum | ApiRateLimitScalarFieldEnum[]
  }

  /**
   * ApiRateLimit findFirstOrThrow
   */
  export type ApiRateLimitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRateLimit
     */
    select?: ApiRateLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRateLimit
     */
    omit?: ApiRateLimitOmit<ExtArgs> | null
    /**
     * Filter, which ApiRateLimit to fetch.
     */
    where?: ApiRateLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiRateLimits to fetch.
     */
    orderBy?: ApiRateLimitOrderByWithRelationInput | ApiRateLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiRateLimits.
     */
    cursor?: ApiRateLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiRateLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiRateLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiRateLimits.
     */
    distinct?: ApiRateLimitScalarFieldEnum | ApiRateLimitScalarFieldEnum[]
  }

  /**
   * ApiRateLimit findMany
   */
  export type ApiRateLimitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRateLimit
     */
    select?: ApiRateLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRateLimit
     */
    omit?: ApiRateLimitOmit<ExtArgs> | null
    /**
     * Filter, which ApiRateLimits to fetch.
     */
    where?: ApiRateLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiRateLimits to fetch.
     */
    orderBy?: ApiRateLimitOrderByWithRelationInput | ApiRateLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiRateLimits.
     */
    cursor?: ApiRateLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiRateLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiRateLimits.
     */
    skip?: number
    distinct?: ApiRateLimitScalarFieldEnum | ApiRateLimitScalarFieldEnum[]
  }

  /**
   * ApiRateLimit create
   */
  export type ApiRateLimitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRateLimit
     */
    select?: ApiRateLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRateLimit
     */
    omit?: ApiRateLimitOmit<ExtArgs> | null
    /**
     * The data needed to create a ApiRateLimit.
     */
    data: XOR<ApiRateLimitCreateInput, ApiRateLimitUncheckedCreateInput>
  }

  /**
   * ApiRateLimit createMany
   */
  export type ApiRateLimitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiRateLimits.
     */
    data: ApiRateLimitCreateManyInput | ApiRateLimitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiRateLimit createManyAndReturn
   */
  export type ApiRateLimitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRateLimit
     */
    select?: ApiRateLimitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRateLimit
     */
    omit?: ApiRateLimitOmit<ExtArgs> | null
    /**
     * The data used to create many ApiRateLimits.
     */
    data: ApiRateLimitCreateManyInput | ApiRateLimitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiRateLimit update
   */
  export type ApiRateLimitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRateLimit
     */
    select?: ApiRateLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRateLimit
     */
    omit?: ApiRateLimitOmit<ExtArgs> | null
    /**
     * The data needed to update a ApiRateLimit.
     */
    data: XOR<ApiRateLimitUpdateInput, ApiRateLimitUncheckedUpdateInput>
    /**
     * Choose, which ApiRateLimit to update.
     */
    where: ApiRateLimitWhereUniqueInput
  }

  /**
   * ApiRateLimit updateMany
   */
  export type ApiRateLimitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiRateLimits.
     */
    data: XOR<ApiRateLimitUpdateManyMutationInput, ApiRateLimitUncheckedUpdateManyInput>
    /**
     * Filter which ApiRateLimits to update
     */
    where?: ApiRateLimitWhereInput
    /**
     * Limit how many ApiRateLimits to update.
     */
    limit?: number
  }

  /**
   * ApiRateLimit updateManyAndReturn
   */
  export type ApiRateLimitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRateLimit
     */
    select?: ApiRateLimitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRateLimit
     */
    omit?: ApiRateLimitOmit<ExtArgs> | null
    /**
     * The data used to update ApiRateLimits.
     */
    data: XOR<ApiRateLimitUpdateManyMutationInput, ApiRateLimitUncheckedUpdateManyInput>
    /**
     * Filter which ApiRateLimits to update
     */
    where?: ApiRateLimitWhereInput
    /**
     * Limit how many ApiRateLimits to update.
     */
    limit?: number
  }

  /**
   * ApiRateLimit upsert
   */
  export type ApiRateLimitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRateLimit
     */
    select?: ApiRateLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRateLimit
     */
    omit?: ApiRateLimitOmit<ExtArgs> | null
    /**
     * The filter to search for the ApiRateLimit to update in case it exists.
     */
    where: ApiRateLimitWhereUniqueInput
    /**
     * In case the ApiRateLimit found by the `where` argument doesn't exist, create a new ApiRateLimit with this data.
     */
    create: XOR<ApiRateLimitCreateInput, ApiRateLimitUncheckedCreateInput>
    /**
     * In case the ApiRateLimit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiRateLimitUpdateInput, ApiRateLimitUncheckedUpdateInput>
  }

  /**
   * ApiRateLimit delete
   */
  export type ApiRateLimitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRateLimit
     */
    select?: ApiRateLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRateLimit
     */
    omit?: ApiRateLimitOmit<ExtArgs> | null
    /**
     * Filter which ApiRateLimit to delete.
     */
    where: ApiRateLimitWhereUniqueInput
  }

  /**
   * ApiRateLimit deleteMany
   */
  export type ApiRateLimitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiRateLimits to delete
     */
    where?: ApiRateLimitWhereInput
    /**
     * Limit how many ApiRateLimits to delete.
     */
    limit?: number
  }

  /**
   * ApiRateLimit without action
   */
  export type ApiRateLimitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiRateLimit
     */
    select?: ApiRateLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiRateLimit
     */
    omit?: ApiRateLimitOmit<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    expiresAt: Date | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date | null
    lastUsedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    expiresAt: Date | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date | null
    lastUsedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    expiresAt: number
    userAgent: number
    ipAddress: number
    createdAt: number
    lastUsedAt: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SessionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    expiresAt?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
    lastUsedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    expiresAt?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
    lastUsedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    expiresAt?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
    lastUsedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: number
    userId: number
    expiresAt: Date
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date
    lastUsedAt: Date
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "expiresAt" | "userAgent" | "ipAddress" | "createdAt" | "lastUsedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      expiresAt: Date
      userAgent: string | null
      ipAddress: string | null
      createdAt: Date
      lastUsedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'Int'>
    readonly userId: FieldRef<"Session", 'Int'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly lastUsedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model AuditRecord
   */

  export type AggregateAuditRecord = {
    _count: AuditRecordCountAggregateOutputType | null
    _avg: AuditRecordAvgAggregateOutputType | null
    _sum: AuditRecordSumAggregateOutputType | null
    _min: AuditRecordMinAggregateOutputType | null
    _max: AuditRecordMaxAggregateOutputType | null
  }

  export type AuditRecordAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    lamport: number | null
  }

  export type AuditRecordSumAggregateOutputType = {
    id: number | null
    userId: number | null
    lamport: number | null
  }

  export type AuditRecordMinAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    category: $Enums.AuditCategory | null
    status: $Enums.AuditStatus | null
    lamport: number | null
    hashPointer: string | null
    createdAt: Date | null
  }

  export type AuditRecordMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    category: $Enums.AuditCategory | null
    status: $Enums.AuditStatus | null
    lamport: number | null
    hashPointer: string | null
    createdAt: Date | null
  }

  export type AuditRecordCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    category: number
    details: number
    metadata: number
    status: number
    lamport: number
    hashPointer: number
    createdAt: number
    _all: number
  }


  export type AuditRecordAvgAggregateInputType = {
    id?: true
    userId?: true
    lamport?: true
  }

  export type AuditRecordSumAggregateInputType = {
    id?: true
    userId?: true
    lamport?: true
  }

  export type AuditRecordMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    category?: true
    status?: true
    lamport?: true
    hashPointer?: true
    createdAt?: true
  }

  export type AuditRecordMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    category?: true
    status?: true
    lamport?: true
    hashPointer?: true
    createdAt?: true
  }

  export type AuditRecordCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    category?: true
    details?: true
    metadata?: true
    status?: true
    lamport?: true
    hashPointer?: true
    createdAt?: true
    _all?: true
  }

  export type AuditRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditRecord to aggregate.
     */
    where?: AuditRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditRecords to fetch.
     */
    orderBy?: AuditRecordOrderByWithRelationInput | AuditRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditRecords
    **/
    _count?: true | AuditRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditRecordMaxAggregateInputType
  }

  export type GetAuditRecordAggregateType<T extends AuditRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditRecord[P]>
      : GetScalarType<T[P], AggregateAuditRecord[P]>
  }




  export type AuditRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditRecordWhereInput
    orderBy?: AuditRecordOrderByWithAggregationInput | AuditRecordOrderByWithAggregationInput[]
    by: AuditRecordScalarFieldEnum[] | AuditRecordScalarFieldEnum
    having?: AuditRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditRecordCountAggregateInputType | true
    _avg?: AuditRecordAvgAggregateInputType
    _sum?: AuditRecordSumAggregateInputType
    _min?: AuditRecordMinAggregateInputType
    _max?: AuditRecordMaxAggregateInputType
  }

  export type AuditRecordGroupByOutputType = {
    id: number
    userId: number
    action: string
    category: $Enums.AuditCategory
    details: JsonValue | null
    metadata: JsonValue | null
    status: $Enums.AuditStatus
    lamport: number
    hashPointer: string | null
    createdAt: Date
    _count: AuditRecordCountAggregateOutputType | null
    _avg: AuditRecordAvgAggregateOutputType | null
    _sum: AuditRecordSumAggregateOutputType | null
    _min: AuditRecordMinAggregateOutputType | null
    _max: AuditRecordMaxAggregateOutputType | null
  }

  type GetAuditRecordGroupByPayload<T extends AuditRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditRecordGroupByOutputType[P]>
            : GetScalarType<T[P], AuditRecordGroupByOutputType[P]>
        }
      >
    >


  export type AuditRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    category?: boolean
    details?: boolean
    metadata?: boolean
    status?: boolean
    lamport?: boolean
    hashPointer?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditRecord"]>

  export type AuditRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    category?: boolean
    details?: boolean
    metadata?: boolean
    status?: boolean
    lamport?: boolean
    hashPointer?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditRecord"]>

  export type AuditRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    category?: boolean
    details?: boolean
    metadata?: boolean
    status?: boolean
    lamport?: boolean
    hashPointer?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditRecord"]>

  export type AuditRecordSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    category?: boolean
    details?: boolean
    metadata?: boolean
    status?: boolean
    lamport?: boolean
    hashPointer?: boolean
    createdAt?: boolean
  }

  export type AuditRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "category" | "details" | "metadata" | "status" | "lamport" | "hashPointer" | "createdAt", ExtArgs["result"]["auditRecord"]>
  export type AuditRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditRecord"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      action: string
      category: $Enums.AuditCategory
      details: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      status: $Enums.AuditStatus
      lamport: number
      hashPointer: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditRecord"]>
    composites: {}
  }

  type AuditRecordGetPayload<S extends boolean | null | undefined | AuditRecordDefaultArgs> = $Result.GetResult<Prisma.$AuditRecordPayload, S>

  type AuditRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditRecordCountAggregateInputType | true
    }

  export interface AuditRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditRecord'], meta: { name: 'AuditRecord' } }
    /**
     * Find zero or one AuditRecord that matches the filter.
     * @param {AuditRecordFindUniqueArgs} args - Arguments to find a AuditRecord
     * @example
     * // Get one AuditRecord
     * const auditRecord = await prisma.auditRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditRecordFindUniqueArgs>(args: SelectSubset<T, AuditRecordFindUniqueArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditRecordFindUniqueOrThrowArgs} args - Arguments to find a AuditRecord
     * @example
     * // Get one AuditRecord
     * const auditRecord = await prisma.auditRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditRecordFindFirstArgs} args - Arguments to find a AuditRecord
     * @example
     * // Get one AuditRecord
     * const auditRecord = await prisma.auditRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditRecordFindFirstArgs>(args?: SelectSubset<T, AuditRecordFindFirstArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditRecordFindFirstOrThrowArgs} args - Arguments to find a AuditRecord
     * @example
     * // Get one AuditRecord
     * const auditRecord = await prisma.auditRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditRecords
     * const auditRecords = await prisma.auditRecord.findMany()
     * 
     * // Get first 10 AuditRecords
     * const auditRecords = await prisma.auditRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditRecordWithIdOnly = await prisma.auditRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditRecordFindManyArgs>(args?: SelectSubset<T, AuditRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditRecord.
     * @param {AuditRecordCreateArgs} args - Arguments to create a AuditRecord.
     * @example
     * // Create one AuditRecord
     * const AuditRecord = await prisma.auditRecord.create({
     *   data: {
     *     // ... data to create a AuditRecord
     *   }
     * })
     * 
     */
    create<T extends AuditRecordCreateArgs>(args: SelectSubset<T, AuditRecordCreateArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditRecords.
     * @param {AuditRecordCreateManyArgs} args - Arguments to create many AuditRecords.
     * @example
     * // Create many AuditRecords
     * const auditRecord = await prisma.auditRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditRecordCreateManyArgs>(args?: SelectSubset<T, AuditRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditRecords and returns the data saved in the database.
     * @param {AuditRecordCreateManyAndReturnArgs} args - Arguments to create many AuditRecords.
     * @example
     * // Create many AuditRecords
     * const auditRecord = await prisma.auditRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditRecords and only return the `id`
     * const auditRecordWithIdOnly = await prisma.auditRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditRecord.
     * @param {AuditRecordDeleteArgs} args - Arguments to delete one AuditRecord.
     * @example
     * // Delete one AuditRecord
     * const AuditRecord = await prisma.auditRecord.delete({
     *   where: {
     *     // ... filter to delete one AuditRecord
     *   }
     * })
     * 
     */
    delete<T extends AuditRecordDeleteArgs>(args: SelectSubset<T, AuditRecordDeleteArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditRecord.
     * @param {AuditRecordUpdateArgs} args - Arguments to update one AuditRecord.
     * @example
     * // Update one AuditRecord
     * const auditRecord = await prisma.auditRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditRecordUpdateArgs>(args: SelectSubset<T, AuditRecordUpdateArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditRecords.
     * @param {AuditRecordDeleteManyArgs} args - Arguments to filter AuditRecords to delete.
     * @example
     * // Delete a few AuditRecords
     * const { count } = await prisma.auditRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditRecordDeleteManyArgs>(args?: SelectSubset<T, AuditRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditRecords
     * const auditRecord = await prisma.auditRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditRecordUpdateManyArgs>(args: SelectSubset<T, AuditRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditRecords and returns the data updated in the database.
     * @param {AuditRecordUpdateManyAndReturnArgs} args - Arguments to update many AuditRecords.
     * @example
     * // Update many AuditRecords
     * const auditRecord = await prisma.auditRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditRecords and only return the `id`
     * const auditRecordWithIdOnly = await prisma.auditRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditRecord.
     * @param {AuditRecordUpsertArgs} args - Arguments to update or create a AuditRecord.
     * @example
     * // Update or create a AuditRecord
     * const auditRecord = await prisma.auditRecord.upsert({
     *   create: {
     *     // ... data to create a AuditRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditRecord we want to update
     *   }
     * })
     */
    upsert<T extends AuditRecordUpsertArgs>(args: SelectSubset<T, AuditRecordUpsertArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditRecordCountArgs} args - Arguments to filter AuditRecords to count.
     * @example
     * // Count the number of AuditRecords
     * const count = await prisma.auditRecord.count({
     *   where: {
     *     // ... the filter for the AuditRecords we want to count
     *   }
     * })
    **/
    count<T extends AuditRecordCountArgs>(
      args?: Subset<T, AuditRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditRecordAggregateArgs>(args: Subset<T, AuditRecordAggregateArgs>): Prisma.PrismaPromise<GetAuditRecordAggregateType<T>>

    /**
     * Group by AuditRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditRecordGroupByArgs['orderBy'] }
        : { orderBy?: AuditRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditRecord model
   */
  readonly fields: AuditRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditRecord model
   */
  interface AuditRecordFieldRefs {
    readonly id: FieldRef<"AuditRecord", 'Int'>
    readonly userId: FieldRef<"AuditRecord", 'Int'>
    readonly action: FieldRef<"AuditRecord", 'String'>
    readonly category: FieldRef<"AuditRecord", 'AuditCategory'>
    readonly details: FieldRef<"AuditRecord", 'Json'>
    readonly metadata: FieldRef<"AuditRecord", 'Json'>
    readonly status: FieldRef<"AuditRecord", 'AuditStatus'>
    readonly lamport: FieldRef<"AuditRecord", 'Int'>
    readonly hashPointer: FieldRef<"AuditRecord", 'String'>
    readonly createdAt: FieldRef<"AuditRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditRecord findUnique
   */
  export type AuditRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * Filter, which AuditRecord to fetch.
     */
    where: AuditRecordWhereUniqueInput
  }

  /**
   * AuditRecord findUniqueOrThrow
   */
  export type AuditRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * Filter, which AuditRecord to fetch.
     */
    where: AuditRecordWhereUniqueInput
  }

  /**
   * AuditRecord findFirst
   */
  export type AuditRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * Filter, which AuditRecord to fetch.
     */
    where?: AuditRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditRecords to fetch.
     */
    orderBy?: AuditRecordOrderByWithRelationInput | AuditRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditRecords.
     */
    cursor?: AuditRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditRecords.
     */
    distinct?: AuditRecordScalarFieldEnum | AuditRecordScalarFieldEnum[]
  }

  /**
   * AuditRecord findFirstOrThrow
   */
  export type AuditRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * Filter, which AuditRecord to fetch.
     */
    where?: AuditRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditRecords to fetch.
     */
    orderBy?: AuditRecordOrderByWithRelationInput | AuditRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditRecords.
     */
    cursor?: AuditRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditRecords.
     */
    distinct?: AuditRecordScalarFieldEnum | AuditRecordScalarFieldEnum[]
  }

  /**
   * AuditRecord findMany
   */
  export type AuditRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * Filter, which AuditRecords to fetch.
     */
    where?: AuditRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditRecords to fetch.
     */
    orderBy?: AuditRecordOrderByWithRelationInput | AuditRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditRecords.
     */
    cursor?: AuditRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditRecords.
     */
    skip?: number
    distinct?: AuditRecordScalarFieldEnum | AuditRecordScalarFieldEnum[]
  }

  /**
   * AuditRecord create
   */
  export type AuditRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditRecord.
     */
    data: XOR<AuditRecordCreateInput, AuditRecordUncheckedCreateInput>
  }

  /**
   * AuditRecord createMany
   */
  export type AuditRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditRecords.
     */
    data: AuditRecordCreateManyInput | AuditRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditRecord createManyAndReturn
   */
  export type AuditRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * The data used to create many AuditRecords.
     */
    data: AuditRecordCreateManyInput | AuditRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditRecord update
   */
  export type AuditRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditRecord.
     */
    data: XOR<AuditRecordUpdateInput, AuditRecordUncheckedUpdateInput>
    /**
     * Choose, which AuditRecord to update.
     */
    where: AuditRecordWhereUniqueInput
  }

  /**
   * AuditRecord updateMany
   */
  export type AuditRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditRecords.
     */
    data: XOR<AuditRecordUpdateManyMutationInput, AuditRecordUncheckedUpdateManyInput>
    /**
     * Filter which AuditRecords to update
     */
    where?: AuditRecordWhereInput
    /**
     * Limit how many AuditRecords to update.
     */
    limit?: number
  }

  /**
   * AuditRecord updateManyAndReturn
   */
  export type AuditRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * The data used to update AuditRecords.
     */
    data: XOR<AuditRecordUpdateManyMutationInput, AuditRecordUncheckedUpdateManyInput>
    /**
     * Filter which AuditRecords to update
     */
    where?: AuditRecordWhereInput
    /**
     * Limit how many AuditRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditRecord upsert
   */
  export type AuditRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditRecord to update in case it exists.
     */
    where: AuditRecordWhereUniqueInput
    /**
     * In case the AuditRecord found by the `where` argument doesn't exist, create a new AuditRecord with this data.
     */
    create: XOR<AuditRecordCreateInput, AuditRecordUncheckedCreateInput>
    /**
     * In case the AuditRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditRecordUpdateInput, AuditRecordUncheckedUpdateInput>
  }

  /**
   * AuditRecord delete
   */
  export type AuditRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * Filter which AuditRecord to delete.
     */
    where: AuditRecordWhereUniqueInput
  }

  /**
   * AuditRecord deleteMany
   */
  export type AuditRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditRecords to delete
     */
    where?: AuditRecordWhereInput
    /**
     * Limit how many AuditRecords to delete.
     */
    limit?: number
  }

  /**
   * AuditRecord without action
   */
  export type AuditRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
  }


  /**
   * Model LamportState
   */

  export type AggregateLamportState = {
    _count: LamportStateCountAggregateOutputType | null
    _avg: LamportStateAvgAggregateOutputType | null
    _sum: LamportStateSumAggregateOutputType | null
    _min: LamportStateMinAggregateOutputType | null
    _max: LamportStateMaxAggregateOutputType | null
  }

  export type LamportStateAvgAggregateOutputType = {
    id: number | null
    lamport: number | null
  }

  export type LamportStateSumAggregateOutputType = {
    id: number | null
    lamport: number | null
  }

  export type LamportStateMinAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    lamport: number | null
    modified: Date | null
  }

  export type LamportStateMaxAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    lamport: number | null
    modified: Date | null
  }

  export type LamportStateCountAggregateOutputType = {
    id: number
    key: number
    value: number
    lamport: number
    metadata: number
    modified: number
    _all: number
  }


  export type LamportStateAvgAggregateInputType = {
    id?: true
    lamport?: true
  }

  export type LamportStateSumAggregateInputType = {
    id?: true
    lamport?: true
  }

  export type LamportStateMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    lamport?: true
    modified?: true
  }

  export type LamportStateMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    lamport?: true
    modified?: true
  }

  export type LamportStateCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    lamport?: true
    metadata?: true
    modified?: true
    _all?: true
  }

  export type LamportStateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LamportState to aggregate.
     */
    where?: LamportStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LamportStates to fetch.
     */
    orderBy?: LamportStateOrderByWithRelationInput | LamportStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LamportStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LamportStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LamportStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LamportStates
    **/
    _count?: true | LamportStateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LamportStateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LamportStateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LamportStateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LamportStateMaxAggregateInputType
  }

  export type GetLamportStateAggregateType<T extends LamportStateAggregateArgs> = {
        [P in keyof T & keyof AggregateLamportState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLamportState[P]>
      : GetScalarType<T[P], AggregateLamportState[P]>
  }




  export type LamportStateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LamportStateWhereInput
    orderBy?: LamportStateOrderByWithAggregationInput | LamportStateOrderByWithAggregationInput[]
    by: LamportStateScalarFieldEnum[] | LamportStateScalarFieldEnum
    having?: LamportStateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LamportStateCountAggregateInputType | true
    _avg?: LamportStateAvgAggregateInputType
    _sum?: LamportStateSumAggregateInputType
    _min?: LamportStateMinAggregateInputType
    _max?: LamportStateMaxAggregateInputType
  }

  export type LamportStateGroupByOutputType = {
    id: number
    key: string
    value: string
    lamport: number
    metadata: JsonValue | null
    modified: Date
    _count: LamportStateCountAggregateOutputType | null
    _avg: LamportStateAvgAggregateOutputType | null
    _sum: LamportStateSumAggregateOutputType | null
    _min: LamportStateMinAggregateOutputType | null
    _max: LamportStateMaxAggregateOutputType | null
  }

  type GetLamportStateGroupByPayload<T extends LamportStateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LamportStateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LamportStateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LamportStateGroupByOutputType[P]>
            : GetScalarType<T[P], LamportStateGroupByOutputType[P]>
        }
      >
    >


  export type LamportStateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    lamport?: boolean
    metadata?: boolean
    modified?: boolean
  }, ExtArgs["result"]["lamportState"]>

  export type LamportStateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    lamport?: boolean
    metadata?: boolean
    modified?: boolean
  }, ExtArgs["result"]["lamportState"]>

  export type LamportStateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    lamport?: boolean
    metadata?: boolean
    modified?: boolean
  }, ExtArgs["result"]["lamportState"]>

  export type LamportStateSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    lamport?: boolean
    metadata?: boolean
    modified?: boolean
  }

  export type LamportStateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "lamport" | "metadata" | "modified", ExtArgs["result"]["lamportState"]>

  export type $LamportStatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LamportState"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      value: string
      lamport: number
      metadata: Prisma.JsonValue | null
      modified: Date
    }, ExtArgs["result"]["lamportState"]>
    composites: {}
  }

  type LamportStateGetPayload<S extends boolean | null | undefined | LamportStateDefaultArgs> = $Result.GetResult<Prisma.$LamportStatePayload, S>

  type LamportStateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LamportStateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LamportStateCountAggregateInputType | true
    }

  export interface LamportStateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LamportState'], meta: { name: 'LamportState' } }
    /**
     * Find zero or one LamportState that matches the filter.
     * @param {LamportStateFindUniqueArgs} args - Arguments to find a LamportState
     * @example
     * // Get one LamportState
     * const lamportState = await prisma.lamportState.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LamportStateFindUniqueArgs>(args: SelectSubset<T, LamportStateFindUniqueArgs<ExtArgs>>): Prisma__LamportStateClient<$Result.GetResult<Prisma.$LamportStatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LamportState that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LamportStateFindUniqueOrThrowArgs} args - Arguments to find a LamportState
     * @example
     * // Get one LamportState
     * const lamportState = await prisma.lamportState.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LamportStateFindUniqueOrThrowArgs>(args: SelectSubset<T, LamportStateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LamportStateClient<$Result.GetResult<Prisma.$LamportStatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LamportState that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LamportStateFindFirstArgs} args - Arguments to find a LamportState
     * @example
     * // Get one LamportState
     * const lamportState = await prisma.lamportState.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LamportStateFindFirstArgs>(args?: SelectSubset<T, LamportStateFindFirstArgs<ExtArgs>>): Prisma__LamportStateClient<$Result.GetResult<Prisma.$LamportStatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LamportState that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LamportStateFindFirstOrThrowArgs} args - Arguments to find a LamportState
     * @example
     * // Get one LamportState
     * const lamportState = await prisma.lamportState.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LamportStateFindFirstOrThrowArgs>(args?: SelectSubset<T, LamportStateFindFirstOrThrowArgs<ExtArgs>>): Prisma__LamportStateClient<$Result.GetResult<Prisma.$LamportStatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LamportStates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LamportStateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LamportStates
     * const lamportStates = await prisma.lamportState.findMany()
     * 
     * // Get first 10 LamportStates
     * const lamportStates = await prisma.lamportState.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lamportStateWithIdOnly = await prisma.lamportState.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LamportStateFindManyArgs>(args?: SelectSubset<T, LamportStateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LamportStatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LamportState.
     * @param {LamportStateCreateArgs} args - Arguments to create a LamportState.
     * @example
     * // Create one LamportState
     * const LamportState = await prisma.lamportState.create({
     *   data: {
     *     // ... data to create a LamportState
     *   }
     * })
     * 
     */
    create<T extends LamportStateCreateArgs>(args: SelectSubset<T, LamportStateCreateArgs<ExtArgs>>): Prisma__LamportStateClient<$Result.GetResult<Prisma.$LamportStatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LamportStates.
     * @param {LamportStateCreateManyArgs} args - Arguments to create many LamportStates.
     * @example
     * // Create many LamportStates
     * const lamportState = await prisma.lamportState.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LamportStateCreateManyArgs>(args?: SelectSubset<T, LamportStateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LamportStates and returns the data saved in the database.
     * @param {LamportStateCreateManyAndReturnArgs} args - Arguments to create many LamportStates.
     * @example
     * // Create many LamportStates
     * const lamportState = await prisma.lamportState.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LamportStates and only return the `id`
     * const lamportStateWithIdOnly = await prisma.lamportState.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LamportStateCreateManyAndReturnArgs>(args?: SelectSubset<T, LamportStateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LamportStatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LamportState.
     * @param {LamportStateDeleteArgs} args - Arguments to delete one LamportState.
     * @example
     * // Delete one LamportState
     * const LamportState = await prisma.lamportState.delete({
     *   where: {
     *     // ... filter to delete one LamportState
     *   }
     * })
     * 
     */
    delete<T extends LamportStateDeleteArgs>(args: SelectSubset<T, LamportStateDeleteArgs<ExtArgs>>): Prisma__LamportStateClient<$Result.GetResult<Prisma.$LamportStatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LamportState.
     * @param {LamportStateUpdateArgs} args - Arguments to update one LamportState.
     * @example
     * // Update one LamportState
     * const lamportState = await prisma.lamportState.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LamportStateUpdateArgs>(args: SelectSubset<T, LamportStateUpdateArgs<ExtArgs>>): Prisma__LamportStateClient<$Result.GetResult<Prisma.$LamportStatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LamportStates.
     * @param {LamportStateDeleteManyArgs} args - Arguments to filter LamportStates to delete.
     * @example
     * // Delete a few LamportStates
     * const { count } = await prisma.lamportState.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LamportStateDeleteManyArgs>(args?: SelectSubset<T, LamportStateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LamportStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LamportStateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LamportStates
     * const lamportState = await prisma.lamportState.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LamportStateUpdateManyArgs>(args: SelectSubset<T, LamportStateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LamportStates and returns the data updated in the database.
     * @param {LamportStateUpdateManyAndReturnArgs} args - Arguments to update many LamportStates.
     * @example
     * // Update many LamportStates
     * const lamportState = await prisma.lamportState.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LamportStates and only return the `id`
     * const lamportStateWithIdOnly = await prisma.lamportState.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LamportStateUpdateManyAndReturnArgs>(args: SelectSubset<T, LamportStateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LamportStatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LamportState.
     * @param {LamportStateUpsertArgs} args - Arguments to update or create a LamportState.
     * @example
     * // Update or create a LamportState
     * const lamportState = await prisma.lamportState.upsert({
     *   create: {
     *     // ... data to create a LamportState
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LamportState we want to update
     *   }
     * })
     */
    upsert<T extends LamportStateUpsertArgs>(args: SelectSubset<T, LamportStateUpsertArgs<ExtArgs>>): Prisma__LamportStateClient<$Result.GetResult<Prisma.$LamportStatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LamportStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LamportStateCountArgs} args - Arguments to filter LamportStates to count.
     * @example
     * // Count the number of LamportStates
     * const count = await prisma.lamportState.count({
     *   where: {
     *     // ... the filter for the LamportStates we want to count
     *   }
     * })
    **/
    count<T extends LamportStateCountArgs>(
      args?: Subset<T, LamportStateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LamportStateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LamportState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LamportStateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LamportStateAggregateArgs>(args: Subset<T, LamportStateAggregateArgs>): Prisma.PrismaPromise<GetLamportStateAggregateType<T>>

    /**
     * Group by LamportState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LamportStateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LamportStateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LamportStateGroupByArgs['orderBy'] }
        : { orderBy?: LamportStateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LamportStateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLamportStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LamportState model
   */
  readonly fields: LamportStateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LamportState.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LamportStateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LamportState model
   */
  interface LamportStateFieldRefs {
    readonly id: FieldRef<"LamportState", 'Int'>
    readonly key: FieldRef<"LamportState", 'String'>
    readonly value: FieldRef<"LamportState", 'String'>
    readonly lamport: FieldRef<"LamportState", 'Int'>
    readonly metadata: FieldRef<"LamportState", 'Json'>
    readonly modified: FieldRef<"LamportState", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LamportState findUnique
   */
  export type LamportStateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportState
     */
    select?: LamportStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LamportState
     */
    omit?: LamportStateOmit<ExtArgs> | null
    /**
     * Filter, which LamportState to fetch.
     */
    where: LamportStateWhereUniqueInput
  }

  /**
   * LamportState findUniqueOrThrow
   */
  export type LamportStateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportState
     */
    select?: LamportStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LamportState
     */
    omit?: LamportStateOmit<ExtArgs> | null
    /**
     * Filter, which LamportState to fetch.
     */
    where: LamportStateWhereUniqueInput
  }

  /**
   * LamportState findFirst
   */
  export type LamportStateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportState
     */
    select?: LamportStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LamportState
     */
    omit?: LamportStateOmit<ExtArgs> | null
    /**
     * Filter, which LamportState to fetch.
     */
    where?: LamportStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LamportStates to fetch.
     */
    orderBy?: LamportStateOrderByWithRelationInput | LamportStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LamportStates.
     */
    cursor?: LamportStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LamportStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LamportStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LamportStates.
     */
    distinct?: LamportStateScalarFieldEnum | LamportStateScalarFieldEnum[]
  }

  /**
   * LamportState findFirstOrThrow
   */
  export type LamportStateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportState
     */
    select?: LamportStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LamportState
     */
    omit?: LamportStateOmit<ExtArgs> | null
    /**
     * Filter, which LamportState to fetch.
     */
    where?: LamportStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LamportStates to fetch.
     */
    orderBy?: LamportStateOrderByWithRelationInput | LamportStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LamportStates.
     */
    cursor?: LamportStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LamportStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LamportStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LamportStates.
     */
    distinct?: LamportStateScalarFieldEnum | LamportStateScalarFieldEnum[]
  }

  /**
   * LamportState findMany
   */
  export type LamportStateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportState
     */
    select?: LamportStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LamportState
     */
    omit?: LamportStateOmit<ExtArgs> | null
    /**
     * Filter, which LamportStates to fetch.
     */
    where?: LamportStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LamportStates to fetch.
     */
    orderBy?: LamportStateOrderByWithRelationInput | LamportStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LamportStates.
     */
    cursor?: LamportStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LamportStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LamportStates.
     */
    skip?: number
    distinct?: LamportStateScalarFieldEnum | LamportStateScalarFieldEnum[]
  }

  /**
   * LamportState create
   */
  export type LamportStateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportState
     */
    select?: LamportStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LamportState
     */
    omit?: LamportStateOmit<ExtArgs> | null
    /**
     * The data needed to create a LamportState.
     */
    data: XOR<LamportStateCreateInput, LamportStateUncheckedCreateInput>
  }

  /**
   * LamportState createMany
   */
  export type LamportStateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LamportStates.
     */
    data: LamportStateCreateManyInput | LamportStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LamportState createManyAndReturn
   */
  export type LamportStateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportState
     */
    select?: LamportStateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LamportState
     */
    omit?: LamportStateOmit<ExtArgs> | null
    /**
     * The data used to create many LamportStates.
     */
    data: LamportStateCreateManyInput | LamportStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LamportState update
   */
  export type LamportStateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportState
     */
    select?: LamportStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LamportState
     */
    omit?: LamportStateOmit<ExtArgs> | null
    /**
     * The data needed to update a LamportState.
     */
    data: XOR<LamportStateUpdateInput, LamportStateUncheckedUpdateInput>
    /**
     * Choose, which LamportState to update.
     */
    where: LamportStateWhereUniqueInput
  }

  /**
   * LamportState updateMany
   */
  export type LamportStateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LamportStates.
     */
    data: XOR<LamportStateUpdateManyMutationInput, LamportStateUncheckedUpdateManyInput>
    /**
     * Filter which LamportStates to update
     */
    where?: LamportStateWhereInput
    /**
     * Limit how many LamportStates to update.
     */
    limit?: number
  }

  /**
   * LamportState updateManyAndReturn
   */
  export type LamportStateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportState
     */
    select?: LamportStateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LamportState
     */
    omit?: LamportStateOmit<ExtArgs> | null
    /**
     * The data used to update LamportStates.
     */
    data: XOR<LamportStateUpdateManyMutationInput, LamportStateUncheckedUpdateManyInput>
    /**
     * Filter which LamportStates to update
     */
    where?: LamportStateWhereInput
    /**
     * Limit how many LamportStates to update.
     */
    limit?: number
  }

  /**
   * LamportState upsert
   */
  export type LamportStateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportState
     */
    select?: LamportStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LamportState
     */
    omit?: LamportStateOmit<ExtArgs> | null
    /**
     * The filter to search for the LamportState to update in case it exists.
     */
    where: LamportStateWhereUniqueInput
    /**
     * In case the LamportState found by the `where` argument doesn't exist, create a new LamportState with this data.
     */
    create: XOR<LamportStateCreateInput, LamportStateUncheckedCreateInput>
    /**
     * In case the LamportState was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LamportStateUpdateInput, LamportStateUncheckedUpdateInput>
  }

  /**
   * LamportState delete
   */
  export type LamportStateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportState
     */
    select?: LamportStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LamportState
     */
    omit?: LamportStateOmit<ExtArgs> | null
    /**
     * Filter which LamportState to delete.
     */
    where: LamportStateWhereUniqueInput
  }

  /**
   * LamportState deleteMany
   */
  export type LamportStateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LamportStates to delete
     */
    where?: LamportStateWhereInput
    /**
     * Limit how many LamportStates to delete.
     */
    limit?: number
  }

  /**
   * LamportState without action
   */
  export type LamportStateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportState
     */
    select?: LamportStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LamportState
     */
    omit?: LamportStateOmit<ExtArgs> | null
  }


  /**
   * Model Budget
   */

  export type AggregateBudget = {
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  export type BudgetAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    limit: number | null
  }

  export type BudgetSumAggregateOutputType = {
    id: number | null
    userId: number | null
    limit: number | null
  }

  export type BudgetMinAggregateOutputType = {
    id: number | null
    userId: number | null
    limit: number | null
    period: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudgetMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    limit: number | null
    period: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudgetCountAggregateOutputType = {
    id: number
    userId: number
    limit: number
    period: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BudgetAvgAggregateInputType = {
    id?: true
    userId?: true
    limit?: true
  }

  export type BudgetSumAggregateInputType = {
    id?: true
    userId?: true
    limit?: true
  }

  export type BudgetMinAggregateInputType = {
    id?: true
    userId?: true
    limit?: true
    period?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudgetMaxAggregateInputType = {
    id?: true
    userId?: true
    limit?: true
    period?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudgetCountAggregateInputType = {
    id?: true
    userId?: true
    limit?: true
    period?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BudgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budget to aggregate.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Budgets
    **/
    _count?: true | BudgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetMaxAggregateInputType
  }

  export type GetBudgetAggregateType<T extends BudgetAggregateArgs> = {
        [P in keyof T & keyof AggregateBudget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudget[P]>
      : GetScalarType<T[P], AggregateBudget[P]>
  }




  export type BudgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithAggregationInput | BudgetOrderByWithAggregationInput[]
    by: BudgetScalarFieldEnum[] | BudgetScalarFieldEnum
    having?: BudgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetCountAggregateInputType | true
    _avg?: BudgetAvgAggregateInputType
    _sum?: BudgetSumAggregateInputType
    _min?: BudgetMinAggregateInputType
    _max?: BudgetMaxAggregateInputType
  }

  export type BudgetGroupByOutputType = {
    id: number
    userId: number
    limit: number
    period: string
    createdAt: Date
    updatedAt: Date
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  type GetBudgetGroupByPayload<T extends BudgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetGroupByOutputType[P]>
        }
      >
    >


  export type BudgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    limit?: boolean
    period?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    limit?: boolean
    period?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    limit?: boolean
    period?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectScalar = {
    id?: boolean
    userId?: boolean
    limit?: boolean
    period?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BudgetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "limit" | "period" | "createdAt" | "updatedAt", ExtArgs["result"]["budget"]>
  export type BudgetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BudgetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BudgetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BudgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Budget"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      limit: number
      period: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["budget"]>
    composites: {}
  }

  type BudgetGetPayload<S extends boolean | null | undefined | BudgetDefaultArgs> = $Result.GetResult<Prisma.$BudgetPayload, S>

  type BudgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BudgetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BudgetCountAggregateInputType | true
    }

  export interface BudgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Budget'], meta: { name: 'Budget' } }
    /**
     * Find zero or one Budget that matches the filter.
     * @param {BudgetFindUniqueArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetFindUniqueArgs>(args: SelectSubset<T, BudgetFindUniqueArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Budget that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BudgetFindUniqueOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetFindFirstArgs>(args?: SelectSubset<T, BudgetFindFirstArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Budgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Budgets
     * const budgets = await prisma.budget.findMany()
     * 
     * // Get first 10 Budgets
     * const budgets = await prisma.budget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetWithIdOnly = await prisma.budget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetFindManyArgs>(args?: SelectSubset<T, BudgetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Budget.
     * @param {BudgetCreateArgs} args - Arguments to create a Budget.
     * @example
     * // Create one Budget
     * const Budget = await prisma.budget.create({
     *   data: {
     *     // ... data to create a Budget
     *   }
     * })
     * 
     */
    create<T extends BudgetCreateArgs>(args: SelectSubset<T, BudgetCreateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Budgets.
     * @param {BudgetCreateManyArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetCreateManyArgs>(args?: SelectSubset<T, BudgetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Budgets and returns the data saved in the database.
     * @param {BudgetCreateManyAndReturnArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Budget.
     * @param {BudgetDeleteArgs} args - Arguments to delete one Budget.
     * @example
     * // Delete one Budget
     * const Budget = await prisma.budget.delete({
     *   where: {
     *     // ... filter to delete one Budget
     *   }
     * })
     * 
     */
    delete<T extends BudgetDeleteArgs>(args: SelectSubset<T, BudgetDeleteArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Budget.
     * @param {BudgetUpdateArgs} args - Arguments to update one Budget.
     * @example
     * // Update one Budget
     * const budget = await prisma.budget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetUpdateArgs>(args: SelectSubset<T, BudgetUpdateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Budgets.
     * @param {BudgetDeleteManyArgs} args - Arguments to filter Budgets to delete.
     * @example
     * // Delete a few Budgets
     * const { count } = await prisma.budget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetDeleteManyArgs>(args?: SelectSubset<T, BudgetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetUpdateManyArgs>(args: SelectSubset<T, BudgetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets and returns the data updated in the database.
     * @param {BudgetUpdateManyAndReturnArgs} args - Arguments to update many Budgets.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BudgetUpdateManyAndReturnArgs>(args: SelectSubset<T, BudgetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Budget.
     * @param {BudgetUpsertArgs} args - Arguments to update or create a Budget.
     * @example
     * // Update or create a Budget
     * const budget = await prisma.budget.upsert({
     *   create: {
     *     // ... data to create a Budget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Budget we want to update
     *   }
     * })
     */
    upsert<T extends BudgetUpsertArgs>(args: SelectSubset<T, BudgetUpsertArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCountArgs} args - Arguments to filter Budgets to count.
     * @example
     * // Count the number of Budgets
     * const count = await prisma.budget.count({
     *   where: {
     *     // ... the filter for the Budgets we want to count
     *   }
     * })
    **/
    count<T extends BudgetCountArgs>(
      args?: Subset<T, BudgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetAggregateArgs>(args: Subset<T, BudgetAggregateArgs>): Prisma.PrismaPromise<GetBudgetAggregateType<T>>

    /**
     * Group by Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetGroupByArgs['orderBy'] }
        : { orderBy?: BudgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Budget model
   */
  readonly fields: BudgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Budget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Budget model
   */
  interface BudgetFieldRefs {
    readonly id: FieldRef<"Budget", 'Int'>
    readonly userId: FieldRef<"Budget", 'Int'>
    readonly limit: FieldRef<"Budget", 'Float'>
    readonly period: FieldRef<"Budget", 'String'>
    readonly createdAt: FieldRef<"Budget", 'DateTime'>
    readonly updatedAt: FieldRef<"Budget", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Budget findUnique
   */
  export type BudgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findUniqueOrThrow
   */
  export type BudgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findFirst
   */
  export type BudgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findFirstOrThrow
   */
  export type BudgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findMany
   */
  export type BudgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budgets to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget create
   */
  export type BudgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to create a Budget.
     */
    data: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
  }

  /**
   * Budget createMany
   */
  export type BudgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Budget createManyAndReturn
   */
  export type BudgetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Budget update
   */
  export type BudgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to update a Budget.
     */
    data: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
    /**
     * Choose, which Budget to update.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget updateMany
   */
  export type BudgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to update.
     */
    limit?: number
  }

  /**
   * Budget updateManyAndReturn
   */
  export type BudgetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Budget upsert
   */
  export type BudgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The filter to search for the Budget to update in case it exists.
     */
    where: BudgetWhereUniqueInput
    /**
     * In case the Budget found by the `where` argument doesn't exist, create a new Budget with this data.
     */
    create: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
    /**
     * In case the Budget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
  }

  /**
   * Budget delete
   */
  export type BudgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter which Budget to delete.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget deleteMany
   */
  export type BudgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budgets to delete
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to delete.
     */
    limit?: number
  }

  /**
   * Budget without action
   */
  export type BudgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
  }


  /**
   * Model RegressionBaseline
   */

  export type AggregateRegressionBaseline = {
    _count: RegressionBaselineCountAggregateOutputType | null
    _avg: RegressionBaselineAvgAggregateOutputType | null
    _sum: RegressionBaselineSumAggregateOutputType | null
    _min: RegressionBaselineMinAggregateOutputType | null
    _max: RegressionBaselineMaxAggregateOutputType | null
  }

  export type RegressionBaselineAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    avgResponseTime: number | null
    avgCost: number | null
    avgQualityScore: number | null
    avgAccuracy: number | null
    successRate: number | null
    alertThreshold: number | null
    sampleSize: number | null
  }

  export type RegressionBaselineSumAggregateOutputType = {
    id: number | null
    userId: number | null
    avgResponseTime: number | null
    avgCost: number | null
    avgQualityScore: number | null
    avgAccuracy: number | null
    successRate: number | null
    alertThreshold: number | null
    sampleSize: number | null
  }

  export type RegressionBaselineMinAggregateOutputType = {
    id: number | null
    userId: number | null
    modelName: string | null
    modelVersion: string | null
    testType: string | null
    avgResponseTime: number | null
    avgCost: number | null
    avgQualityScore: number | null
    avgAccuracy: number | null
    successRate: number | null
    alertThreshold: number | null
    sampleSize: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RegressionBaselineMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    modelName: string | null
    modelVersion: string | null
    testType: string | null
    avgResponseTime: number | null
    avgCost: number | null
    avgQualityScore: number | null
    avgAccuracy: number | null
    successRate: number | null
    alertThreshold: number | null
    sampleSize: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RegressionBaselineCountAggregateOutputType = {
    id: number
    userId: number
    modelName: number
    modelVersion: number
    testType: number
    avgResponseTime: number
    avgCost: number
    avgQualityScore: number
    avgAccuracy: number
    successRate: number
    alertThreshold: number
    sampleSize: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RegressionBaselineAvgAggregateInputType = {
    id?: true
    userId?: true
    avgResponseTime?: true
    avgCost?: true
    avgQualityScore?: true
    avgAccuracy?: true
    successRate?: true
    alertThreshold?: true
    sampleSize?: true
  }

  export type RegressionBaselineSumAggregateInputType = {
    id?: true
    userId?: true
    avgResponseTime?: true
    avgCost?: true
    avgQualityScore?: true
    avgAccuracy?: true
    successRate?: true
    alertThreshold?: true
    sampleSize?: true
  }

  export type RegressionBaselineMinAggregateInputType = {
    id?: true
    userId?: true
    modelName?: true
    modelVersion?: true
    testType?: true
    avgResponseTime?: true
    avgCost?: true
    avgQualityScore?: true
    avgAccuracy?: true
    successRate?: true
    alertThreshold?: true
    sampleSize?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RegressionBaselineMaxAggregateInputType = {
    id?: true
    userId?: true
    modelName?: true
    modelVersion?: true
    testType?: true
    avgResponseTime?: true
    avgCost?: true
    avgQualityScore?: true
    avgAccuracy?: true
    successRate?: true
    alertThreshold?: true
    sampleSize?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RegressionBaselineCountAggregateInputType = {
    id?: true
    userId?: true
    modelName?: true
    modelVersion?: true
    testType?: true
    avgResponseTime?: true
    avgCost?: true
    avgQualityScore?: true
    avgAccuracy?: true
    successRate?: true
    alertThreshold?: true
    sampleSize?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RegressionBaselineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegressionBaseline to aggregate.
     */
    where?: RegressionBaselineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegressionBaselines to fetch.
     */
    orderBy?: RegressionBaselineOrderByWithRelationInput | RegressionBaselineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegressionBaselineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegressionBaselines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegressionBaselines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RegressionBaselines
    **/
    _count?: true | RegressionBaselineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegressionBaselineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegressionBaselineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegressionBaselineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegressionBaselineMaxAggregateInputType
  }

  export type GetRegressionBaselineAggregateType<T extends RegressionBaselineAggregateArgs> = {
        [P in keyof T & keyof AggregateRegressionBaseline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegressionBaseline[P]>
      : GetScalarType<T[P], AggregateRegressionBaseline[P]>
  }




  export type RegressionBaselineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegressionBaselineWhereInput
    orderBy?: RegressionBaselineOrderByWithAggregationInput | RegressionBaselineOrderByWithAggregationInput[]
    by: RegressionBaselineScalarFieldEnum[] | RegressionBaselineScalarFieldEnum
    having?: RegressionBaselineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegressionBaselineCountAggregateInputType | true
    _avg?: RegressionBaselineAvgAggregateInputType
    _sum?: RegressionBaselineSumAggregateInputType
    _min?: RegressionBaselineMinAggregateInputType
    _max?: RegressionBaselineMaxAggregateInputType
  }

  export type RegressionBaselineGroupByOutputType = {
    id: number
    userId: number
    modelName: string
    modelVersion: string | null
    testType: string
    avgResponseTime: number
    avgCost: number
    avgQualityScore: number
    avgAccuracy: number
    successRate: number
    alertThreshold: number
    sampleSize: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: RegressionBaselineCountAggregateOutputType | null
    _avg: RegressionBaselineAvgAggregateOutputType | null
    _sum: RegressionBaselineSumAggregateOutputType | null
    _min: RegressionBaselineMinAggregateOutputType | null
    _max: RegressionBaselineMaxAggregateOutputType | null
  }

  type GetRegressionBaselineGroupByPayload<T extends RegressionBaselineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegressionBaselineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegressionBaselineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegressionBaselineGroupByOutputType[P]>
            : GetScalarType<T[P], RegressionBaselineGroupByOutputType[P]>
        }
      >
    >


  export type RegressionBaselineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    modelName?: boolean
    modelVersion?: boolean
    testType?: boolean
    avgResponseTime?: boolean
    avgCost?: boolean
    avgQualityScore?: boolean
    avgAccuracy?: boolean
    successRate?: boolean
    alertThreshold?: boolean
    sampleSize?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["regressionBaseline"]>

  export type RegressionBaselineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    modelName?: boolean
    modelVersion?: boolean
    testType?: boolean
    avgResponseTime?: boolean
    avgCost?: boolean
    avgQualityScore?: boolean
    avgAccuracy?: boolean
    successRate?: boolean
    alertThreshold?: boolean
    sampleSize?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["regressionBaseline"]>

  export type RegressionBaselineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    modelName?: boolean
    modelVersion?: boolean
    testType?: boolean
    avgResponseTime?: boolean
    avgCost?: boolean
    avgQualityScore?: boolean
    avgAccuracy?: boolean
    successRate?: boolean
    alertThreshold?: boolean
    sampleSize?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["regressionBaseline"]>

  export type RegressionBaselineSelectScalar = {
    id?: boolean
    userId?: boolean
    modelName?: boolean
    modelVersion?: boolean
    testType?: boolean
    avgResponseTime?: boolean
    avgCost?: boolean
    avgQualityScore?: boolean
    avgAccuracy?: boolean
    successRate?: boolean
    alertThreshold?: boolean
    sampleSize?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RegressionBaselineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "modelName" | "modelVersion" | "testType" | "avgResponseTime" | "avgCost" | "avgQualityScore" | "avgAccuracy" | "successRate" | "alertThreshold" | "sampleSize" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["regressionBaseline"]>
  export type RegressionBaselineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RegressionBaselineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RegressionBaselineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RegressionBaselinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RegressionBaseline"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      modelName: string
      modelVersion: string | null
      testType: string
      avgResponseTime: number
      avgCost: number
      avgQualityScore: number
      avgAccuracy: number
      successRate: number
      alertThreshold: number
      sampleSize: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["regressionBaseline"]>
    composites: {}
  }

  type RegressionBaselineGetPayload<S extends boolean | null | undefined | RegressionBaselineDefaultArgs> = $Result.GetResult<Prisma.$RegressionBaselinePayload, S>

  type RegressionBaselineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegressionBaselineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegressionBaselineCountAggregateInputType | true
    }

  export interface RegressionBaselineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RegressionBaseline'], meta: { name: 'RegressionBaseline' } }
    /**
     * Find zero or one RegressionBaseline that matches the filter.
     * @param {RegressionBaselineFindUniqueArgs} args - Arguments to find a RegressionBaseline
     * @example
     * // Get one RegressionBaseline
     * const regressionBaseline = await prisma.regressionBaseline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegressionBaselineFindUniqueArgs>(args: SelectSubset<T, RegressionBaselineFindUniqueArgs<ExtArgs>>): Prisma__RegressionBaselineClient<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RegressionBaseline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegressionBaselineFindUniqueOrThrowArgs} args - Arguments to find a RegressionBaseline
     * @example
     * // Get one RegressionBaseline
     * const regressionBaseline = await prisma.regressionBaseline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegressionBaselineFindUniqueOrThrowArgs>(args: SelectSubset<T, RegressionBaselineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegressionBaselineClient<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegressionBaseline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegressionBaselineFindFirstArgs} args - Arguments to find a RegressionBaseline
     * @example
     * // Get one RegressionBaseline
     * const regressionBaseline = await prisma.regressionBaseline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegressionBaselineFindFirstArgs>(args?: SelectSubset<T, RegressionBaselineFindFirstArgs<ExtArgs>>): Prisma__RegressionBaselineClient<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegressionBaseline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegressionBaselineFindFirstOrThrowArgs} args - Arguments to find a RegressionBaseline
     * @example
     * // Get one RegressionBaseline
     * const regressionBaseline = await prisma.regressionBaseline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegressionBaselineFindFirstOrThrowArgs>(args?: SelectSubset<T, RegressionBaselineFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegressionBaselineClient<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RegressionBaselines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegressionBaselineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RegressionBaselines
     * const regressionBaselines = await prisma.regressionBaseline.findMany()
     * 
     * // Get first 10 RegressionBaselines
     * const regressionBaselines = await prisma.regressionBaseline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regressionBaselineWithIdOnly = await prisma.regressionBaseline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegressionBaselineFindManyArgs>(args?: SelectSubset<T, RegressionBaselineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RegressionBaseline.
     * @param {RegressionBaselineCreateArgs} args - Arguments to create a RegressionBaseline.
     * @example
     * // Create one RegressionBaseline
     * const RegressionBaseline = await prisma.regressionBaseline.create({
     *   data: {
     *     // ... data to create a RegressionBaseline
     *   }
     * })
     * 
     */
    create<T extends RegressionBaselineCreateArgs>(args: SelectSubset<T, RegressionBaselineCreateArgs<ExtArgs>>): Prisma__RegressionBaselineClient<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RegressionBaselines.
     * @param {RegressionBaselineCreateManyArgs} args - Arguments to create many RegressionBaselines.
     * @example
     * // Create many RegressionBaselines
     * const regressionBaseline = await prisma.regressionBaseline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegressionBaselineCreateManyArgs>(args?: SelectSubset<T, RegressionBaselineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RegressionBaselines and returns the data saved in the database.
     * @param {RegressionBaselineCreateManyAndReturnArgs} args - Arguments to create many RegressionBaselines.
     * @example
     * // Create many RegressionBaselines
     * const regressionBaseline = await prisma.regressionBaseline.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RegressionBaselines and only return the `id`
     * const regressionBaselineWithIdOnly = await prisma.regressionBaseline.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegressionBaselineCreateManyAndReturnArgs>(args?: SelectSubset<T, RegressionBaselineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RegressionBaseline.
     * @param {RegressionBaselineDeleteArgs} args - Arguments to delete one RegressionBaseline.
     * @example
     * // Delete one RegressionBaseline
     * const RegressionBaseline = await prisma.regressionBaseline.delete({
     *   where: {
     *     // ... filter to delete one RegressionBaseline
     *   }
     * })
     * 
     */
    delete<T extends RegressionBaselineDeleteArgs>(args: SelectSubset<T, RegressionBaselineDeleteArgs<ExtArgs>>): Prisma__RegressionBaselineClient<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RegressionBaseline.
     * @param {RegressionBaselineUpdateArgs} args - Arguments to update one RegressionBaseline.
     * @example
     * // Update one RegressionBaseline
     * const regressionBaseline = await prisma.regressionBaseline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegressionBaselineUpdateArgs>(args: SelectSubset<T, RegressionBaselineUpdateArgs<ExtArgs>>): Prisma__RegressionBaselineClient<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RegressionBaselines.
     * @param {RegressionBaselineDeleteManyArgs} args - Arguments to filter RegressionBaselines to delete.
     * @example
     * // Delete a few RegressionBaselines
     * const { count } = await prisma.regressionBaseline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegressionBaselineDeleteManyArgs>(args?: SelectSubset<T, RegressionBaselineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegressionBaselines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegressionBaselineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RegressionBaselines
     * const regressionBaseline = await prisma.regressionBaseline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegressionBaselineUpdateManyArgs>(args: SelectSubset<T, RegressionBaselineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegressionBaselines and returns the data updated in the database.
     * @param {RegressionBaselineUpdateManyAndReturnArgs} args - Arguments to update many RegressionBaselines.
     * @example
     * // Update many RegressionBaselines
     * const regressionBaseline = await prisma.regressionBaseline.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RegressionBaselines and only return the `id`
     * const regressionBaselineWithIdOnly = await prisma.regressionBaseline.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RegressionBaselineUpdateManyAndReturnArgs>(args: SelectSubset<T, RegressionBaselineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RegressionBaseline.
     * @param {RegressionBaselineUpsertArgs} args - Arguments to update or create a RegressionBaseline.
     * @example
     * // Update or create a RegressionBaseline
     * const regressionBaseline = await prisma.regressionBaseline.upsert({
     *   create: {
     *     // ... data to create a RegressionBaseline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RegressionBaseline we want to update
     *   }
     * })
     */
    upsert<T extends RegressionBaselineUpsertArgs>(args: SelectSubset<T, RegressionBaselineUpsertArgs<ExtArgs>>): Prisma__RegressionBaselineClient<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RegressionBaselines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegressionBaselineCountArgs} args - Arguments to filter RegressionBaselines to count.
     * @example
     * // Count the number of RegressionBaselines
     * const count = await prisma.regressionBaseline.count({
     *   where: {
     *     // ... the filter for the RegressionBaselines we want to count
     *   }
     * })
    **/
    count<T extends RegressionBaselineCountArgs>(
      args?: Subset<T, RegressionBaselineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegressionBaselineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RegressionBaseline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegressionBaselineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegressionBaselineAggregateArgs>(args: Subset<T, RegressionBaselineAggregateArgs>): Prisma.PrismaPromise<GetRegressionBaselineAggregateType<T>>

    /**
     * Group by RegressionBaseline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegressionBaselineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegressionBaselineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegressionBaselineGroupByArgs['orderBy'] }
        : { orderBy?: RegressionBaselineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegressionBaselineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegressionBaselineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RegressionBaseline model
   */
  readonly fields: RegressionBaselineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RegressionBaseline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegressionBaselineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RegressionBaseline model
   */
  interface RegressionBaselineFieldRefs {
    readonly id: FieldRef<"RegressionBaseline", 'Int'>
    readonly userId: FieldRef<"RegressionBaseline", 'Int'>
    readonly modelName: FieldRef<"RegressionBaseline", 'String'>
    readonly modelVersion: FieldRef<"RegressionBaseline", 'String'>
    readonly testType: FieldRef<"RegressionBaseline", 'String'>
    readonly avgResponseTime: FieldRef<"RegressionBaseline", 'Float'>
    readonly avgCost: FieldRef<"RegressionBaseline", 'Float'>
    readonly avgQualityScore: FieldRef<"RegressionBaseline", 'Float'>
    readonly avgAccuracy: FieldRef<"RegressionBaseline", 'Float'>
    readonly successRate: FieldRef<"RegressionBaseline", 'Float'>
    readonly alertThreshold: FieldRef<"RegressionBaseline", 'Float'>
    readonly sampleSize: FieldRef<"RegressionBaseline", 'Int'>
    readonly isActive: FieldRef<"RegressionBaseline", 'Boolean'>
    readonly createdAt: FieldRef<"RegressionBaseline", 'DateTime'>
    readonly updatedAt: FieldRef<"RegressionBaseline", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RegressionBaseline findUnique
   */
  export type RegressionBaselineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
    /**
     * Filter, which RegressionBaseline to fetch.
     */
    where: RegressionBaselineWhereUniqueInput
  }

  /**
   * RegressionBaseline findUniqueOrThrow
   */
  export type RegressionBaselineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
    /**
     * Filter, which RegressionBaseline to fetch.
     */
    where: RegressionBaselineWhereUniqueInput
  }

  /**
   * RegressionBaseline findFirst
   */
  export type RegressionBaselineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
    /**
     * Filter, which RegressionBaseline to fetch.
     */
    where?: RegressionBaselineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegressionBaselines to fetch.
     */
    orderBy?: RegressionBaselineOrderByWithRelationInput | RegressionBaselineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegressionBaselines.
     */
    cursor?: RegressionBaselineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegressionBaselines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegressionBaselines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegressionBaselines.
     */
    distinct?: RegressionBaselineScalarFieldEnum | RegressionBaselineScalarFieldEnum[]
  }

  /**
   * RegressionBaseline findFirstOrThrow
   */
  export type RegressionBaselineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
    /**
     * Filter, which RegressionBaseline to fetch.
     */
    where?: RegressionBaselineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegressionBaselines to fetch.
     */
    orderBy?: RegressionBaselineOrderByWithRelationInput | RegressionBaselineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegressionBaselines.
     */
    cursor?: RegressionBaselineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegressionBaselines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegressionBaselines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegressionBaselines.
     */
    distinct?: RegressionBaselineScalarFieldEnum | RegressionBaselineScalarFieldEnum[]
  }

  /**
   * RegressionBaseline findMany
   */
  export type RegressionBaselineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
    /**
     * Filter, which RegressionBaselines to fetch.
     */
    where?: RegressionBaselineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegressionBaselines to fetch.
     */
    orderBy?: RegressionBaselineOrderByWithRelationInput | RegressionBaselineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RegressionBaselines.
     */
    cursor?: RegressionBaselineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegressionBaselines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegressionBaselines.
     */
    skip?: number
    distinct?: RegressionBaselineScalarFieldEnum | RegressionBaselineScalarFieldEnum[]
  }

  /**
   * RegressionBaseline create
   */
  export type RegressionBaselineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
    /**
     * The data needed to create a RegressionBaseline.
     */
    data: XOR<RegressionBaselineCreateInput, RegressionBaselineUncheckedCreateInput>
  }

  /**
   * RegressionBaseline createMany
   */
  export type RegressionBaselineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RegressionBaselines.
     */
    data: RegressionBaselineCreateManyInput | RegressionBaselineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RegressionBaseline createManyAndReturn
   */
  export type RegressionBaselineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * The data used to create many RegressionBaselines.
     */
    data: RegressionBaselineCreateManyInput | RegressionBaselineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RegressionBaseline update
   */
  export type RegressionBaselineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
    /**
     * The data needed to update a RegressionBaseline.
     */
    data: XOR<RegressionBaselineUpdateInput, RegressionBaselineUncheckedUpdateInput>
    /**
     * Choose, which RegressionBaseline to update.
     */
    where: RegressionBaselineWhereUniqueInput
  }

  /**
   * RegressionBaseline updateMany
   */
  export type RegressionBaselineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RegressionBaselines.
     */
    data: XOR<RegressionBaselineUpdateManyMutationInput, RegressionBaselineUncheckedUpdateManyInput>
    /**
     * Filter which RegressionBaselines to update
     */
    where?: RegressionBaselineWhereInput
    /**
     * Limit how many RegressionBaselines to update.
     */
    limit?: number
  }

  /**
   * RegressionBaseline updateManyAndReturn
   */
  export type RegressionBaselineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * The data used to update RegressionBaselines.
     */
    data: XOR<RegressionBaselineUpdateManyMutationInput, RegressionBaselineUncheckedUpdateManyInput>
    /**
     * Filter which RegressionBaselines to update
     */
    where?: RegressionBaselineWhereInput
    /**
     * Limit how many RegressionBaselines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RegressionBaseline upsert
   */
  export type RegressionBaselineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
    /**
     * The filter to search for the RegressionBaseline to update in case it exists.
     */
    where: RegressionBaselineWhereUniqueInput
    /**
     * In case the RegressionBaseline found by the `where` argument doesn't exist, create a new RegressionBaseline with this data.
     */
    create: XOR<RegressionBaselineCreateInput, RegressionBaselineUncheckedCreateInput>
    /**
     * In case the RegressionBaseline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegressionBaselineUpdateInput, RegressionBaselineUncheckedUpdateInput>
  }

  /**
   * RegressionBaseline delete
   */
  export type RegressionBaselineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
    /**
     * Filter which RegressionBaseline to delete.
     */
    where: RegressionBaselineWhereUniqueInput
  }

  /**
   * RegressionBaseline deleteMany
   */
  export type RegressionBaselineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegressionBaselines to delete
     */
    where?: RegressionBaselineWhereInput
    /**
     * Limit how many RegressionBaselines to delete.
     */
    limit?: number
  }

  /**
   * RegressionBaseline without action
   */
  export type RegressionBaselineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
  }


  /**
   * Model Feedback
   */

  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    assignedTo: number | null
    respondedBy: number | null
    sentimentScore: number | null
    upvotes: number | null
  }

  export type FeedbackSumAggregateOutputType = {
    id: number | null
    userId: number | null
    assignedTo: number | null
    respondedBy: number | null
    sentimentScore: number | null
    upvotes: number | null
  }

  export type FeedbackMinAggregateOutputType = {
    id: number | null
    userId: number | null
    type: $Enums.FeedbackType | null
    category: $Enums.FeedbackCategory | null
    priority: $Enums.FeedbackPriority | null
    subject: string | null
    message: string | null
    url: string | null
    userAgent: string | null
    status: $Enums.FeedbackStatus | null
    assignedTo: number | null
    response: string | null
    respondedAt: Date | null
    respondedBy: number | null
    sentiment: string | null
    sentimentScore: number | null
    upvotes: number | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    resolvedAt: Date | null
  }

  export type FeedbackMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    type: $Enums.FeedbackType | null
    category: $Enums.FeedbackCategory | null
    priority: $Enums.FeedbackPriority | null
    subject: string | null
    message: string | null
    url: string | null
    userAgent: string | null
    status: $Enums.FeedbackStatus | null
    assignedTo: number | null
    response: string | null
    respondedAt: Date | null
    respondedBy: number | null
    sentiment: string | null
    sentimentScore: number | null
    upvotes: number | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    resolvedAt: Date | null
  }

  export type FeedbackCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    category: number
    priority: number
    subject: number
    message: number
    url: number
    userAgent: number
    metadata: number
    attachmentUrls: number
    status: number
    assignedTo: number
    response: number
    respondedAt: number
    respondedBy: number
    sentiment: number
    sentimentScore: number
    upvotes: number
    isPublic: number
    createdAt: number
    updatedAt: number
    resolvedAt: number
    _all: number
  }


  export type FeedbackAvgAggregateInputType = {
    id?: true
    userId?: true
    assignedTo?: true
    respondedBy?: true
    sentimentScore?: true
    upvotes?: true
  }

  export type FeedbackSumAggregateInputType = {
    id?: true
    userId?: true
    assignedTo?: true
    respondedBy?: true
    sentimentScore?: true
    upvotes?: true
  }

  export type FeedbackMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    category?: true
    priority?: true
    subject?: true
    message?: true
    url?: true
    userAgent?: true
    status?: true
    assignedTo?: true
    response?: true
    respondedAt?: true
    respondedBy?: true
    sentiment?: true
    sentimentScore?: true
    upvotes?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
  }

  export type FeedbackMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    category?: true
    priority?: true
    subject?: true
    message?: true
    url?: true
    userAgent?: true
    status?: true
    assignedTo?: true
    response?: true
    respondedAt?: true
    respondedBy?: true
    sentiment?: true
    sentimentScore?: true
    upvotes?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
  }

  export type FeedbackCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    category?: true
    priority?: true
    subject?: true
    message?: true
    url?: true
    userAgent?: true
    metadata?: true
    attachmentUrls?: true
    status?: true
    assignedTo?: true
    response?: true
    respondedAt?: true
    respondedBy?: true
    sentiment?: true
    sentimentScore?: true
    upvotes?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedback to aggregate.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type FeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithAggregationInput | FeedbackOrderByWithAggregationInput[]
    by: FeedbackScalarFieldEnum[] | FeedbackScalarFieldEnum
    having?: FeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _avg?: FeedbackAvgAggregateInputType
    _sum?: FeedbackSumAggregateInputType
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }

  export type FeedbackGroupByOutputType = {
    id: number
    userId: number
    type: $Enums.FeedbackType
    category: $Enums.FeedbackCategory
    priority: $Enums.FeedbackPriority
    subject: string
    message: string
    url: string | null
    userAgent: string | null
    metadata: JsonValue | null
    attachmentUrls: string[]
    status: $Enums.FeedbackStatus
    assignedTo: number | null
    response: string | null
    respondedAt: Date | null
    respondedBy: number | null
    sentiment: string | null
    sentimentScore: number | null
    upvotes: number
    isPublic: boolean
    createdAt: Date
    updatedAt: Date
    resolvedAt: Date | null
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    category?: boolean
    priority?: boolean
    subject?: boolean
    message?: boolean
    url?: boolean
    userAgent?: boolean
    metadata?: boolean
    attachmentUrls?: boolean
    status?: boolean
    assignedTo?: boolean
    response?: boolean
    respondedAt?: boolean
    respondedBy?: boolean
    sentiment?: boolean
    sentimentScore?: boolean
    upvotes?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    category?: boolean
    priority?: boolean
    subject?: boolean
    message?: boolean
    url?: boolean
    userAgent?: boolean
    metadata?: boolean
    attachmentUrls?: boolean
    status?: boolean
    assignedTo?: boolean
    response?: boolean
    respondedAt?: boolean
    respondedBy?: boolean
    sentiment?: boolean
    sentimentScore?: boolean
    upvotes?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    category?: boolean
    priority?: boolean
    subject?: boolean
    message?: boolean
    url?: boolean
    userAgent?: boolean
    metadata?: boolean
    attachmentUrls?: boolean
    status?: boolean
    assignedTo?: boolean
    response?: boolean
    respondedAt?: boolean
    respondedBy?: boolean
    sentiment?: boolean
    sentimentScore?: boolean
    upvotes?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    category?: boolean
    priority?: boolean
    subject?: boolean
    message?: boolean
    url?: boolean
    userAgent?: boolean
    metadata?: boolean
    attachmentUrls?: boolean
    status?: boolean
    assignedTo?: boolean
    response?: boolean
    respondedAt?: boolean
    respondedBy?: boolean
    sentiment?: boolean
    sentimentScore?: boolean
    upvotes?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
  }

  export type FeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "category" | "priority" | "subject" | "message" | "url" | "userAgent" | "metadata" | "attachmentUrls" | "status" | "assignedTo" | "response" | "respondedAt" | "respondedBy" | "sentiment" | "sentimentScore" | "upvotes" | "isPublic" | "createdAt" | "updatedAt" | "resolvedAt", ExtArgs["result"]["feedback"]>
  export type FeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeedbackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feedback"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      type: $Enums.FeedbackType
      category: $Enums.FeedbackCategory
      priority: $Enums.FeedbackPriority
      subject: string
      message: string
      url: string | null
      userAgent: string | null
      metadata: Prisma.JsonValue | null
      attachmentUrls: string[]
      status: $Enums.FeedbackStatus
      assignedTo: number | null
      response: string | null
      respondedAt: Date | null
      respondedBy: number | null
      sentiment: string | null
      sentimentScore: number | null
      upvotes: number
      isPublic: boolean
      createdAt: Date
      updatedAt: Date
      resolvedAt: Date | null
    }, ExtArgs["result"]["feedback"]>
    composites: {}
  }

  type FeedbackGetPayload<S extends boolean | null | undefined | FeedbackDefaultArgs> = $Result.GetResult<Prisma.$FeedbackPayload, S>

  type FeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface FeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feedback'], meta: { name: 'Feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {FeedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedbackFindUniqueArgs>(args: SelectSubset<T, FeedbackFindUniqueArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedbackFindFirstArgs>(args?: SelectSubset<T, FeedbackFindFirstArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackWithIdOnly = await prisma.feedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedbackFindManyArgs>(args?: SelectSubset<T, FeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feedback.
     * @param {FeedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
     */
    create<T extends FeedbackCreateArgs>(args: SelectSubset<T, FeedbackCreateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Feedbacks.
     * @param {FeedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedbackCreateManyArgs>(args?: SelectSubset<T, FeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feedbacks and returns the data saved in the database.
     * @param {FeedbackCreateManyAndReturnArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feedbacks and only return the `id`
     * const feedbackWithIdOnly = await prisma.feedback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Feedback.
     * @param {FeedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
     */
    delete<T extends FeedbackDeleteArgs>(args: SelectSubset<T, FeedbackDeleteArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feedback.
     * @param {FeedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedbackUpdateArgs>(args: SelectSubset<T, FeedbackUpdateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedbackDeleteManyArgs>(args?: SelectSubset<T, FeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedbackUpdateManyArgs>(args: SelectSubset<T, FeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks and returns the data updated in the database.
     * @param {FeedbackUpdateManyAndReturnArgs} args - Arguments to update many Feedbacks.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Feedbacks and only return the `id`
     * const feedbackWithIdOnly = await prisma.feedback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeedbackUpdateManyAndReturnArgs>(args: SelectSubset<T, FeedbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Feedback.
     * @param {FeedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
     */
    upsert<T extends FeedbackUpsertArgs>(args: SelectSubset<T, FeedbackUpsertArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbackCountArgs>(
      args?: Subset<T, FeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feedback model
   */
  readonly fields: FeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feedback model
   */
  interface FeedbackFieldRefs {
    readonly id: FieldRef<"Feedback", 'Int'>
    readonly userId: FieldRef<"Feedback", 'Int'>
    readonly type: FieldRef<"Feedback", 'FeedbackType'>
    readonly category: FieldRef<"Feedback", 'FeedbackCategory'>
    readonly priority: FieldRef<"Feedback", 'FeedbackPriority'>
    readonly subject: FieldRef<"Feedback", 'String'>
    readonly message: FieldRef<"Feedback", 'String'>
    readonly url: FieldRef<"Feedback", 'String'>
    readonly userAgent: FieldRef<"Feedback", 'String'>
    readonly metadata: FieldRef<"Feedback", 'Json'>
    readonly attachmentUrls: FieldRef<"Feedback", 'String[]'>
    readonly status: FieldRef<"Feedback", 'FeedbackStatus'>
    readonly assignedTo: FieldRef<"Feedback", 'Int'>
    readonly response: FieldRef<"Feedback", 'String'>
    readonly respondedAt: FieldRef<"Feedback", 'DateTime'>
    readonly respondedBy: FieldRef<"Feedback", 'Int'>
    readonly sentiment: FieldRef<"Feedback", 'String'>
    readonly sentimentScore: FieldRef<"Feedback", 'Float'>
    readonly upvotes: FieldRef<"Feedback", 'Int'>
    readonly isPublic: FieldRef<"Feedback", 'Boolean'>
    readonly createdAt: FieldRef<"Feedback", 'DateTime'>
    readonly updatedAt: FieldRef<"Feedback", 'DateTime'>
    readonly resolvedAt: FieldRef<"Feedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Feedback findUnique
   */
  export type FeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findUniqueOrThrow
   */
  export type FeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findFirst
   */
  export type FeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findFirstOrThrow
   */
  export type FeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findMany
   */
  export type FeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedbacks to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback create
   */
  export type FeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a Feedback.
     */
    data: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
  }

  /**
   * Feedback createMany
   */
  export type FeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feedback createManyAndReturn
   */
  export type FeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feedback update
   */
  export type FeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a Feedback.
     */
    data: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
    /**
     * Choose, which Feedback to update.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback updateMany
   */
  export type FeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to update.
     */
    limit?: number
  }

  /**
   * Feedback updateManyAndReturn
   */
  export type FeedbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feedback upsert
   */
  export type FeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the Feedback to update in case it exists.
     */
    where: FeedbackWhereUniqueInput
    /**
     * In case the Feedback found by the `where` argument doesn't exist, create a new Feedback with this data.
     */
    create: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
    /**
     * In case the Feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
  }

  /**
   * Feedback delete
   */
  export type FeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter which Feedback to delete.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback deleteMany
   */
  export type FeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedbacks to delete
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to delete.
     */
    limit?: number
  }

  /**
   * Feedback without action
   */
  export type FeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
  }


  /**
   * Model IpWhitelist
   */

  export type AggregateIpWhitelist = {
    _count: IpWhitelistCountAggregateOutputType | null
    _avg: IpWhitelistAvgAggregateOutputType | null
    _sum: IpWhitelistSumAggregateOutputType | null
    _min: IpWhitelistMinAggregateOutputType | null
    _max: IpWhitelistMaxAggregateOutputType | null
  }

  export type IpWhitelistAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    orgId: number | null
    createdBy: number | null
  }

  export type IpWhitelistSumAggregateOutputType = {
    id: number | null
    userId: number | null
    orgId: number | null
    createdBy: number | null
  }

  export type IpWhitelistMinAggregateOutputType = {
    id: number | null
    userId: number | null
    orgId: number | null
    ipAddress: string | null
    description: string | null
    isActive: boolean | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUsedAt: Date | null
  }

  export type IpWhitelistMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    orgId: number | null
    ipAddress: string | null
    description: string | null
    isActive: boolean | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUsedAt: Date | null
  }

  export type IpWhitelistCountAggregateOutputType = {
    id: number
    userId: number
    orgId: number
    ipAddress: number
    description: number
    isActive: number
    createdBy: number
    createdAt: number
    updatedAt: number
    lastUsedAt: number
    _all: number
  }


  export type IpWhitelistAvgAggregateInputType = {
    id?: true
    userId?: true
    orgId?: true
    createdBy?: true
  }

  export type IpWhitelistSumAggregateInputType = {
    id?: true
    userId?: true
    orgId?: true
    createdBy?: true
  }

  export type IpWhitelistMinAggregateInputType = {
    id?: true
    userId?: true
    orgId?: true
    ipAddress?: true
    description?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    lastUsedAt?: true
  }

  export type IpWhitelistMaxAggregateInputType = {
    id?: true
    userId?: true
    orgId?: true
    ipAddress?: true
    description?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    lastUsedAt?: true
  }

  export type IpWhitelistCountAggregateInputType = {
    id?: true
    userId?: true
    orgId?: true
    ipAddress?: true
    description?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    lastUsedAt?: true
    _all?: true
  }

  export type IpWhitelistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IpWhitelist to aggregate.
     */
    where?: IpWhitelistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IpWhitelists to fetch.
     */
    orderBy?: IpWhitelistOrderByWithRelationInput | IpWhitelistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IpWhitelistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IpWhitelists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IpWhitelists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IpWhitelists
    **/
    _count?: true | IpWhitelistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IpWhitelistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IpWhitelistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IpWhitelistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IpWhitelistMaxAggregateInputType
  }

  export type GetIpWhitelistAggregateType<T extends IpWhitelistAggregateArgs> = {
        [P in keyof T & keyof AggregateIpWhitelist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIpWhitelist[P]>
      : GetScalarType<T[P], AggregateIpWhitelist[P]>
  }




  export type IpWhitelistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IpWhitelistWhereInput
    orderBy?: IpWhitelistOrderByWithAggregationInput | IpWhitelistOrderByWithAggregationInput[]
    by: IpWhitelistScalarFieldEnum[] | IpWhitelistScalarFieldEnum
    having?: IpWhitelistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IpWhitelistCountAggregateInputType | true
    _avg?: IpWhitelistAvgAggregateInputType
    _sum?: IpWhitelistSumAggregateInputType
    _min?: IpWhitelistMinAggregateInputType
    _max?: IpWhitelistMaxAggregateInputType
  }

  export type IpWhitelistGroupByOutputType = {
    id: number
    userId: number | null
    orgId: number | null
    ipAddress: string
    description: string | null
    isActive: boolean
    createdBy: number
    createdAt: Date
    updatedAt: Date
    lastUsedAt: Date | null
    _count: IpWhitelistCountAggregateOutputType | null
    _avg: IpWhitelistAvgAggregateOutputType | null
    _sum: IpWhitelistSumAggregateOutputType | null
    _min: IpWhitelistMinAggregateOutputType | null
    _max: IpWhitelistMaxAggregateOutputType | null
  }

  type GetIpWhitelistGroupByPayload<T extends IpWhitelistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IpWhitelistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IpWhitelistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IpWhitelistGroupByOutputType[P]>
            : GetScalarType<T[P], IpWhitelistGroupByOutputType[P]>
        }
      >
    >


  export type IpWhitelistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orgId?: boolean
    ipAddress?: boolean
    description?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
  }, ExtArgs["result"]["ipWhitelist"]>

  export type IpWhitelistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orgId?: boolean
    ipAddress?: boolean
    description?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
  }, ExtArgs["result"]["ipWhitelist"]>

  export type IpWhitelistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orgId?: boolean
    ipAddress?: boolean
    description?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
  }, ExtArgs["result"]["ipWhitelist"]>

  export type IpWhitelistSelectScalar = {
    id?: boolean
    userId?: boolean
    orgId?: boolean
    ipAddress?: boolean
    description?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
  }

  export type IpWhitelistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "orgId" | "ipAddress" | "description" | "isActive" | "createdBy" | "createdAt" | "updatedAt" | "lastUsedAt", ExtArgs["result"]["ipWhitelist"]>

  export type $IpWhitelistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IpWhitelist"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      orgId: number | null
      ipAddress: string
      description: string | null
      isActive: boolean
      createdBy: number
      createdAt: Date
      updatedAt: Date
      lastUsedAt: Date | null
    }, ExtArgs["result"]["ipWhitelist"]>
    composites: {}
  }

  type IpWhitelistGetPayload<S extends boolean | null | undefined | IpWhitelistDefaultArgs> = $Result.GetResult<Prisma.$IpWhitelistPayload, S>

  type IpWhitelistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IpWhitelistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IpWhitelistCountAggregateInputType | true
    }

  export interface IpWhitelistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IpWhitelist'], meta: { name: 'IpWhitelist' } }
    /**
     * Find zero or one IpWhitelist that matches the filter.
     * @param {IpWhitelistFindUniqueArgs} args - Arguments to find a IpWhitelist
     * @example
     * // Get one IpWhitelist
     * const ipWhitelist = await prisma.ipWhitelist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IpWhitelistFindUniqueArgs>(args: SelectSubset<T, IpWhitelistFindUniqueArgs<ExtArgs>>): Prisma__IpWhitelistClient<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IpWhitelist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IpWhitelistFindUniqueOrThrowArgs} args - Arguments to find a IpWhitelist
     * @example
     * // Get one IpWhitelist
     * const ipWhitelist = await prisma.ipWhitelist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IpWhitelistFindUniqueOrThrowArgs>(args: SelectSubset<T, IpWhitelistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IpWhitelistClient<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IpWhitelist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpWhitelistFindFirstArgs} args - Arguments to find a IpWhitelist
     * @example
     * // Get one IpWhitelist
     * const ipWhitelist = await prisma.ipWhitelist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IpWhitelistFindFirstArgs>(args?: SelectSubset<T, IpWhitelistFindFirstArgs<ExtArgs>>): Prisma__IpWhitelistClient<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IpWhitelist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpWhitelistFindFirstOrThrowArgs} args - Arguments to find a IpWhitelist
     * @example
     * // Get one IpWhitelist
     * const ipWhitelist = await prisma.ipWhitelist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IpWhitelistFindFirstOrThrowArgs>(args?: SelectSubset<T, IpWhitelistFindFirstOrThrowArgs<ExtArgs>>): Prisma__IpWhitelistClient<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IpWhitelists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpWhitelistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IpWhitelists
     * const ipWhitelists = await prisma.ipWhitelist.findMany()
     * 
     * // Get first 10 IpWhitelists
     * const ipWhitelists = await prisma.ipWhitelist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ipWhitelistWithIdOnly = await prisma.ipWhitelist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IpWhitelistFindManyArgs>(args?: SelectSubset<T, IpWhitelistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IpWhitelist.
     * @param {IpWhitelistCreateArgs} args - Arguments to create a IpWhitelist.
     * @example
     * // Create one IpWhitelist
     * const IpWhitelist = await prisma.ipWhitelist.create({
     *   data: {
     *     // ... data to create a IpWhitelist
     *   }
     * })
     * 
     */
    create<T extends IpWhitelistCreateArgs>(args: SelectSubset<T, IpWhitelistCreateArgs<ExtArgs>>): Prisma__IpWhitelistClient<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IpWhitelists.
     * @param {IpWhitelistCreateManyArgs} args - Arguments to create many IpWhitelists.
     * @example
     * // Create many IpWhitelists
     * const ipWhitelist = await prisma.ipWhitelist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IpWhitelistCreateManyArgs>(args?: SelectSubset<T, IpWhitelistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IpWhitelists and returns the data saved in the database.
     * @param {IpWhitelistCreateManyAndReturnArgs} args - Arguments to create many IpWhitelists.
     * @example
     * // Create many IpWhitelists
     * const ipWhitelist = await prisma.ipWhitelist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IpWhitelists and only return the `id`
     * const ipWhitelistWithIdOnly = await prisma.ipWhitelist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IpWhitelistCreateManyAndReturnArgs>(args?: SelectSubset<T, IpWhitelistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IpWhitelist.
     * @param {IpWhitelistDeleteArgs} args - Arguments to delete one IpWhitelist.
     * @example
     * // Delete one IpWhitelist
     * const IpWhitelist = await prisma.ipWhitelist.delete({
     *   where: {
     *     // ... filter to delete one IpWhitelist
     *   }
     * })
     * 
     */
    delete<T extends IpWhitelistDeleteArgs>(args: SelectSubset<T, IpWhitelistDeleteArgs<ExtArgs>>): Prisma__IpWhitelistClient<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IpWhitelist.
     * @param {IpWhitelistUpdateArgs} args - Arguments to update one IpWhitelist.
     * @example
     * // Update one IpWhitelist
     * const ipWhitelist = await prisma.ipWhitelist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IpWhitelistUpdateArgs>(args: SelectSubset<T, IpWhitelistUpdateArgs<ExtArgs>>): Prisma__IpWhitelistClient<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IpWhitelists.
     * @param {IpWhitelistDeleteManyArgs} args - Arguments to filter IpWhitelists to delete.
     * @example
     * // Delete a few IpWhitelists
     * const { count } = await prisma.ipWhitelist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IpWhitelistDeleteManyArgs>(args?: SelectSubset<T, IpWhitelistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IpWhitelists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpWhitelistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IpWhitelists
     * const ipWhitelist = await prisma.ipWhitelist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IpWhitelistUpdateManyArgs>(args: SelectSubset<T, IpWhitelistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IpWhitelists and returns the data updated in the database.
     * @param {IpWhitelistUpdateManyAndReturnArgs} args - Arguments to update many IpWhitelists.
     * @example
     * // Update many IpWhitelists
     * const ipWhitelist = await prisma.ipWhitelist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IpWhitelists and only return the `id`
     * const ipWhitelistWithIdOnly = await prisma.ipWhitelist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IpWhitelistUpdateManyAndReturnArgs>(args: SelectSubset<T, IpWhitelistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IpWhitelist.
     * @param {IpWhitelistUpsertArgs} args - Arguments to update or create a IpWhitelist.
     * @example
     * // Update or create a IpWhitelist
     * const ipWhitelist = await prisma.ipWhitelist.upsert({
     *   create: {
     *     // ... data to create a IpWhitelist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IpWhitelist we want to update
     *   }
     * })
     */
    upsert<T extends IpWhitelistUpsertArgs>(args: SelectSubset<T, IpWhitelistUpsertArgs<ExtArgs>>): Prisma__IpWhitelistClient<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IpWhitelists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpWhitelistCountArgs} args - Arguments to filter IpWhitelists to count.
     * @example
     * // Count the number of IpWhitelists
     * const count = await prisma.ipWhitelist.count({
     *   where: {
     *     // ... the filter for the IpWhitelists we want to count
     *   }
     * })
    **/
    count<T extends IpWhitelistCountArgs>(
      args?: Subset<T, IpWhitelistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IpWhitelistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IpWhitelist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpWhitelistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IpWhitelistAggregateArgs>(args: Subset<T, IpWhitelistAggregateArgs>): Prisma.PrismaPromise<GetIpWhitelistAggregateType<T>>

    /**
     * Group by IpWhitelist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpWhitelistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IpWhitelistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IpWhitelistGroupByArgs['orderBy'] }
        : { orderBy?: IpWhitelistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IpWhitelistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIpWhitelistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IpWhitelist model
   */
  readonly fields: IpWhitelistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IpWhitelist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IpWhitelistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IpWhitelist model
   */
  interface IpWhitelistFieldRefs {
    readonly id: FieldRef<"IpWhitelist", 'Int'>
    readonly userId: FieldRef<"IpWhitelist", 'Int'>
    readonly orgId: FieldRef<"IpWhitelist", 'Int'>
    readonly ipAddress: FieldRef<"IpWhitelist", 'String'>
    readonly description: FieldRef<"IpWhitelist", 'String'>
    readonly isActive: FieldRef<"IpWhitelist", 'Boolean'>
    readonly createdBy: FieldRef<"IpWhitelist", 'Int'>
    readonly createdAt: FieldRef<"IpWhitelist", 'DateTime'>
    readonly updatedAt: FieldRef<"IpWhitelist", 'DateTime'>
    readonly lastUsedAt: FieldRef<"IpWhitelist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IpWhitelist findUnique
   */
  export type IpWhitelistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * Filter, which IpWhitelist to fetch.
     */
    where: IpWhitelistWhereUniqueInput
  }

  /**
   * IpWhitelist findUniqueOrThrow
   */
  export type IpWhitelistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * Filter, which IpWhitelist to fetch.
     */
    where: IpWhitelistWhereUniqueInput
  }

  /**
   * IpWhitelist findFirst
   */
  export type IpWhitelistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * Filter, which IpWhitelist to fetch.
     */
    where?: IpWhitelistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IpWhitelists to fetch.
     */
    orderBy?: IpWhitelistOrderByWithRelationInput | IpWhitelistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IpWhitelists.
     */
    cursor?: IpWhitelistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IpWhitelists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IpWhitelists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IpWhitelists.
     */
    distinct?: IpWhitelistScalarFieldEnum | IpWhitelistScalarFieldEnum[]
  }

  /**
   * IpWhitelist findFirstOrThrow
   */
  export type IpWhitelistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * Filter, which IpWhitelist to fetch.
     */
    where?: IpWhitelistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IpWhitelists to fetch.
     */
    orderBy?: IpWhitelistOrderByWithRelationInput | IpWhitelistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IpWhitelists.
     */
    cursor?: IpWhitelistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IpWhitelists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IpWhitelists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IpWhitelists.
     */
    distinct?: IpWhitelistScalarFieldEnum | IpWhitelistScalarFieldEnum[]
  }

  /**
   * IpWhitelist findMany
   */
  export type IpWhitelistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * Filter, which IpWhitelists to fetch.
     */
    where?: IpWhitelistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IpWhitelists to fetch.
     */
    orderBy?: IpWhitelistOrderByWithRelationInput | IpWhitelistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IpWhitelists.
     */
    cursor?: IpWhitelistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IpWhitelists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IpWhitelists.
     */
    skip?: number
    distinct?: IpWhitelistScalarFieldEnum | IpWhitelistScalarFieldEnum[]
  }

  /**
   * IpWhitelist create
   */
  export type IpWhitelistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * The data needed to create a IpWhitelist.
     */
    data: XOR<IpWhitelistCreateInput, IpWhitelistUncheckedCreateInput>
  }

  /**
   * IpWhitelist createMany
   */
  export type IpWhitelistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IpWhitelists.
     */
    data: IpWhitelistCreateManyInput | IpWhitelistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IpWhitelist createManyAndReturn
   */
  export type IpWhitelistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * The data used to create many IpWhitelists.
     */
    data: IpWhitelistCreateManyInput | IpWhitelistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IpWhitelist update
   */
  export type IpWhitelistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * The data needed to update a IpWhitelist.
     */
    data: XOR<IpWhitelistUpdateInput, IpWhitelistUncheckedUpdateInput>
    /**
     * Choose, which IpWhitelist to update.
     */
    where: IpWhitelistWhereUniqueInput
  }

  /**
   * IpWhitelist updateMany
   */
  export type IpWhitelistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IpWhitelists.
     */
    data: XOR<IpWhitelistUpdateManyMutationInput, IpWhitelistUncheckedUpdateManyInput>
    /**
     * Filter which IpWhitelists to update
     */
    where?: IpWhitelistWhereInput
    /**
     * Limit how many IpWhitelists to update.
     */
    limit?: number
  }

  /**
   * IpWhitelist updateManyAndReturn
   */
  export type IpWhitelistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * The data used to update IpWhitelists.
     */
    data: XOR<IpWhitelistUpdateManyMutationInput, IpWhitelistUncheckedUpdateManyInput>
    /**
     * Filter which IpWhitelists to update
     */
    where?: IpWhitelistWhereInput
    /**
     * Limit how many IpWhitelists to update.
     */
    limit?: number
  }

  /**
   * IpWhitelist upsert
   */
  export type IpWhitelistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * The filter to search for the IpWhitelist to update in case it exists.
     */
    where: IpWhitelistWhereUniqueInput
    /**
     * In case the IpWhitelist found by the `where` argument doesn't exist, create a new IpWhitelist with this data.
     */
    create: XOR<IpWhitelistCreateInput, IpWhitelistUncheckedCreateInput>
    /**
     * In case the IpWhitelist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IpWhitelistUpdateInput, IpWhitelistUncheckedUpdateInput>
  }

  /**
   * IpWhitelist delete
   */
  export type IpWhitelistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * Filter which IpWhitelist to delete.
     */
    where: IpWhitelistWhereUniqueInput
  }

  /**
   * IpWhitelist deleteMany
   */
  export type IpWhitelistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IpWhitelists to delete
     */
    where?: IpWhitelistWhereInput
    /**
     * Limit how many IpWhitelists to delete.
     */
    limit?: number
  }

  /**
   * IpWhitelist without action
   */
  export type IpWhitelistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
  }


  /**
   * Model SecurityEvent
   */

  export type AggregateSecurityEvent = {
    _count: SecurityEventCountAggregateOutputType | null
    _avg: SecurityEventAvgAggregateOutputType | null
    _sum: SecurityEventSumAggregateOutputType | null
    _min: SecurityEventMinAggregateOutputType | null
    _max: SecurityEventMaxAggregateOutputType | null
  }

  export type SecurityEventAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    resolvedBy: number | null
  }

  export type SecurityEventSumAggregateOutputType = {
    id: number | null
    userId: number | null
    resolvedBy: number | null
  }

  export type SecurityEventMinAggregateOutputType = {
    id: number | null
    userId: number | null
    eventType: $Enums.SecurityEventType | null
    severity: $Enums.SecuritySeverity | null
    ipAddress: string | null
    userAgent: string | null
    description: string | null
    resolved: boolean | null
    resolvedBy: number | null
    resolvedAt: Date | null
    createdAt: Date | null
  }

  export type SecurityEventMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    eventType: $Enums.SecurityEventType | null
    severity: $Enums.SecuritySeverity | null
    ipAddress: string | null
    userAgent: string | null
    description: string | null
    resolved: boolean | null
    resolvedBy: number | null
    resolvedAt: Date | null
    createdAt: Date | null
  }

  export type SecurityEventCountAggregateOutputType = {
    id: number
    userId: number
    eventType: number
    severity: number
    ipAddress: number
    userAgent: number
    description: number
    metadata: number
    resolved: number
    resolvedBy: number
    resolvedAt: number
    createdAt: number
    _all: number
  }


  export type SecurityEventAvgAggregateInputType = {
    id?: true
    userId?: true
    resolvedBy?: true
  }

  export type SecurityEventSumAggregateInputType = {
    id?: true
    userId?: true
    resolvedBy?: true
  }

  export type SecurityEventMinAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    severity?: true
    ipAddress?: true
    userAgent?: true
    description?: true
    resolved?: true
    resolvedBy?: true
    resolvedAt?: true
    createdAt?: true
  }

  export type SecurityEventMaxAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    severity?: true
    ipAddress?: true
    userAgent?: true
    description?: true
    resolved?: true
    resolvedBy?: true
    resolvedAt?: true
    createdAt?: true
  }

  export type SecurityEventCountAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    severity?: true
    ipAddress?: true
    userAgent?: true
    description?: true
    metadata?: true
    resolved?: true
    resolvedBy?: true
    resolvedAt?: true
    createdAt?: true
    _all?: true
  }

  export type SecurityEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityEvent to aggregate.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityEvents
    **/
    _count?: true | SecurityEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SecurityEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SecurityEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityEventMaxAggregateInputType
  }

  export type GetSecurityEventAggregateType<T extends SecurityEventAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityEvent[P]>
      : GetScalarType<T[P], AggregateSecurityEvent[P]>
  }




  export type SecurityEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityEventWhereInput
    orderBy?: SecurityEventOrderByWithAggregationInput | SecurityEventOrderByWithAggregationInput[]
    by: SecurityEventScalarFieldEnum[] | SecurityEventScalarFieldEnum
    having?: SecurityEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityEventCountAggregateInputType | true
    _avg?: SecurityEventAvgAggregateInputType
    _sum?: SecurityEventSumAggregateInputType
    _min?: SecurityEventMinAggregateInputType
    _max?: SecurityEventMaxAggregateInputType
  }

  export type SecurityEventGroupByOutputType = {
    id: number
    userId: number | null
    eventType: $Enums.SecurityEventType
    severity: $Enums.SecuritySeverity
    ipAddress: string | null
    userAgent: string | null
    description: string
    metadata: JsonValue | null
    resolved: boolean
    resolvedBy: number | null
    resolvedAt: Date | null
    createdAt: Date
    _count: SecurityEventCountAggregateOutputType | null
    _avg: SecurityEventAvgAggregateOutputType | null
    _sum: SecurityEventSumAggregateOutputType | null
    _min: SecurityEventMinAggregateOutputType | null
    _max: SecurityEventMaxAggregateOutputType | null
  }

  type GetSecurityEventGroupByPayload<T extends SecurityEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecurityEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityEventGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityEventGroupByOutputType[P]>
        }
      >
    >


  export type SecurityEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    severity?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    description?: boolean
    metadata?: boolean
    resolved?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["securityEvent"]>

  export type SecurityEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    severity?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    description?: boolean
    metadata?: boolean
    resolved?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["securityEvent"]>

  export type SecurityEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    severity?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    description?: boolean
    metadata?: boolean
    resolved?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["securityEvent"]>

  export type SecurityEventSelectScalar = {
    id?: boolean
    userId?: boolean
    eventType?: boolean
    severity?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    description?: boolean
    metadata?: boolean
    resolved?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
  }

  export type SecurityEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "eventType" | "severity" | "ipAddress" | "userAgent" | "description" | "metadata" | "resolved" | "resolvedBy" | "resolvedAt" | "createdAt", ExtArgs["result"]["securityEvent"]>

  export type $SecurityEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecurityEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      eventType: $Enums.SecurityEventType
      severity: $Enums.SecuritySeverity
      ipAddress: string | null
      userAgent: string | null
      description: string
      metadata: Prisma.JsonValue | null
      resolved: boolean
      resolvedBy: number | null
      resolvedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["securityEvent"]>
    composites: {}
  }

  type SecurityEventGetPayload<S extends boolean | null | undefined | SecurityEventDefaultArgs> = $Result.GetResult<Prisma.$SecurityEventPayload, S>

  type SecurityEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SecurityEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SecurityEventCountAggregateInputType | true
    }

  export interface SecurityEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecurityEvent'], meta: { name: 'SecurityEvent' } }
    /**
     * Find zero or one SecurityEvent that matches the filter.
     * @param {SecurityEventFindUniqueArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecurityEventFindUniqueArgs>(args: SelectSubset<T, SecurityEventFindUniqueArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SecurityEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SecurityEventFindUniqueOrThrowArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecurityEventFindUniqueOrThrowArgs>(args: SelectSubset<T, SecurityEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventFindFirstArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecurityEventFindFirstArgs>(args?: SelectSubset<T, SecurityEventFindFirstArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventFindFirstOrThrowArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecurityEventFindFirstOrThrowArgs>(args?: SelectSubset<T, SecurityEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SecurityEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityEvents
     * const securityEvents = await prisma.securityEvent.findMany()
     * 
     * // Get first 10 SecurityEvents
     * const securityEvents = await prisma.securityEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityEventWithIdOnly = await prisma.securityEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SecurityEventFindManyArgs>(args?: SelectSubset<T, SecurityEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SecurityEvent.
     * @param {SecurityEventCreateArgs} args - Arguments to create a SecurityEvent.
     * @example
     * // Create one SecurityEvent
     * const SecurityEvent = await prisma.securityEvent.create({
     *   data: {
     *     // ... data to create a SecurityEvent
     *   }
     * })
     * 
     */
    create<T extends SecurityEventCreateArgs>(args: SelectSubset<T, SecurityEventCreateArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SecurityEvents.
     * @param {SecurityEventCreateManyArgs} args - Arguments to create many SecurityEvents.
     * @example
     * // Create many SecurityEvents
     * const securityEvent = await prisma.securityEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SecurityEventCreateManyArgs>(args?: SelectSubset<T, SecurityEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SecurityEvents and returns the data saved in the database.
     * @param {SecurityEventCreateManyAndReturnArgs} args - Arguments to create many SecurityEvents.
     * @example
     * // Create many SecurityEvents
     * const securityEvent = await prisma.securityEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SecurityEvents and only return the `id`
     * const securityEventWithIdOnly = await prisma.securityEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SecurityEventCreateManyAndReturnArgs>(args?: SelectSubset<T, SecurityEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SecurityEvent.
     * @param {SecurityEventDeleteArgs} args - Arguments to delete one SecurityEvent.
     * @example
     * // Delete one SecurityEvent
     * const SecurityEvent = await prisma.securityEvent.delete({
     *   where: {
     *     // ... filter to delete one SecurityEvent
     *   }
     * })
     * 
     */
    delete<T extends SecurityEventDeleteArgs>(args: SelectSubset<T, SecurityEventDeleteArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SecurityEvent.
     * @param {SecurityEventUpdateArgs} args - Arguments to update one SecurityEvent.
     * @example
     * // Update one SecurityEvent
     * const securityEvent = await prisma.securityEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SecurityEventUpdateArgs>(args: SelectSubset<T, SecurityEventUpdateArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SecurityEvents.
     * @param {SecurityEventDeleteManyArgs} args - Arguments to filter SecurityEvents to delete.
     * @example
     * // Delete a few SecurityEvents
     * const { count } = await prisma.securityEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SecurityEventDeleteManyArgs>(args?: SelectSubset<T, SecurityEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityEvents
     * const securityEvent = await prisma.securityEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SecurityEventUpdateManyArgs>(args: SelectSubset<T, SecurityEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityEvents and returns the data updated in the database.
     * @param {SecurityEventUpdateManyAndReturnArgs} args - Arguments to update many SecurityEvents.
     * @example
     * // Update many SecurityEvents
     * const securityEvent = await prisma.securityEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SecurityEvents and only return the `id`
     * const securityEventWithIdOnly = await prisma.securityEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SecurityEventUpdateManyAndReturnArgs>(args: SelectSubset<T, SecurityEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SecurityEvent.
     * @param {SecurityEventUpsertArgs} args - Arguments to update or create a SecurityEvent.
     * @example
     * // Update or create a SecurityEvent
     * const securityEvent = await prisma.securityEvent.upsert({
     *   create: {
     *     // ... data to create a SecurityEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityEvent we want to update
     *   }
     * })
     */
    upsert<T extends SecurityEventUpsertArgs>(args: SelectSubset<T, SecurityEventUpsertArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SecurityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventCountArgs} args - Arguments to filter SecurityEvents to count.
     * @example
     * // Count the number of SecurityEvents
     * const count = await prisma.securityEvent.count({
     *   where: {
     *     // ... the filter for the SecurityEvents we want to count
     *   }
     * })
    **/
    count<T extends SecurityEventCountArgs>(
      args?: Subset<T, SecurityEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityEventAggregateArgs>(args: Subset<T, SecurityEventAggregateArgs>): Prisma.PrismaPromise<GetSecurityEventAggregateType<T>>

    /**
     * Group by SecurityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityEventGroupByArgs['orderBy'] }
        : { orderBy?: SecurityEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecurityEvent model
   */
  readonly fields: SecurityEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecurityEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SecurityEvent model
   */
  interface SecurityEventFieldRefs {
    readonly id: FieldRef<"SecurityEvent", 'Int'>
    readonly userId: FieldRef<"SecurityEvent", 'Int'>
    readonly eventType: FieldRef<"SecurityEvent", 'SecurityEventType'>
    readonly severity: FieldRef<"SecurityEvent", 'SecuritySeverity'>
    readonly ipAddress: FieldRef<"SecurityEvent", 'String'>
    readonly userAgent: FieldRef<"SecurityEvent", 'String'>
    readonly description: FieldRef<"SecurityEvent", 'String'>
    readonly metadata: FieldRef<"SecurityEvent", 'Json'>
    readonly resolved: FieldRef<"SecurityEvent", 'Boolean'>
    readonly resolvedBy: FieldRef<"SecurityEvent", 'Int'>
    readonly resolvedAt: FieldRef<"SecurityEvent", 'DateTime'>
    readonly createdAt: FieldRef<"SecurityEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SecurityEvent findUnique
   */
  export type SecurityEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent findUniqueOrThrow
   */
  export type SecurityEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent findFirst
   */
  export type SecurityEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityEvents.
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityEvents.
     */
    distinct?: SecurityEventScalarFieldEnum | SecurityEventScalarFieldEnum[]
  }

  /**
   * SecurityEvent findFirstOrThrow
   */
  export type SecurityEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityEvents.
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityEvents.
     */
    distinct?: SecurityEventScalarFieldEnum | SecurityEventScalarFieldEnum[]
  }

  /**
   * SecurityEvent findMany
   */
  export type SecurityEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Filter, which SecurityEvents to fetch.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityEvents.
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    distinct?: SecurityEventScalarFieldEnum | SecurityEventScalarFieldEnum[]
  }

  /**
   * SecurityEvent create
   */
  export type SecurityEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * The data needed to create a SecurityEvent.
     */
    data: XOR<SecurityEventCreateInput, SecurityEventUncheckedCreateInput>
  }

  /**
   * SecurityEvent createMany
   */
  export type SecurityEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecurityEvents.
     */
    data: SecurityEventCreateManyInput | SecurityEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityEvent createManyAndReturn
   */
  export type SecurityEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * The data used to create many SecurityEvents.
     */
    data: SecurityEventCreateManyInput | SecurityEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityEvent update
   */
  export type SecurityEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * The data needed to update a SecurityEvent.
     */
    data: XOR<SecurityEventUpdateInput, SecurityEventUncheckedUpdateInput>
    /**
     * Choose, which SecurityEvent to update.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent updateMany
   */
  export type SecurityEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecurityEvents.
     */
    data: XOR<SecurityEventUpdateManyMutationInput, SecurityEventUncheckedUpdateManyInput>
    /**
     * Filter which SecurityEvents to update
     */
    where?: SecurityEventWhereInput
    /**
     * Limit how many SecurityEvents to update.
     */
    limit?: number
  }

  /**
   * SecurityEvent updateManyAndReturn
   */
  export type SecurityEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * The data used to update SecurityEvents.
     */
    data: XOR<SecurityEventUpdateManyMutationInput, SecurityEventUncheckedUpdateManyInput>
    /**
     * Filter which SecurityEvents to update
     */
    where?: SecurityEventWhereInput
    /**
     * Limit how many SecurityEvents to update.
     */
    limit?: number
  }

  /**
   * SecurityEvent upsert
   */
  export type SecurityEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * The filter to search for the SecurityEvent to update in case it exists.
     */
    where: SecurityEventWhereUniqueInput
    /**
     * In case the SecurityEvent found by the `where` argument doesn't exist, create a new SecurityEvent with this data.
     */
    create: XOR<SecurityEventCreateInput, SecurityEventUncheckedCreateInput>
    /**
     * In case the SecurityEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecurityEventUpdateInput, SecurityEventUncheckedUpdateInput>
  }

  /**
   * SecurityEvent delete
   */
  export type SecurityEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Filter which SecurityEvent to delete.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent deleteMany
   */
  export type SecurityEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityEvents to delete
     */
    where?: SecurityEventWhereInput
    /**
     * Limit how many SecurityEvents to delete.
     */
    limit?: number
  }

  /**
   * SecurityEvent without action
   */
  export type SecurityEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
  }


  /**
   * Model TwoFactorBackup
   */

  export type AggregateTwoFactorBackup = {
    _count: TwoFactorBackupCountAggregateOutputType | null
    _avg: TwoFactorBackupAvgAggregateOutputType | null
    _sum: TwoFactorBackupSumAggregateOutputType | null
    _min: TwoFactorBackupMinAggregateOutputType | null
    _max: TwoFactorBackupMaxAggregateOutputType | null
  }

  export type TwoFactorBackupAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TwoFactorBackupSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TwoFactorBackupMinAggregateOutputType = {
    id: number | null
    userId: number | null
    code: string | null
    used: boolean | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type TwoFactorBackupMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    code: string | null
    used: boolean | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type TwoFactorBackupCountAggregateOutputType = {
    id: number
    userId: number
    code: number
    used: number
    usedAt: number
    createdAt: number
    _all: number
  }


  export type TwoFactorBackupAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TwoFactorBackupSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TwoFactorBackupMinAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    used?: true
    usedAt?: true
    createdAt?: true
  }

  export type TwoFactorBackupMaxAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    used?: true
    usedAt?: true
    createdAt?: true
  }

  export type TwoFactorBackupCountAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    used?: true
    usedAt?: true
    createdAt?: true
    _all?: true
  }

  export type TwoFactorBackupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactorBackup to aggregate.
     */
    where?: TwoFactorBackupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorBackups to fetch.
     */
    orderBy?: TwoFactorBackupOrderByWithRelationInput | TwoFactorBackupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwoFactorBackupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorBackups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorBackups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwoFactorBackups
    **/
    _count?: true | TwoFactorBackupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwoFactorBackupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwoFactorBackupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwoFactorBackupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwoFactorBackupMaxAggregateInputType
  }

  export type GetTwoFactorBackupAggregateType<T extends TwoFactorBackupAggregateArgs> = {
        [P in keyof T & keyof AggregateTwoFactorBackup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwoFactorBackup[P]>
      : GetScalarType<T[P], AggregateTwoFactorBackup[P]>
  }




  export type TwoFactorBackupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwoFactorBackupWhereInput
    orderBy?: TwoFactorBackupOrderByWithAggregationInput | TwoFactorBackupOrderByWithAggregationInput[]
    by: TwoFactorBackupScalarFieldEnum[] | TwoFactorBackupScalarFieldEnum
    having?: TwoFactorBackupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwoFactorBackupCountAggregateInputType | true
    _avg?: TwoFactorBackupAvgAggregateInputType
    _sum?: TwoFactorBackupSumAggregateInputType
    _min?: TwoFactorBackupMinAggregateInputType
    _max?: TwoFactorBackupMaxAggregateInputType
  }

  export type TwoFactorBackupGroupByOutputType = {
    id: number
    userId: number
    code: string
    used: boolean
    usedAt: Date | null
    createdAt: Date
    _count: TwoFactorBackupCountAggregateOutputType | null
    _avg: TwoFactorBackupAvgAggregateOutputType | null
    _sum: TwoFactorBackupSumAggregateOutputType | null
    _min: TwoFactorBackupMinAggregateOutputType | null
    _max: TwoFactorBackupMaxAggregateOutputType | null
  }

  type GetTwoFactorBackupGroupByPayload<T extends TwoFactorBackupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TwoFactorBackupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwoFactorBackupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwoFactorBackupGroupByOutputType[P]>
            : GetScalarType<T[P], TwoFactorBackupGroupByOutputType[P]>
        }
      >
    >


  export type TwoFactorBackupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    code?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["twoFactorBackup"]>

  export type TwoFactorBackupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    code?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["twoFactorBackup"]>

  export type TwoFactorBackupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    code?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["twoFactorBackup"]>

  export type TwoFactorBackupSelectScalar = {
    id?: boolean
    userId?: boolean
    code?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
  }

  export type TwoFactorBackupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "code" | "used" | "usedAt" | "createdAt", ExtArgs["result"]["twoFactorBackup"]>

  export type $TwoFactorBackupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TwoFactorBackup"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      code: string
      used: boolean
      usedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["twoFactorBackup"]>
    composites: {}
  }

  type TwoFactorBackupGetPayload<S extends boolean | null | undefined | TwoFactorBackupDefaultArgs> = $Result.GetResult<Prisma.$TwoFactorBackupPayload, S>

  type TwoFactorBackupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TwoFactorBackupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TwoFactorBackupCountAggregateInputType | true
    }

  export interface TwoFactorBackupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TwoFactorBackup'], meta: { name: 'TwoFactorBackup' } }
    /**
     * Find zero or one TwoFactorBackup that matches the filter.
     * @param {TwoFactorBackupFindUniqueArgs} args - Arguments to find a TwoFactorBackup
     * @example
     * // Get one TwoFactorBackup
     * const twoFactorBackup = await prisma.twoFactorBackup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TwoFactorBackupFindUniqueArgs>(args: SelectSubset<T, TwoFactorBackupFindUniqueArgs<ExtArgs>>): Prisma__TwoFactorBackupClient<$Result.GetResult<Prisma.$TwoFactorBackupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TwoFactorBackup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TwoFactorBackupFindUniqueOrThrowArgs} args - Arguments to find a TwoFactorBackup
     * @example
     * // Get one TwoFactorBackup
     * const twoFactorBackup = await prisma.twoFactorBackup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TwoFactorBackupFindUniqueOrThrowArgs>(args: SelectSubset<T, TwoFactorBackupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TwoFactorBackupClient<$Result.GetResult<Prisma.$TwoFactorBackupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TwoFactorBackup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorBackupFindFirstArgs} args - Arguments to find a TwoFactorBackup
     * @example
     * // Get one TwoFactorBackup
     * const twoFactorBackup = await prisma.twoFactorBackup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TwoFactorBackupFindFirstArgs>(args?: SelectSubset<T, TwoFactorBackupFindFirstArgs<ExtArgs>>): Prisma__TwoFactorBackupClient<$Result.GetResult<Prisma.$TwoFactorBackupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TwoFactorBackup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorBackupFindFirstOrThrowArgs} args - Arguments to find a TwoFactorBackup
     * @example
     * // Get one TwoFactorBackup
     * const twoFactorBackup = await prisma.twoFactorBackup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TwoFactorBackupFindFirstOrThrowArgs>(args?: SelectSubset<T, TwoFactorBackupFindFirstOrThrowArgs<ExtArgs>>): Prisma__TwoFactorBackupClient<$Result.GetResult<Prisma.$TwoFactorBackupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TwoFactorBackups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorBackupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwoFactorBackups
     * const twoFactorBackups = await prisma.twoFactorBackup.findMany()
     * 
     * // Get first 10 TwoFactorBackups
     * const twoFactorBackups = await prisma.twoFactorBackup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twoFactorBackupWithIdOnly = await prisma.twoFactorBackup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TwoFactorBackupFindManyArgs>(args?: SelectSubset<T, TwoFactorBackupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorBackupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TwoFactorBackup.
     * @param {TwoFactorBackupCreateArgs} args - Arguments to create a TwoFactorBackup.
     * @example
     * // Create one TwoFactorBackup
     * const TwoFactorBackup = await prisma.twoFactorBackup.create({
     *   data: {
     *     // ... data to create a TwoFactorBackup
     *   }
     * })
     * 
     */
    create<T extends TwoFactorBackupCreateArgs>(args: SelectSubset<T, TwoFactorBackupCreateArgs<ExtArgs>>): Prisma__TwoFactorBackupClient<$Result.GetResult<Prisma.$TwoFactorBackupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TwoFactorBackups.
     * @param {TwoFactorBackupCreateManyArgs} args - Arguments to create many TwoFactorBackups.
     * @example
     * // Create many TwoFactorBackups
     * const twoFactorBackup = await prisma.twoFactorBackup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TwoFactorBackupCreateManyArgs>(args?: SelectSubset<T, TwoFactorBackupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TwoFactorBackups and returns the data saved in the database.
     * @param {TwoFactorBackupCreateManyAndReturnArgs} args - Arguments to create many TwoFactorBackups.
     * @example
     * // Create many TwoFactorBackups
     * const twoFactorBackup = await prisma.twoFactorBackup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TwoFactorBackups and only return the `id`
     * const twoFactorBackupWithIdOnly = await prisma.twoFactorBackup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TwoFactorBackupCreateManyAndReturnArgs>(args?: SelectSubset<T, TwoFactorBackupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorBackupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TwoFactorBackup.
     * @param {TwoFactorBackupDeleteArgs} args - Arguments to delete one TwoFactorBackup.
     * @example
     * // Delete one TwoFactorBackup
     * const TwoFactorBackup = await prisma.twoFactorBackup.delete({
     *   where: {
     *     // ... filter to delete one TwoFactorBackup
     *   }
     * })
     * 
     */
    delete<T extends TwoFactorBackupDeleteArgs>(args: SelectSubset<T, TwoFactorBackupDeleteArgs<ExtArgs>>): Prisma__TwoFactorBackupClient<$Result.GetResult<Prisma.$TwoFactorBackupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TwoFactorBackup.
     * @param {TwoFactorBackupUpdateArgs} args - Arguments to update one TwoFactorBackup.
     * @example
     * // Update one TwoFactorBackup
     * const twoFactorBackup = await prisma.twoFactorBackup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TwoFactorBackupUpdateArgs>(args: SelectSubset<T, TwoFactorBackupUpdateArgs<ExtArgs>>): Prisma__TwoFactorBackupClient<$Result.GetResult<Prisma.$TwoFactorBackupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TwoFactorBackups.
     * @param {TwoFactorBackupDeleteManyArgs} args - Arguments to filter TwoFactorBackups to delete.
     * @example
     * // Delete a few TwoFactorBackups
     * const { count } = await prisma.twoFactorBackup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TwoFactorBackupDeleteManyArgs>(args?: SelectSubset<T, TwoFactorBackupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwoFactorBackups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorBackupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwoFactorBackups
     * const twoFactorBackup = await prisma.twoFactorBackup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TwoFactorBackupUpdateManyArgs>(args: SelectSubset<T, TwoFactorBackupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwoFactorBackups and returns the data updated in the database.
     * @param {TwoFactorBackupUpdateManyAndReturnArgs} args - Arguments to update many TwoFactorBackups.
     * @example
     * // Update many TwoFactorBackups
     * const twoFactorBackup = await prisma.twoFactorBackup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TwoFactorBackups and only return the `id`
     * const twoFactorBackupWithIdOnly = await prisma.twoFactorBackup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TwoFactorBackupUpdateManyAndReturnArgs>(args: SelectSubset<T, TwoFactorBackupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorBackupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TwoFactorBackup.
     * @param {TwoFactorBackupUpsertArgs} args - Arguments to update or create a TwoFactorBackup.
     * @example
     * // Update or create a TwoFactorBackup
     * const twoFactorBackup = await prisma.twoFactorBackup.upsert({
     *   create: {
     *     // ... data to create a TwoFactorBackup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwoFactorBackup we want to update
     *   }
     * })
     */
    upsert<T extends TwoFactorBackupUpsertArgs>(args: SelectSubset<T, TwoFactorBackupUpsertArgs<ExtArgs>>): Prisma__TwoFactorBackupClient<$Result.GetResult<Prisma.$TwoFactorBackupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TwoFactorBackups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorBackupCountArgs} args - Arguments to filter TwoFactorBackups to count.
     * @example
     * // Count the number of TwoFactorBackups
     * const count = await prisma.twoFactorBackup.count({
     *   where: {
     *     // ... the filter for the TwoFactorBackups we want to count
     *   }
     * })
    **/
    count<T extends TwoFactorBackupCountArgs>(
      args?: Subset<T, TwoFactorBackupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwoFactorBackupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwoFactorBackup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorBackupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwoFactorBackupAggregateArgs>(args: Subset<T, TwoFactorBackupAggregateArgs>): Prisma.PrismaPromise<GetTwoFactorBackupAggregateType<T>>

    /**
     * Group by TwoFactorBackup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorBackupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwoFactorBackupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwoFactorBackupGroupByArgs['orderBy'] }
        : { orderBy?: TwoFactorBackupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwoFactorBackupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwoFactorBackupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TwoFactorBackup model
   */
  readonly fields: TwoFactorBackupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TwoFactorBackup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TwoFactorBackupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TwoFactorBackup model
   */
  interface TwoFactorBackupFieldRefs {
    readonly id: FieldRef<"TwoFactorBackup", 'Int'>
    readonly userId: FieldRef<"TwoFactorBackup", 'Int'>
    readonly code: FieldRef<"TwoFactorBackup", 'String'>
    readonly used: FieldRef<"TwoFactorBackup", 'Boolean'>
    readonly usedAt: FieldRef<"TwoFactorBackup", 'DateTime'>
    readonly createdAt: FieldRef<"TwoFactorBackup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TwoFactorBackup findUnique
   */
  export type TwoFactorBackupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorBackup
     */
    select?: TwoFactorBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorBackup
     */
    omit?: TwoFactorBackupOmit<ExtArgs> | null
    /**
     * Filter, which TwoFactorBackup to fetch.
     */
    where: TwoFactorBackupWhereUniqueInput
  }

  /**
   * TwoFactorBackup findUniqueOrThrow
   */
  export type TwoFactorBackupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorBackup
     */
    select?: TwoFactorBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorBackup
     */
    omit?: TwoFactorBackupOmit<ExtArgs> | null
    /**
     * Filter, which TwoFactorBackup to fetch.
     */
    where: TwoFactorBackupWhereUniqueInput
  }

  /**
   * TwoFactorBackup findFirst
   */
  export type TwoFactorBackupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorBackup
     */
    select?: TwoFactorBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorBackup
     */
    omit?: TwoFactorBackupOmit<ExtArgs> | null
    /**
     * Filter, which TwoFactorBackup to fetch.
     */
    where?: TwoFactorBackupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorBackups to fetch.
     */
    orderBy?: TwoFactorBackupOrderByWithRelationInput | TwoFactorBackupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactorBackups.
     */
    cursor?: TwoFactorBackupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorBackups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorBackups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactorBackups.
     */
    distinct?: TwoFactorBackupScalarFieldEnum | TwoFactorBackupScalarFieldEnum[]
  }

  /**
   * TwoFactorBackup findFirstOrThrow
   */
  export type TwoFactorBackupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorBackup
     */
    select?: TwoFactorBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorBackup
     */
    omit?: TwoFactorBackupOmit<ExtArgs> | null
    /**
     * Filter, which TwoFactorBackup to fetch.
     */
    where?: TwoFactorBackupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorBackups to fetch.
     */
    orderBy?: TwoFactorBackupOrderByWithRelationInput | TwoFactorBackupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactorBackups.
     */
    cursor?: TwoFactorBackupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorBackups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorBackups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactorBackups.
     */
    distinct?: TwoFactorBackupScalarFieldEnum | TwoFactorBackupScalarFieldEnum[]
  }

  /**
   * TwoFactorBackup findMany
   */
  export type TwoFactorBackupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorBackup
     */
    select?: TwoFactorBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorBackup
     */
    omit?: TwoFactorBackupOmit<ExtArgs> | null
    /**
     * Filter, which TwoFactorBackups to fetch.
     */
    where?: TwoFactorBackupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorBackups to fetch.
     */
    orderBy?: TwoFactorBackupOrderByWithRelationInput | TwoFactorBackupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwoFactorBackups.
     */
    cursor?: TwoFactorBackupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorBackups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorBackups.
     */
    skip?: number
    distinct?: TwoFactorBackupScalarFieldEnum | TwoFactorBackupScalarFieldEnum[]
  }

  /**
   * TwoFactorBackup create
   */
  export type TwoFactorBackupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorBackup
     */
    select?: TwoFactorBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorBackup
     */
    omit?: TwoFactorBackupOmit<ExtArgs> | null
    /**
     * The data needed to create a TwoFactorBackup.
     */
    data: XOR<TwoFactorBackupCreateInput, TwoFactorBackupUncheckedCreateInput>
  }

  /**
   * TwoFactorBackup createMany
   */
  export type TwoFactorBackupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TwoFactorBackups.
     */
    data: TwoFactorBackupCreateManyInput | TwoFactorBackupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TwoFactorBackup createManyAndReturn
   */
  export type TwoFactorBackupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorBackup
     */
    select?: TwoFactorBackupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorBackup
     */
    omit?: TwoFactorBackupOmit<ExtArgs> | null
    /**
     * The data used to create many TwoFactorBackups.
     */
    data: TwoFactorBackupCreateManyInput | TwoFactorBackupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TwoFactorBackup update
   */
  export type TwoFactorBackupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorBackup
     */
    select?: TwoFactorBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorBackup
     */
    omit?: TwoFactorBackupOmit<ExtArgs> | null
    /**
     * The data needed to update a TwoFactorBackup.
     */
    data: XOR<TwoFactorBackupUpdateInput, TwoFactorBackupUncheckedUpdateInput>
    /**
     * Choose, which TwoFactorBackup to update.
     */
    where: TwoFactorBackupWhereUniqueInput
  }

  /**
   * TwoFactorBackup updateMany
   */
  export type TwoFactorBackupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TwoFactorBackups.
     */
    data: XOR<TwoFactorBackupUpdateManyMutationInput, TwoFactorBackupUncheckedUpdateManyInput>
    /**
     * Filter which TwoFactorBackups to update
     */
    where?: TwoFactorBackupWhereInput
    /**
     * Limit how many TwoFactorBackups to update.
     */
    limit?: number
  }

  /**
   * TwoFactorBackup updateManyAndReturn
   */
  export type TwoFactorBackupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorBackup
     */
    select?: TwoFactorBackupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorBackup
     */
    omit?: TwoFactorBackupOmit<ExtArgs> | null
    /**
     * The data used to update TwoFactorBackups.
     */
    data: XOR<TwoFactorBackupUpdateManyMutationInput, TwoFactorBackupUncheckedUpdateManyInput>
    /**
     * Filter which TwoFactorBackups to update
     */
    where?: TwoFactorBackupWhereInput
    /**
     * Limit how many TwoFactorBackups to update.
     */
    limit?: number
  }

  /**
   * TwoFactorBackup upsert
   */
  export type TwoFactorBackupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorBackup
     */
    select?: TwoFactorBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorBackup
     */
    omit?: TwoFactorBackupOmit<ExtArgs> | null
    /**
     * The filter to search for the TwoFactorBackup to update in case it exists.
     */
    where: TwoFactorBackupWhereUniqueInput
    /**
     * In case the TwoFactorBackup found by the `where` argument doesn't exist, create a new TwoFactorBackup with this data.
     */
    create: XOR<TwoFactorBackupCreateInput, TwoFactorBackupUncheckedCreateInput>
    /**
     * In case the TwoFactorBackup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwoFactorBackupUpdateInput, TwoFactorBackupUncheckedUpdateInput>
  }

  /**
   * TwoFactorBackup delete
   */
  export type TwoFactorBackupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorBackup
     */
    select?: TwoFactorBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorBackup
     */
    omit?: TwoFactorBackupOmit<ExtArgs> | null
    /**
     * Filter which TwoFactorBackup to delete.
     */
    where: TwoFactorBackupWhereUniqueInput
  }

  /**
   * TwoFactorBackup deleteMany
   */
  export type TwoFactorBackupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactorBackups to delete
     */
    where?: TwoFactorBackupWhereInput
    /**
     * Limit how many TwoFactorBackups to delete.
     */
    limit?: number
  }

  /**
   * TwoFactorBackup without action
   */
  export type TwoFactorBackupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorBackup
     */
    select?: TwoFactorBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorBackup
     */
    omit?: TwoFactorBackupOmit<ExtArgs> | null
  }


  /**
   * Model SSOConfiguration
   */

  export type AggregateSSOConfiguration = {
    _count: SSOConfigurationCountAggregateOutputType | null
    _avg: SSOConfigurationAvgAggregateOutputType | null
    _sum: SSOConfigurationSumAggregateOutputType | null
    _min: SSOConfigurationMinAggregateOutputType | null
    _max: SSOConfigurationMaxAggregateOutputType | null
  }

  export type SSOConfigurationAvgAggregateOutputType = {
    id: number | null
    orgId: number | null
    createdBy: number | null
  }

  export type SSOConfigurationSumAggregateOutputType = {
    id: number | null
    orgId: number | null
    createdBy: number | null
  }

  export type SSOConfigurationMinAggregateOutputType = {
    id: number | null
    orgId: number | null
    provider: $Enums.SSOProvider | null
    enabled: boolean | null
    samlEntryPoint: string | null
    samlIssuer: string | null
    samlCert: string | null
    samlCallbackUrl: string | null
    samlLogoutUrl: string | null
    oauthClientId: string | null
    oauthClientSecret: string | null
    oauthAuthUrl: string | null
    oauthTokenUrl: string | null
    oauthUserInfoUrl: string | null
    jitProvisioning: boolean | null
    defaultRole: $Enums.Role | null
    defaultTier: $Enums.UserTier | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUsedAt: Date | null
  }

  export type SSOConfigurationMaxAggregateOutputType = {
    id: number | null
    orgId: number | null
    provider: $Enums.SSOProvider | null
    enabled: boolean | null
    samlEntryPoint: string | null
    samlIssuer: string | null
    samlCert: string | null
    samlCallbackUrl: string | null
    samlLogoutUrl: string | null
    oauthClientId: string | null
    oauthClientSecret: string | null
    oauthAuthUrl: string | null
    oauthTokenUrl: string | null
    oauthUserInfoUrl: string | null
    jitProvisioning: boolean | null
    defaultRole: $Enums.Role | null
    defaultTier: $Enums.UserTier | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUsedAt: Date | null
  }

  export type SSOConfigurationCountAggregateOutputType = {
    id: number
    orgId: number
    provider: number
    enabled: number
    samlEntryPoint: number
    samlIssuer: number
    samlCert: number
    samlCallbackUrl: number
    samlLogoutUrl: number
    oauthClientId: number
    oauthClientSecret: number
    oauthAuthUrl: number
    oauthTokenUrl: number
    oauthUserInfoUrl: number
    oauthScopes: number
    domainRestriction: number
    jitProvisioning: number
    defaultRole: number
    defaultTier: number
    metadata: number
    createdBy: number
    createdAt: number
    updatedAt: number
    lastUsedAt: number
    _all: number
  }


  export type SSOConfigurationAvgAggregateInputType = {
    id?: true
    orgId?: true
    createdBy?: true
  }

  export type SSOConfigurationSumAggregateInputType = {
    id?: true
    orgId?: true
    createdBy?: true
  }

  export type SSOConfigurationMinAggregateInputType = {
    id?: true
    orgId?: true
    provider?: true
    enabled?: true
    samlEntryPoint?: true
    samlIssuer?: true
    samlCert?: true
    samlCallbackUrl?: true
    samlLogoutUrl?: true
    oauthClientId?: true
    oauthClientSecret?: true
    oauthAuthUrl?: true
    oauthTokenUrl?: true
    oauthUserInfoUrl?: true
    jitProvisioning?: true
    defaultRole?: true
    defaultTier?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    lastUsedAt?: true
  }

  export type SSOConfigurationMaxAggregateInputType = {
    id?: true
    orgId?: true
    provider?: true
    enabled?: true
    samlEntryPoint?: true
    samlIssuer?: true
    samlCert?: true
    samlCallbackUrl?: true
    samlLogoutUrl?: true
    oauthClientId?: true
    oauthClientSecret?: true
    oauthAuthUrl?: true
    oauthTokenUrl?: true
    oauthUserInfoUrl?: true
    jitProvisioning?: true
    defaultRole?: true
    defaultTier?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    lastUsedAt?: true
  }

  export type SSOConfigurationCountAggregateInputType = {
    id?: true
    orgId?: true
    provider?: true
    enabled?: true
    samlEntryPoint?: true
    samlIssuer?: true
    samlCert?: true
    samlCallbackUrl?: true
    samlLogoutUrl?: true
    oauthClientId?: true
    oauthClientSecret?: true
    oauthAuthUrl?: true
    oauthTokenUrl?: true
    oauthUserInfoUrl?: true
    oauthScopes?: true
    domainRestriction?: true
    jitProvisioning?: true
    defaultRole?: true
    defaultTier?: true
    metadata?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    lastUsedAt?: true
    _all?: true
  }

  export type SSOConfigurationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SSOConfiguration to aggregate.
     */
    where?: SSOConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SSOConfigurations to fetch.
     */
    orderBy?: SSOConfigurationOrderByWithRelationInput | SSOConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SSOConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SSOConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SSOConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SSOConfigurations
    **/
    _count?: true | SSOConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SSOConfigurationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SSOConfigurationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SSOConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SSOConfigurationMaxAggregateInputType
  }

  export type GetSSOConfigurationAggregateType<T extends SSOConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateSSOConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSSOConfiguration[P]>
      : GetScalarType<T[P], AggregateSSOConfiguration[P]>
  }




  export type SSOConfigurationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SSOConfigurationWhereInput
    orderBy?: SSOConfigurationOrderByWithAggregationInput | SSOConfigurationOrderByWithAggregationInput[]
    by: SSOConfigurationScalarFieldEnum[] | SSOConfigurationScalarFieldEnum
    having?: SSOConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SSOConfigurationCountAggregateInputType | true
    _avg?: SSOConfigurationAvgAggregateInputType
    _sum?: SSOConfigurationSumAggregateInputType
    _min?: SSOConfigurationMinAggregateInputType
    _max?: SSOConfigurationMaxAggregateInputType
  }

  export type SSOConfigurationGroupByOutputType = {
    id: number
    orgId: number
    provider: $Enums.SSOProvider
    enabled: boolean
    samlEntryPoint: string | null
    samlIssuer: string | null
    samlCert: string | null
    samlCallbackUrl: string | null
    samlLogoutUrl: string | null
    oauthClientId: string | null
    oauthClientSecret: string | null
    oauthAuthUrl: string | null
    oauthTokenUrl: string | null
    oauthUserInfoUrl: string | null
    oauthScopes: string[]
    domainRestriction: string[]
    jitProvisioning: boolean
    defaultRole: $Enums.Role
    defaultTier: $Enums.UserTier
    metadata: JsonValue | null
    createdBy: number
    createdAt: Date
    updatedAt: Date
    lastUsedAt: Date | null
    _count: SSOConfigurationCountAggregateOutputType | null
    _avg: SSOConfigurationAvgAggregateOutputType | null
    _sum: SSOConfigurationSumAggregateOutputType | null
    _min: SSOConfigurationMinAggregateOutputType | null
    _max: SSOConfigurationMaxAggregateOutputType | null
  }

  type GetSSOConfigurationGroupByPayload<T extends SSOConfigurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SSOConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SSOConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SSOConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], SSOConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type SSOConfigurationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    provider?: boolean
    enabled?: boolean
    samlEntryPoint?: boolean
    samlIssuer?: boolean
    samlCert?: boolean
    samlCallbackUrl?: boolean
    samlLogoutUrl?: boolean
    oauthClientId?: boolean
    oauthClientSecret?: boolean
    oauthAuthUrl?: boolean
    oauthTokenUrl?: boolean
    oauthUserInfoUrl?: boolean
    oauthScopes?: boolean
    domainRestriction?: boolean
    jitProvisioning?: boolean
    defaultRole?: boolean
    defaultTier?: boolean
    metadata?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sSOConfiguration"]>

  export type SSOConfigurationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    provider?: boolean
    enabled?: boolean
    samlEntryPoint?: boolean
    samlIssuer?: boolean
    samlCert?: boolean
    samlCallbackUrl?: boolean
    samlLogoutUrl?: boolean
    oauthClientId?: boolean
    oauthClientSecret?: boolean
    oauthAuthUrl?: boolean
    oauthTokenUrl?: boolean
    oauthUserInfoUrl?: boolean
    oauthScopes?: boolean
    domainRestriction?: boolean
    jitProvisioning?: boolean
    defaultRole?: boolean
    defaultTier?: boolean
    metadata?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sSOConfiguration"]>

  export type SSOConfigurationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    provider?: boolean
    enabled?: boolean
    samlEntryPoint?: boolean
    samlIssuer?: boolean
    samlCert?: boolean
    samlCallbackUrl?: boolean
    samlLogoutUrl?: boolean
    oauthClientId?: boolean
    oauthClientSecret?: boolean
    oauthAuthUrl?: boolean
    oauthTokenUrl?: boolean
    oauthUserInfoUrl?: boolean
    oauthScopes?: boolean
    domainRestriction?: boolean
    jitProvisioning?: boolean
    defaultRole?: boolean
    defaultTier?: boolean
    metadata?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sSOConfiguration"]>

  export type SSOConfigurationSelectScalar = {
    id?: boolean
    orgId?: boolean
    provider?: boolean
    enabled?: boolean
    samlEntryPoint?: boolean
    samlIssuer?: boolean
    samlCert?: boolean
    samlCallbackUrl?: boolean
    samlLogoutUrl?: boolean
    oauthClientId?: boolean
    oauthClientSecret?: boolean
    oauthAuthUrl?: boolean
    oauthTokenUrl?: boolean
    oauthUserInfoUrl?: boolean
    oauthScopes?: boolean
    domainRestriction?: boolean
    jitProvisioning?: boolean
    defaultRole?: boolean
    defaultTier?: boolean
    metadata?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
  }

  export type SSOConfigurationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "provider" | "enabled" | "samlEntryPoint" | "samlIssuer" | "samlCert" | "samlCallbackUrl" | "samlLogoutUrl" | "oauthClientId" | "oauthClientSecret" | "oauthAuthUrl" | "oauthTokenUrl" | "oauthUserInfoUrl" | "oauthScopes" | "domainRestriction" | "jitProvisioning" | "defaultRole" | "defaultTier" | "metadata" | "createdBy" | "createdAt" | "updatedAt" | "lastUsedAt", ExtArgs["result"]["sSOConfiguration"]>
  export type SSOConfigurationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type SSOConfigurationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type SSOConfigurationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $SSOConfigurationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SSOConfiguration"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orgId: number
      provider: $Enums.SSOProvider
      enabled: boolean
      samlEntryPoint: string | null
      samlIssuer: string | null
      samlCert: string | null
      samlCallbackUrl: string | null
      samlLogoutUrl: string | null
      oauthClientId: string | null
      oauthClientSecret: string | null
      oauthAuthUrl: string | null
      oauthTokenUrl: string | null
      oauthUserInfoUrl: string | null
      oauthScopes: string[]
      domainRestriction: string[]
      jitProvisioning: boolean
      defaultRole: $Enums.Role
      defaultTier: $Enums.UserTier
      metadata: Prisma.JsonValue | null
      createdBy: number
      createdAt: Date
      updatedAt: Date
      lastUsedAt: Date | null
    }, ExtArgs["result"]["sSOConfiguration"]>
    composites: {}
  }

  type SSOConfigurationGetPayload<S extends boolean | null | undefined | SSOConfigurationDefaultArgs> = $Result.GetResult<Prisma.$SSOConfigurationPayload, S>

  type SSOConfigurationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SSOConfigurationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SSOConfigurationCountAggregateInputType | true
    }

  export interface SSOConfigurationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SSOConfiguration'], meta: { name: 'SSOConfiguration' } }
    /**
     * Find zero or one SSOConfiguration that matches the filter.
     * @param {SSOConfigurationFindUniqueArgs} args - Arguments to find a SSOConfiguration
     * @example
     * // Get one SSOConfiguration
     * const sSOConfiguration = await prisma.sSOConfiguration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SSOConfigurationFindUniqueArgs>(args: SelectSubset<T, SSOConfigurationFindUniqueArgs<ExtArgs>>): Prisma__SSOConfigurationClient<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SSOConfiguration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SSOConfigurationFindUniqueOrThrowArgs} args - Arguments to find a SSOConfiguration
     * @example
     * // Get one SSOConfiguration
     * const sSOConfiguration = await prisma.sSOConfiguration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SSOConfigurationFindUniqueOrThrowArgs>(args: SelectSubset<T, SSOConfigurationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SSOConfigurationClient<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SSOConfiguration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOConfigurationFindFirstArgs} args - Arguments to find a SSOConfiguration
     * @example
     * // Get one SSOConfiguration
     * const sSOConfiguration = await prisma.sSOConfiguration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SSOConfigurationFindFirstArgs>(args?: SelectSubset<T, SSOConfigurationFindFirstArgs<ExtArgs>>): Prisma__SSOConfigurationClient<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SSOConfiguration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOConfigurationFindFirstOrThrowArgs} args - Arguments to find a SSOConfiguration
     * @example
     * // Get one SSOConfiguration
     * const sSOConfiguration = await prisma.sSOConfiguration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SSOConfigurationFindFirstOrThrowArgs>(args?: SelectSubset<T, SSOConfigurationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SSOConfigurationClient<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SSOConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOConfigurationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SSOConfigurations
     * const sSOConfigurations = await prisma.sSOConfiguration.findMany()
     * 
     * // Get first 10 SSOConfigurations
     * const sSOConfigurations = await prisma.sSOConfiguration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sSOConfigurationWithIdOnly = await prisma.sSOConfiguration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SSOConfigurationFindManyArgs>(args?: SelectSubset<T, SSOConfigurationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SSOConfiguration.
     * @param {SSOConfigurationCreateArgs} args - Arguments to create a SSOConfiguration.
     * @example
     * // Create one SSOConfiguration
     * const SSOConfiguration = await prisma.sSOConfiguration.create({
     *   data: {
     *     // ... data to create a SSOConfiguration
     *   }
     * })
     * 
     */
    create<T extends SSOConfigurationCreateArgs>(args: SelectSubset<T, SSOConfigurationCreateArgs<ExtArgs>>): Prisma__SSOConfigurationClient<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SSOConfigurations.
     * @param {SSOConfigurationCreateManyArgs} args - Arguments to create many SSOConfigurations.
     * @example
     * // Create many SSOConfigurations
     * const sSOConfiguration = await prisma.sSOConfiguration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SSOConfigurationCreateManyArgs>(args?: SelectSubset<T, SSOConfigurationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SSOConfigurations and returns the data saved in the database.
     * @param {SSOConfigurationCreateManyAndReturnArgs} args - Arguments to create many SSOConfigurations.
     * @example
     * // Create many SSOConfigurations
     * const sSOConfiguration = await prisma.sSOConfiguration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SSOConfigurations and only return the `id`
     * const sSOConfigurationWithIdOnly = await prisma.sSOConfiguration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SSOConfigurationCreateManyAndReturnArgs>(args?: SelectSubset<T, SSOConfigurationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SSOConfiguration.
     * @param {SSOConfigurationDeleteArgs} args - Arguments to delete one SSOConfiguration.
     * @example
     * // Delete one SSOConfiguration
     * const SSOConfiguration = await prisma.sSOConfiguration.delete({
     *   where: {
     *     // ... filter to delete one SSOConfiguration
     *   }
     * })
     * 
     */
    delete<T extends SSOConfigurationDeleteArgs>(args: SelectSubset<T, SSOConfigurationDeleteArgs<ExtArgs>>): Prisma__SSOConfigurationClient<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SSOConfiguration.
     * @param {SSOConfigurationUpdateArgs} args - Arguments to update one SSOConfiguration.
     * @example
     * // Update one SSOConfiguration
     * const sSOConfiguration = await prisma.sSOConfiguration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SSOConfigurationUpdateArgs>(args: SelectSubset<T, SSOConfigurationUpdateArgs<ExtArgs>>): Prisma__SSOConfigurationClient<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SSOConfigurations.
     * @param {SSOConfigurationDeleteManyArgs} args - Arguments to filter SSOConfigurations to delete.
     * @example
     * // Delete a few SSOConfigurations
     * const { count } = await prisma.sSOConfiguration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SSOConfigurationDeleteManyArgs>(args?: SelectSubset<T, SSOConfigurationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SSOConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SSOConfigurations
     * const sSOConfiguration = await prisma.sSOConfiguration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SSOConfigurationUpdateManyArgs>(args: SelectSubset<T, SSOConfigurationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SSOConfigurations and returns the data updated in the database.
     * @param {SSOConfigurationUpdateManyAndReturnArgs} args - Arguments to update many SSOConfigurations.
     * @example
     * // Update many SSOConfigurations
     * const sSOConfiguration = await prisma.sSOConfiguration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SSOConfigurations and only return the `id`
     * const sSOConfigurationWithIdOnly = await prisma.sSOConfiguration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SSOConfigurationUpdateManyAndReturnArgs>(args: SelectSubset<T, SSOConfigurationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SSOConfiguration.
     * @param {SSOConfigurationUpsertArgs} args - Arguments to update or create a SSOConfiguration.
     * @example
     * // Update or create a SSOConfiguration
     * const sSOConfiguration = await prisma.sSOConfiguration.upsert({
     *   create: {
     *     // ... data to create a SSOConfiguration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SSOConfiguration we want to update
     *   }
     * })
     */
    upsert<T extends SSOConfigurationUpsertArgs>(args: SelectSubset<T, SSOConfigurationUpsertArgs<ExtArgs>>): Prisma__SSOConfigurationClient<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SSOConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOConfigurationCountArgs} args - Arguments to filter SSOConfigurations to count.
     * @example
     * // Count the number of SSOConfigurations
     * const count = await prisma.sSOConfiguration.count({
     *   where: {
     *     // ... the filter for the SSOConfigurations we want to count
     *   }
     * })
    **/
    count<T extends SSOConfigurationCountArgs>(
      args?: Subset<T, SSOConfigurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SSOConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SSOConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SSOConfigurationAggregateArgs>(args: Subset<T, SSOConfigurationAggregateArgs>): Prisma.PrismaPromise<GetSSOConfigurationAggregateType<T>>

    /**
     * Group by SSOConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SSOConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SSOConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: SSOConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SSOConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSSOConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SSOConfiguration model
   */
  readonly fields: SSOConfigurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SSOConfiguration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SSOConfigurationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SSOConfiguration model
   */
  interface SSOConfigurationFieldRefs {
    readonly id: FieldRef<"SSOConfiguration", 'Int'>
    readonly orgId: FieldRef<"SSOConfiguration", 'Int'>
    readonly provider: FieldRef<"SSOConfiguration", 'SSOProvider'>
    readonly enabled: FieldRef<"SSOConfiguration", 'Boolean'>
    readonly samlEntryPoint: FieldRef<"SSOConfiguration", 'String'>
    readonly samlIssuer: FieldRef<"SSOConfiguration", 'String'>
    readonly samlCert: FieldRef<"SSOConfiguration", 'String'>
    readonly samlCallbackUrl: FieldRef<"SSOConfiguration", 'String'>
    readonly samlLogoutUrl: FieldRef<"SSOConfiguration", 'String'>
    readonly oauthClientId: FieldRef<"SSOConfiguration", 'String'>
    readonly oauthClientSecret: FieldRef<"SSOConfiguration", 'String'>
    readonly oauthAuthUrl: FieldRef<"SSOConfiguration", 'String'>
    readonly oauthTokenUrl: FieldRef<"SSOConfiguration", 'String'>
    readonly oauthUserInfoUrl: FieldRef<"SSOConfiguration", 'String'>
    readonly oauthScopes: FieldRef<"SSOConfiguration", 'String[]'>
    readonly domainRestriction: FieldRef<"SSOConfiguration", 'String[]'>
    readonly jitProvisioning: FieldRef<"SSOConfiguration", 'Boolean'>
    readonly defaultRole: FieldRef<"SSOConfiguration", 'Role'>
    readonly defaultTier: FieldRef<"SSOConfiguration", 'UserTier'>
    readonly metadata: FieldRef<"SSOConfiguration", 'Json'>
    readonly createdBy: FieldRef<"SSOConfiguration", 'Int'>
    readonly createdAt: FieldRef<"SSOConfiguration", 'DateTime'>
    readonly updatedAt: FieldRef<"SSOConfiguration", 'DateTime'>
    readonly lastUsedAt: FieldRef<"SSOConfiguration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SSOConfiguration findUnique
   */
  export type SSOConfigurationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which SSOConfiguration to fetch.
     */
    where: SSOConfigurationWhereUniqueInput
  }

  /**
   * SSOConfiguration findUniqueOrThrow
   */
  export type SSOConfigurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which SSOConfiguration to fetch.
     */
    where: SSOConfigurationWhereUniqueInput
  }

  /**
   * SSOConfiguration findFirst
   */
  export type SSOConfigurationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which SSOConfiguration to fetch.
     */
    where?: SSOConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SSOConfigurations to fetch.
     */
    orderBy?: SSOConfigurationOrderByWithRelationInput | SSOConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SSOConfigurations.
     */
    cursor?: SSOConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SSOConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SSOConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SSOConfigurations.
     */
    distinct?: SSOConfigurationScalarFieldEnum | SSOConfigurationScalarFieldEnum[]
  }

  /**
   * SSOConfiguration findFirstOrThrow
   */
  export type SSOConfigurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which SSOConfiguration to fetch.
     */
    where?: SSOConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SSOConfigurations to fetch.
     */
    orderBy?: SSOConfigurationOrderByWithRelationInput | SSOConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SSOConfigurations.
     */
    cursor?: SSOConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SSOConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SSOConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SSOConfigurations.
     */
    distinct?: SSOConfigurationScalarFieldEnum | SSOConfigurationScalarFieldEnum[]
  }

  /**
   * SSOConfiguration findMany
   */
  export type SSOConfigurationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which SSOConfigurations to fetch.
     */
    where?: SSOConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SSOConfigurations to fetch.
     */
    orderBy?: SSOConfigurationOrderByWithRelationInput | SSOConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SSOConfigurations.
     */
    cursor?: SSOConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SSOConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SSOConfigurations.
     */
    skip?: number
    distinct?: SSOConfigurationScalarFieldEnum | SSOConfigurationScalarFieldEnum[]
  }

  /**
   * SSOConfiguration create
   */
  export type SSOConfigurationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
    /**
     * The data needed to create a SSOConfiguration.
     */
    data: XOR<SSOConfigurationCreateInput, SSOConfigurationUncheckedCreateInput>
  }

  /**
   * SSOConfiguration createMany
   */
  export type SSOConfigurationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SSOConfigurations.
     */
    data: SSOConfigurationCreateManyInput | SSOConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SSOConfiguration createManyAndReturn
   */
  export type SSOConfigurationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * The data used to create many SSOConfigurations.
     */
    data: SSOConfigurationCreateManyInput | SSOConfigurationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SSOConfiguration update
   */
  export type SSOConfigurationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
    /**
     * The data needed to update a SSOConfiguration.
     */
    data: XOR<SSOConfigurationUpdateInput, SSOConfigurationUncheckedUpdateInput>
    /**
     * Choose, which SSOConfiguration to update.
     */
    where: SSOConfigurationWhereUniqueInput
  }

  /**
   * SSOConfiguration updateMany
   */
  export type SSOConfigurationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SSOConfigurations.
     */
    data: XOR<SSOConfigurationUpdateManyMutationInput, SSOConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which SSOConfigurations to update
     */
    where?: SSOConfigurationWhereInput
    /**
     * Limit how many SSOConfigurations to update.
     */
    limit?: number
  }

  /**
   * SSOConfiguration updateManyAndReturn
   */
  export type SSOConfigurationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * The data used to update SSOConfigurations.
     */
    data: XOR<SSOConfigurationUpdateManyMutationInput, SSOConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which SSOConfigurations to update
     */
    where?: SSOConfigurationWhereInput
    /**
     * Limit how many SSOConfigurations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SSOConfiguration upsert
   */
  export type SSOConfigurationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
    /**
     * The filter to search for the SSOConfiguration to update in case it exists.
     */
    where: SSOConfigurationWhereUniqueInput
    /**
     * In case the SSOConfiguration found by the `where` argument doesn't exist, create a new SSOConfiguration with this data.
     */
    create: XOR<SSOConfigurationCreateInput, SSOConfigurationUncheckedCreateInput>
    /**
     * In case the SSOConfiguration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SSOConfigurationUpdateInput, SSOConfigurationUncheckedUpdateInput>
  }

  /**
   * SSOConfiguration delete
   */
  export type SSOConfigurationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
    /**
     * Filter which SSOConfiguration to delete.
     */
    where: SSOConfigurationWhereUniqueInput
  }

  /**
   * SSOConfiguration deleteMany
   */
  export type SSOConfigurationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SSOConfigurations to delete
     */
    where?: SSOConfigurationWhereInput
    /**
     * Limit how many SSOConfigurations to delete.
     */
    limit?: number
  }

  /**
   * SSOConfiguration without action
   */
  export type SSOConfigurationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
  }


  /**
   * Model SSOSession
   */

  export type AggregateSSOSession = {
    _count: SSOSessionCountAggregateOutputType | null
    _avg: SSOSessionAvgAggregateOutputType | null
    _sum: SSOSessionSumAggregateOutputType | null
    _min: SSOSessionMinAggregateOutputType | null
    _max: SSOSessionMaxAggregateOutputType | null
  }

  export type SSOSessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SSOSessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SSOSessionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    provider: $Enums.SSOProvider | null
    sessionId: string | null
    nameId: string | null
    sessionIndex: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
    lastActivityAt: Date | null
  }

  export type SSOSessionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    provider: $Enums.SSOProvider | null
    sessionId: string | null
    nameId: string | null
    sessionIndex: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
    lastActivityAt: Date | null
  }

  export type SSOSessionCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    sessionId: number
    nameId: number
    sessionIndex: number
    attributes: number
    ipAddress: number
    userAgent: number
    expiresAt: number
    createdAt: number
    lastActivityAt: number
    _all: number
  }


  export type SSOSessionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SSOSessionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SSOSessionMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    sessionId?: true
    nameId?: true
    sessionIndex?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    lastActivityAt?: true
  }

  export type SSOSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    sessionId?: true
    nameId?: true
    sessionIndex?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    lastActivityAt?: true
  }

  export type SSOSessionCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    sessionId?: true
    nameId?: true
    sessionIndex?: true
    attributes?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    lastActivityAt?: true
    _all?: true
  }

  export type SSOSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SSOSession to aggregate.
     */
    where?: SSOSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SSOSessions to fetch.
     */
    orderBy?: SSOSessionOrderByWithRelationInput | SSOSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SSOSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SSOSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SSOSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SSOSessions
    **/
    _count?: true | SSOSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SSOSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SSOSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SSOSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SSOSessionMaxAggregateInputType
  }

  export type GetSSOSessionAggregateType<T extends SSOSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSSOSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSSOSession[P]>
      : GetScalarType<T[P], AggregateSSOSession[P]>
  }




  export type SSOSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SSOSessionWhereInput
    orderBy?: SSOSessionOrderByWithAggregationInput | SSOSessionOrderByWithAggregationInput[]
    by: SSOSessionScalarFieldEnum[] | SSOSessionScalarFieldEnum
    having?: SSOSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SSOSessionCountAggregateInputType | true
    _avg?: SSOSessionAvgAggregateInputType
    _sum?: SSOSessionSumAggregateInputType
    _min?: SSOSessionMinAggregateInputType
    _max?: SSOSessionMaxAggregateInputType
  }

  export type SSOSessionGroupByOutputType = {
    id: number
    userId: number
    provider: $Enums.SSOProvider
    sessionId: string
    nameId: string | null
    sessionIndex: string | null
    attributes: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date
    createdAt: Date
    lastActivityAt: Date
    _count: SSOSessionCountAggregateOutputType | null
    _avg: SSOSessionAvgAggregateOutputType | null
    _sum: SSOSessionSumAggregateOutputType | null
    _min: SSOSessionMinAggregateOutputType | null
    _max: SSOSessionMaxAggregateOutputType | null
  }

  type GetSSOSessionGroupByPayload<T extends SSOSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SSOSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SSOSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SSOSessionGroupByOutputType[P]>
            : GetScalarType<T[P], SSOSessionGroupByOutputType[P]>
        }
      >
    >


  export type SSOSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    sessionId?: boolean
    nameId?: boolean
    sessionIndex?: boolean
    attributes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    lastActivityAt?: boolean
  }, ExtArgs["result"]["sSOSession"]>

  export type SSOSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    sessionId?: boolean
    nameId?: boolean
    sessionIndex?: boolean
    attributes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    lastActivityAt?: boolean
  }, ExtArgs["result"]["sSOSession"]>

  export type SSOSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    sessionId?: boolean
    nameId?: boolean
    sessionIndex?: boolean
    attributes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    lastActivityAt?: boolean
  }, ExtArgs["result"]["sSOSession"]>

  export type SSOSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    sessionId?: boolean
    nameId?: boolean
    sessionIndex?: boolean
    attributes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    lastActivityAt?: boolean
  }

  export type SSOSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "provider" | "sessionId" | "nameId" | "sessionIndex" | "attributes" | "ipAddress" | "userAgent" | "expiresAt" | "createdAt" | "lastActivityAt", ExtArgs["result"]["sSOSession"]>

  export type $SSOSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SSOSession"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      provider: $Enums.SSOProvider
      sessionId: string
      nameId: string | null
      sessionIndex: string | null
      attributes: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      expiresAt: Date
      createdAt: Date
      lastActivityAt: Date
    }, ExtArgs["result"]["sSOSession"]>
    composites: {}
  }

  type SSOSessionGetPayload<S extends boolean | null | undefined | SSOSessionDefaultArgs> = $Result.GetResult<Prisma.$SSOSessionPayload, S>

  type SSOSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SSOSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SSOSessionCountAggregateInputType | true
    }

  export interface SSOSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SSOSession'], meta: { name: 'SSOSession' } }
    /**
     * Find zero or one SSOSession that matches the filter.
     * @param {SSOSessionFindUniqueArgs} args - Arguments to find a SSOSession
     * @example
     * // Get one SSOSession
     * const sSOSession = await prisma.sSOSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SSOSessionFindUniqueArgs>(args: SelectSubset<T, SSOSessionFindUniqueArgs<ExtArgs>>): Prisma__SSOSessionClient<$Result.GetResult<Prisma.$SSOSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SSOSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SSOSessionFindUniqueOrThrowArgs} args - Arguments to find a SSOSession
     * @example
     * // Get one SSOSession
     * const sSOSession = await prisma.sSOSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SSOSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SSOSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SSOSessionClient<$Result.GetResult<Prisma.$SSOSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SSOSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOSessionFindFirstArgs} args - Arguments to find a SSOSession
     * @example
     * // Get one SSOSession
     * const sSOSession = await prisma.sSOSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SSOSessionFindFirstArgs>(args?: SelectSubset<T, SSOSessionFindFirstArgs<ExtArgs>>): Prisma__SSOSessionClient<$Result.GetResult<Prisma.$SSOSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SSOSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOSessionFindFirstOrThrowArgs} args - Arguments to find a SSOSession
     * @example
     * // Get one SSOSession
     * const sSOSession = await prisma.sSOSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SSOSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SSOSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SSOSessionClient<$Result.GetResult<Prisma.$SSOSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SSOSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SSOSessions
     * const sSOSessions = await prisma.sSOSession.findMany()
     * 
     * // Get first 10 SSOSessions
     * const sSOSessions = await prisma.sSOSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sSOSessionWithIdOnly = await prisma.sSOSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SSOSessionFindManyArgs>(args?: SelectSubset<T, SSOSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SSOSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SSOSession.
     * @param {SSOSessionCreateArgs} args - Arguments to create a SSOSession.
     * @example
     * // Create one SSOSession
     * const SSOSession = await prisma.sSOSession.create({
     *   data: {
     *     // ... data to create a SSOSession
     *   }
     * })
     * 
     */
    create<T extends SSOSessionCreateArgs>(args: SelectSubset<T, SSOSessionCreateArgs<ExtArgs>>): Prisma__SSOSessionClient<$Result.GetResult<Prisma.$SSOSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SSOSessions.
     * @param {SSOSessionCreateManyArgs} args - Arguments to create many SSOSessions.
     * @example
     * // Create many SSOSessions
     * const sSOSession = await prisma.sSOSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SSOSessionCreateManyArgs>(args?: SelectSubset<T, SSOSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SSOSessions and returns the data saved in the database.
     * @param {SSOSessionCreateManyAndReturnArgs} args - Arguments to create many SSOSessions.
     * @example
     * // Create many SSOSessions
     * const sSOSession = await prisma.sSOSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SSOSessions and only return the `id`
     * const sSOSessionWithIdOnly = await prisma.sSOSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SSOSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SSOSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SSOSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SSOSession.
     * @param {SSOSessionDeleteArgs} args - Arguments to delete one SSOSession.
     * @example
     * // Delete one SSOSession
     * const SSOSession = await prisma.sSOSession.delete({
     *   where: {
     *     // ... filter to delete one SSOSession
     *   }
     * })
     * 
     */
    delete<T extends SSOSessionDeleteArgs>(args: SelectSubset<T, SSOSessionDeleteArgs<ExtArgs>>): Prisma__SSOSessionClient<$Result.GetResult<Prisma.$SSOSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SSOSession.
     * @param {SSOSessionUpdateArgs} args - Arguments to update one SSOSession.
     * @example
     * // Update one SSOSession
     * const sSOSession = await prisma.sSOSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SSOSessionUpdateArgs>(args: SelectSubset<T, SSOSessionUpdateArgs<ExtArgs>>): Prisma__SSOSessionClient<$Result.GetResult<Prisma.$SSOSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SSOSessions.
     * @param {SSOSessionDeleteManyArgs} args - Arguments to filter SSOSessions to delete.
     * @example
     * // Delete a few SSOSessions
     * const { count } = await prisma.sSOSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SSOSessionDeleteManyArgs>(args?: SelectSubset<T, SSOSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SSOSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SSOSessions
     * const sSOSession = await prisma.sSOSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SSOSessionUpdateManyArgs>(args: SelectSubset<T, SSOSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SSOSessions and returns the data updated in the database.
     * @param {SSOSessionUpdateManyAndReturnArgs} args - Arguments to update many SSOSessions.
     * @example
     * // Update many SSOSessions
     * const sSOSession = await prisma.sSOSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SSOSessions and only return the `id`
     * const sSOSessionWithIdOnly = await prisma.sSOSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SSOSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SSOSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SSOSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SSOSession.
     * @param {SSOSessionUpsertArgs} args - Arguments to update or create a SSOSession.
     * @example
     * // Update or create a SSOSession
     * const sSOSession = await prisma.sSOSession.upsert({
     *   create: {
     *     // ... data to create a SSOSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SSOSession we want to update
     *   }
     * })
     */
    upsert<T extends SSOSessionUpsertArgs>(args: SelectSubset<T, SSOSessionUpsertArgs<ExtArgs>>): Prisma__SSOSessionClient<$Result.GetResult<Prisma.$SSOSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SSOSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOSessionCountArgs} args - Arguments to filter SSOSessions to count.
     * @example
     * // Count the number of SSOSessions
     * const count = await prisma.sSOSession.count({
     *   where: {
     *     // ... the filter for the SSOSessions we want to count
     *   }
     * })
    **/
    count<T extends SSOSessionCountArgs>(
      args?: Subset<T, SSOSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SSOSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SSOSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SSOSessionAggregateArgs>(args: Subset<T, SSOSessionAggregateArgs>): Prisma.PrismaPromise<GetSSOSessionAggregateType<T>>

    /**
     * Group by SSOSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SSOSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SSOSessionGroupByArgs['orderBy'] }
        : { orderBy?: SSOSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SSOSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSSOSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SSOSession model
   */
  readonly fields: SSOSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SSOSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SSOSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SSOSession model
   */
  interface SSOSessionFieldRefs {
    readonly id: FieldRef<"SSOSession", 'Int'>
    readonly userId: FieldRef<"SSOSession", 'Int'>
    readonly provider: FieldRef<"SSOSession", 'SSOProvider'>
    readonly sessionId: FieldRef<"SSOSession", 'String'>
    readonly nameId: FieldRef<"SSOSession", 'String'>
    readonly sessionIndex: FieldRef<"SSOSession", 'String'>
    readonly attributes: FieldRef<"SSOSession", 'Json'>
    readonly ipAddress: FieldRef<"SSOSession", 'String'>
    readonly userAgent: FieldRef<"SSOSession", 'String'>
    readonly expiresAt: FieldRef<"SSOSession", 'DateTime'>
    readonly createdAt: FieldRef<"SSOSession", 'DateTime'>
    readonly lastActivityAt: FieldRef<"SSOSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SSOSession findUnique
   */
  export type SSOSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOSession
     */
    select?: SSOSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOSession
     */
    omit?: SSOSessionOmit<ExtArgs> | null
    /**
     * Filter, which SSOSession to fetch.
     */
    where: SSOSessionWhereUniqueInput
  }

  /**
   * SSOSession findUniqueOrThrow
   */
  export type SSOSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOSession
     */
    select?: SSOSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOSession
     */
    omit?: SSOSessionOmit<ExtArgs> | null
    /**
     * Filter, which SSOSession to fetch.
     */
    where: SSOSessionWhereUniqueInput
  }

  /**
   * SSOSession findFirst
   */
  export type SSOSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOSession
     */
    select?: SSOSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOSession
     */
    omit?: SSOSessionOmit<ExtArgs> | null
    /**
     * Filter, which SSOSession to fetch.
     */
    where?: SSOSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SSOSessions to fetch.
     */
    orderBy?: SSOSessionOrderByWithRelationInput | SSOSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SSOSessions.
     */
    cursor?: SSOSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SSOSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SSOSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SSOSessions.
     */
    distinct?: SSOSessionScalarFieldEnum | SSOSessionScalarFieldEnum[]
  }

  /**
   * SSOSession findFirstOrThrow
   */
  export type SSOSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOSession
     */
    select?: SSOSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOSession
     */
    omit?: SSOSessionOmit<ExtArgs> | null
    /**
     * Filter, which SSOSession to fetch.
     */
    where?: SSOSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SSOSessions to fetch.
     */
    orderBy?: SSOSessionOrderByWithRelationInput | SSOSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SSOSessions.
     */
    cursor?: SSOSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SSOSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SSOSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SSOSessions.
     */
    distinct?: SSOSessionScalarFieldEnum | SSOSessionScalarFieldEnum[]
  }

  /**
   * SSOSession findMany
   */
  export type SSOSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOSession
     */
    select?: SSOSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOSession
     */
    omit?: SSOSessionOmit<ExtArgs> | null
    /**
     * Filter, which SSOSessions to fetch.
     */
    where?: SSOSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SSOSessions to fetch.
     */
    orderBy?: SSOSessionOrderByWithRelationInput | SSOSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SSOSessions.
     */
    cursor?: SSOSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SSOSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SSOSessions.
     */
    skip?: number
    distinct?: SSOSessionScalarFieldEnum | SSOSessionScalarFieldEnum[]
  }

  /**
   * SSOSession create
   */
  export type SSOSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOSession
     */
    select?: SSOSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOSession
     */
    omit?: SSOSessionOmit<ExtArgs> | null
    /**
     * The data needed to create a SSOSession.
     */
    data: XOR<SSOSessionCreateInput, SSOSessionUncheckedCreateInput>
  }

  /**
   * SSOSession createMany
   */
  export type SSOSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SSOSessions.
     */
    data: SSOSessionCreateManyInput | SSOSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SSOSession createManyAndReturn
   */
  export type SSOSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOSession
     */
    select?: SSOSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SSOSession
     */
    omit?: SSOSessionOmit<ExtArgs> | null
    /**
     * The data used to create many SSOSessions.
     */
    data: SSOSessionCreateManyInput | SSOSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SSOSession update
   */
  export type SSOSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOSession
     */
    select?: SSOSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOSession
     */
    omit?: SSOSessionOmit<ExtArgs> | null
    /**
     * The data needed to update a SSOSession.
     */
    data: XOR<SSOSessionUpdateInput, SSOSessionUncheckedUpdateInput>
    /**
     * Choose, which SSOSession to update.
     */
    where: SSOSessionWhereUniqueInput
  }

  /**
   * SSOSession updateMany
   */
  export type SSOSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SSOSessions.
     */
    data: XOR<SSOSessionUpdateManyMutationInput, SSOSessionUncheckedUpdateManyInput>
    /**
     * Filter which SSOSessions to update
     */
    where?: SSOSessionWhereInput
    /**
     * Limit how many SSOSessions to update.
     */
    limit?: number
  }

  /**
   * SSOSession updateManyAndReturn
   */
  export type SSOSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOSession
     */
    select?: SSOSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SSOSession
     */
    omit?: SSOSessionOmit<ExtArgs> | null
    /**
     * The data used to update SSOSessions.
     */
    data: XOR<SSOSessionUpdateManyMutationInput, SSOSessionUncheckedUpdateManyInput>
    /**
     * Filter which SSOSessions to update
     */
    where?: SSOSessionWhereInput
    /**
     * Limit how many SSOSessions to update.
     */
    limit?: number
  }

  /**
   * SSOSession upsert
   */
  export type SSOSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOSession
     */
    select?: SSOSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOSession
     */
    omit?: SSOSessionOmit<ExtArgs> | null
    /**
     * The filter to search for the SSOSession to update in case it exists.
     */
    where: SSOSessionWhereUniqueInput
    /**
     * In case the SSOSession found by the `where` argument doesn't exist, create a new SSOSession with this data.
     */
    create: XOR<SSOSessionCreateInput, SSOSessionUncheckedCreateInput>
    /**
     * In case the SSOSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SSOSessionUpdateInput, SSOSessionUncheckedUpdateInput>
  }

  /**
   * SSOSession delete
   */
  export type SSOSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOSession
     */
    select?: SSOSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOSession
     */
    omit?: SSOSessionOmit<ExtArgs> | null
    /**
     * Filter which SSOSession to delete.
     */
    where: SSOSessionWhereUniqueInput
  }

  /**
   * SSOSession deleteMany
   */
  export type SSOSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SSOSessions to delete
     */
    where?: SSOSessionWhereInput
    /**
     * Limit how many SSOSessions to delete.
     */
    limit?: number
  }

  /**
   * SSOSession without action
   */
  export type SSOSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOSession
     */
    select?: SSOSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOSession
     */
    omit?: SSOSessionOmit<ExtArgs> | null
  }


  /**
   * Model SSOAuditLog
   */

  export type AggregateSSOAuditLog = {
    _count: SSOAuditLogCountAggregateOutputType | null
    _avg: SSOAuditLogAvgAggregateOutputType | null
    _sum: SSOAuditLogSumAggregateOutputType | null
    _min: SSOAuditLogMinAggregateOutputType | null
    _max: SSOAuditLogMaxAggregateOutputType | null
  }

  export type SSOAuditLogAvgAggregateOutputType = {
    id: number | null
    orgId: number | null
    userId: number | null
  }

  export type SSOAuditLogSumAggregateOutputType = {
    id: number | null
    orgId: number | null
    userId: number | null
  }

  export type SSOAuditLogMinAggregateOutputType = {
    id: number | null
    orgId: number | null
    userId: number | null
    provider: $Enums.SSOProvider | null
    eventType: $Enums.SSOEventType | null
    success: boolean | null
    ipAddress: string | null
    userAgent: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type SSOAuditLogMaxAggregateOutputType = {
    id: number | null
    orgId: number | null
    userId: number | null
    provider: $Enums.SSOProvider | null
    eventType: $Enums.SSOEventType | null
    success: boolean | null
    ipAddress: string | null
    userAgent: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type SSOAuditLogCountAggregateOutputType = {
    id: number
    orgId: number
    userId: number
    provider: number
    eventType: number
    success: number
    ipAddress: number
    userAgent: number
    errorMessage: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type SSOAuditLogAvgAggregateInputType = {
    id?: true
    orgId?: true
    userId?: true
  }

  export type SSOAuditLogSumAggregateInputType = {
    id?: true
    orgId?: true
    userId?: true
  }

  export type SSOAuditLogMinAggregateInputType = {
    id?: true
    orgId?: true
    userId?: true
    provider?: true
    eventType?: true
    success?: true
    ipAddress?: true
    userAgent?: true
    errorMessage?: true
    createdAt?: true
  }

  export type SSOAuditLogMaxAggregateInputType = {
    id?: true
    orgId?: true
    userId?: true
    provider?: true
    eventType?: true
    success?: true
    ipAddress?: true
    userAgent?: true
    errorMessage?: true
    createdAt?: true
  }

  export type SSOAuditLogCountAggregateInputType = {
    id?: true
    orgId?: true
    userId?: true
    provider?: true
    eventType?: true
    success?: true
    ipAddress?: true
    userAgent?: true
    errorMessage?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type SSOAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SSOAuditLog to aggregate.
     */
    where?: SSOAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SSOAuditLogs to fetch.
     */
    orderBy?: SSOAuditLogOrderByWithRelationInput | SSOAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SSOAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SSOAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SSOAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SSOAuditLogs
    **/
    _count?: true | SSOAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SSOAuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SSOAuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SSOAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SSOAuditLogMaxAggregateInputType
  }

  export type GetSSOAuditLogAggregateType<T extends SSOAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSSOAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSSOAuditLog[P]>
      : GetScalarType<T[P], AggregateSSOAuditLog[P]>
  }




  export type SSOAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SSOAuditLogWhereInput
    orderBy?: SSOAuditLogOrderByWithAggregationInput | SSOAuditLogOrderByWithAggregationInput[]
    by: SSOAuditLogScalarFieldEnum[] | SSOAuditLogScalarFieldEnum
    having?: SSOAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SSOAuditLogCountAggregateInputType | true
    _avg?: SSOAuditLogAvgAggregateInputType
    _sum?: SSOAuditLogSumAggregateInputType
    _min?: SSOAuditLogMinAggregateInputType
    _max?: SSOAuditLogMaxAggregateInputType
  }

  export type SSOAuditLogGroupByOutputType = {
    id: number
    orgId: number | null
    userId: number | null
    provider: $Enums.SSOProvider
    eventType: $Enums.SSOEventType
    success: boolean
    ipAddress: string | null
    userAgent: string | null
    errorMessage: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: SSOAuditLogCountAggregateOutputType | null
    _avg: SSOAuditLogAvgAggregateOutputType | null
    _sum: SSOAuditLogSumAggregateOutputType | null
    _min: SSOAuditLogMinAggregateOutputType | null
    _max: SSOAuditLogMaxAggregateOutputType | null
  }

  type GetSSOAuditLogGroupByPayload<T extends SSOAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SSOAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SSOAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SSOAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], SSOAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type SSOAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    userId?: boolean
    provider?: boolean
    eventType?: boolean
    success?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sSOAuditLog"]>

  export type SSOAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    userId?: boolean
    provider?: boolean
    eventType?: boolean
    success?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sSOAuditLog"]>

  export type SSOAuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    userId?: boolean
    provider?: boolean
    eventType?: boolean
    success?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sSOAuditLog"]>

  export type SSOAuditLogSelectScalar = {
    id?: boolean
    orgId?: boolean
    userId?: boolean
    provider?: boolean
    eventType?: boolean
    success?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type SSOAuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "userId" | "provider" | "eventType" | "success" | "ipAddress" | "userAgent" | "errorMessage" | "metadata" | "createdAt", ExtArgs["result"]["sSOAuditLog"]>

  export type $SSOAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SSOAuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orgId: number | null
      userId: number | null
      provider: $Enums.SSOProvider
      eventType: $Enums.SSOEventType
      success: boolean
      ipAddress: string | null
      userAgent: string | null
      errorMessage: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["sSOAuditLog"]>
    composites: {}
  }

  type SSOAuditLogGetPayload<S extends boolean | null | undefined | SSOAuditLogDefaultArgs> = $Result.GetResult<Prisma.$SSOAuditLogPayload, S>

  type SSOAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SSOAuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SSOAuditLogCountAggregateInputType | true
    }

  export interface SSOAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SSOAuditLog'], meta: { name: 'SSOAuditLog' } }
    /**
     * Find zero or one SSOAuditLog that matches the filter.
     * @param {SSOAuditLogFindUniqueArgs} args - Arguments to find a SSOAuditLog
     * @example
     * // Get one SSOAuditLog
     * const sSOAuditLog = await prisma.sSOAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SSOAuditLogFindUniqueArgs>(args: SelectSubset<T, SSOAuditLogFindUniqueArgs<ExtArgs>>): Prisma__SSOAuditLogClient<$Result.GetResult<Prisma.$SSOAuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SSOAuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SSOAuditLogFindUniqueOrThrowArgs} args - Arguments to find a SSOAuditLog
     * @example
     * // Get one SSOAuditLog
     * const sSOAuditLog = await prisma.sSOAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SSOAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SSOAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SSOAuditLogClient<$Result.GetResult<Prisma.$SSOAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SSOAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOAuditLogFindFirstArgs} args - Arguments to find a SSOAuditLog
     * @example
     * // Get one SSOAuditLog
     * const sSOAuditLog = await prisma.sSOAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SSOAuditLogFindFirstArgs>(args?: SelectSubset<T, SSOAuditLogFindFirstArgs<ExtArgs>>): Prisma__SSOAuditLogClient<$Result.GetResult<Prisma.$SSOAuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SSOAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOAuditLogFindFirstOrThrowArgs} args - Arguments to find a SSOAuditLog
     * @example
     * // Get one SSOAuditLog
     * const sSOAuditLog = await prisma.sSOAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SSOAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SSOAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SSOAuditLogClient<$Result.GetResult<Prisma.$SSOAuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SSOAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SSOAuditLogs
     * const sSOAuditLogs = await prisma.sSOAuditLog.findMany()
     * 
     * // Get first 10 SSOAuditLogs
     * const sSOAuditLogs = await prisma.sSOAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sSOAuditLogWithIdOnly = await prisma.sSOAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SSOAuditLogFindManyArgs>(args?: SelectSubset<T, SSOAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SSOAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SSOAuditLog.
     * @param {SSOAuditLogCreateArgs} args - Arguments to create a SSOAuditLog.
     * @example
     * // Create one SSOAuditLog
     * const SSOAuditLog = await prisma.sSOAuditLog.create({
     *   data: {
     *     // ... data to create a SSOAuditLog
     *   }
     * })
     * 
     */
    create<T extends SSOAuditLogCreateArgs>(args: SelectSubset<T, SSOAuditLogCreateArgs<ExtArgs>>): Prisma__SSOAuditLogClient<$Result.GetResult<Prisma.$SSOAuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SSOAuditLogs.
     * @param {SSOAuditLogCreateManyArgs} args - Arguments to create many SSOAuditLogs.
     * @example
     * // Create many SSOAuditLogs
     * const sSOAuditLog = await prisma.sSOAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SSOAuditLogCreateManyArgs>(args?: SelectSubset<T, SSOAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SSOAuditLogs and returns the data saved in the database.
     * @param {SSOAuditLogCreateManyAndReturnArgs} args - Arguments to create many SSOAuditLogs.
     * @example
     * // Create many SSOAuditLogs
     * const sSOAuditLog = await prisma.sSOAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SSOAuditLogs and only return the `id`
     * const sSOAuditLogWithIdOnly = await prisma.sSOAuditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SSOAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SSOAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SSOAuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SSOAuditLog.
     * @param {SSOAuditLogDeleteArgs} args - Arguments to delete one SSOAuditLog.
     * @example
     * // Delete one SSOAuditLog
     * const SSOAuditLog = await prisma.sSOAuditLog.delete({
     *   where: {
     *     // ... filter to delete one SSOAuditLog
     *   }
     * })
     * 
     */
    delete<T extends SSOAuditLogDeleteArgs>(args: SelectSubset<T, SSOAuditLogDeleteArgs<ExtArgs>>): Prisma__SSOAuditLogClient<$Result.GetResult<Prisma.$SSOAuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SSOAuditLog.
     * @param {SSOAuditLogUpdateArgs} args - Arguments to update one SSOAuditLog.
     * @example
     * // Update one SSOAuditLog
     * const sSOAuditLog = await prisma.sSOAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SSOAuditLogUpdateArgs>(args: SelectSubset<T, SSOAuditLogUpdateArgs<ExtArgs>>): Prisma__SSOAuditLogClient<$Result.GetResult<Prisma.$SSOAuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SSOAuditLogs.
     * @param {SSOAuditLogDeleteManyArgs} args - Arguments to filter SSOAuditLogs to delete.
     * @example
     * // Delete a few SSOAuditLogs
     * const { count } = await prisma.sSOAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SSOAuditLogDeleteManyArgs>(args?: SelectSubset<T, SSOAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SSOAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SSOAuditLogs
     * const sSOAuditLog = await prisma.sSOAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SSOAuditLogUpdateManyArgs>(args: SelectSubset<T, SSOAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SSOAuditLogs and returns the data updated in the database.
     * @param {SSOAuditLogUpdateManyAndReturnArgs} args - Arguments to update many SSOAuditLogs.
     * @example
     * // Update many SSOAuditLogs
     * const sSOAuditLog = await prisma.sSOAuditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SSOAuditLogs and only return the `id`
     * const sSOAuditLogWithIdOnly = await prisma.sSOAuditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SSOAuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, SSOAuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SSOAuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SSOAuditLog.
     * @param {SSOAuditLogUpsertArgs} args - Arguments to update or create a SSOAuditLog.
     * @example
     * // Update or create a SSOAuditLog
     * const sSOAuditLog = await prisma.sSOAuditLog.upsert({
     *   create: {
     *     // ... data to create a SSOAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SSOAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends SSOAuditLogUpsertArgs>(args: SelectSubset<T, SSOAuditLogUpsertArgs<ExtArgs>>): Prisma__SSOAuditLogClient<$Result.GetResult<Prisma.$SSOAuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SSOAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOAuditLogCountArgs} args - Arguments to filter SSOAuditLogs to count.
     * @example
     * // Count the number of SSOAuditLogs
     * const count = await prisma.sSOAuditLog.count({
     *   where: {
     *     // ... the filter for the SSOAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends SSOAuditLogCountArgs>(
      args?: Subset<T, SSOAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SSOAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SSOAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SSOAuditLogAggregateArgs>(args: Subset<T, SSOAuditLogAggregateArgs>): Prisma.PrismaPromise<GetSSOAuditLogAggregateType<T>>

    /**
     * Group by SSOAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SSOAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SSOAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: SSOAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SSOAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSSOAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SSOAuditLog model
   */
  readonly fields: SSOAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SSOAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SSOAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SSOAuditLog model
   */
  interface SSOAuditLogFieldRefs {
    readonly id: FieldRef<"SSOAuditLog", 'Int'>
    readonly orgId: FieldRef<"SSOAuditLog", 'Int'>
    readonly userId: FieldRef<"SSOAuditLog", 'Int'>
    readonly provider: FieldRef<"SSOAuditLog", 'SSOProvider'>
    readonly eventType: FieldRef<"SSOAuditLog", 'SSOEventType'>
    readonly success: FieldRef<"SSOAuditLog", 'Boolean'>
    readonly ipAddress: FieldRef<"SSOAuditLog", 'String'>
    readonly userAgent: FieldRef<"SSOAuditLog", 'String'>
    readonly errorMessage: FieldRef<"SSOAuditLog", 'String'>
    readonly metadata: FieldRef<"SSOAuditLog", 'Json'>
    readonly createdAt: FieldRef<"SSOAuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SSOAuditLog findUnique
   */
  export type SSOAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOAuditLog
     */
    select?: SSOAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOAuditLog
     */
    omit?: SSOAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which SSOAuditLog to fetch.
     */
    where: SSOAuditLogWhereUniqueInput
  }

  /**
   * SSOAuditLog findUniqueOrThrow
   */
  export type SSOAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOAuditLog
     */
    select?: SSOAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOAuditLog
     */
    omit?: SSOAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which SSOAuditLog to fetch.
     */
    where: SSOAuditLogWhereUniqueInput
  }

  /**
   * SSOAuditLog findFirst
   */
  export type SSOAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOAuditLog
     */
    select?: SSOAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOAuditLog
     */
    omit?: SSOAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which SSOAuditLog to fetch.
     */
    where?: SSOAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SSOAuditLogs to fetch.
     */
    orderBy?: SSOAuditLogOrderByWithRelationInput | SSOAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SSOAuditLogs.
     */
    cursor?: SSOAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SSOAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SSOAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SSOAuditLogs.
     */
    distinct?: SSOAuditLogScalarFieldEnum | SSOAuditLogScalarFieldEnum[]
  }

  /**
   * SSOAuditLog findFirstOrThrow
   */
  export type SSOAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOAuditLog
     */
    select?: SSOAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOAuditLog
     */
    omit?: SSOAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which SSOAuditLog to fetch.
     */
    where?: SSOAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SSOAuditLogs to fetch.
     */
    orderBy?: SSOAuditLogOrderByWithRelationInput | SSOAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SSOAuditLogs.
     */
    cursor?: SSOAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SSOAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SSOAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SSOAuditLogs.
     */
    distinct?: SSOAuditLogScalarFieldEnum | SSOAuditLogScalarFieldEnum[]
  }

  /**
   * SSOAuditLog findMany
   */
  export type SSOAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOAuditLog
     */
    select?: SSOAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOAuditLog
     */
    omit?: SSOAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which SSOAuditLogs to fetch.
     */
    where?: SSOAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SSOAuditLogs to fetch.
     */
    orderBy?: SSOAuditLogOrderByWithRelationInput | SSOAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SSOAuditLogs.
     */
    cursor?: SSOAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SSOAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SSOAuditLogs.
     */
    skip?: number
    distinct?: SSOAuditLogScalarFieldEnum | SSOAuditLogScalarFieldEnum[]
  }

  /**
   * SSOAuditLog create
   */
  export type SSOAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOAuditLog
     */
    select?: SSOAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOAuditLog
     */
    omit?: SSOAuditLogOmit<ExtArgs> | null
    /**
     * The data needed to create a SSOAuditLog.
     */
    data: XOR<SSOAuditLogCreateInput, SSOAuditLogUncheckedCreateInput>
  }

  /**
   * SSOAuditLog createMany
   */
  export type SSOAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SSOAuditLogs.
     */
    data: SSOAuditLogCreateManyInput | SSOAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SSOAuditLog createManyAndReturn
   */
  export type SSOAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOAuditLog
     */
    select?: SSOAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SSOAuditLog
     */
    omit?: SSOAuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many SSOAuditLogs.
     */
    data: SSOAuditLogCreateManyInput | SSOAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SSOAuditLog update
   */
  export type SSOAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOAuditLog
     */
    select?: SSOAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOAuditLog
     */
    omit?: SSOAuditLogOmit<ExtArgs> | null
    /**
     * The data needed to update a SSOAuditLog.
     */
    data: XOR<SSOAuditLogUpdateInput, SSOAuditLogUncheckedUpdateInput>
    /**
     * Choose, which SSOAuditLog to update.
     */
    where: SSOAuditLogWhereUniqueInput
  }

  /**
   * SSOAuditLog updateMany
   */
  export type SSOAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SSOAuditLogs.
     */
    data: XOR<SSOAuditLogUpdateManyMutationInput, SSOAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which SSOAuditLogs to update
     */
    where?: SSOAuditLogWhereInput
    /**
     * Limit how many SSOAuditLogs to update.
     */
    limit?: number
  }

  /**
   * SSOAuditLog updateManyAndReturn
   */
  export type SSOAuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOAuditLog
     */
    select?: SSOAuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SSOAuditLog
     */
    omit?: SSOAuditLogOmit<ExtArgs> | null
    /**
     * The data used to update SSOAuditLogs.
     */
    data: XOR<SSOAuditLogUpdateManyMutationInput, SSOAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which SSOAuditLogs to update
     */
    where?: SSOAuditLogWhereInput
    /**
     * Limit how many SSOAuditLogs to update.
     */
    limit?: number
  }

  /**
   * SSOAuditLog upsert
   */
  export type SSOAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOAuditLog
     */
    select?: SSOAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOAuditLog
     */
    omit?: SSOAuditLogOmit<ExtArgs> | null
    /**
     * The filter to search for the SSOAuditLog to update in case it exists.
     */
    where: SSOAuditLogWhereUniqueInput
    /**
     * In case the SSOAuditLog found by the `where` argument doesn't exist, create a new SSOAuditLog with this data.
     */
    create: XOR<SSOAuditLogCreateInput, SSOAuditLogUncheckedCreateInput>
    /**
     * In case the SSOAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SSOAuditLogUpdateInput, SSOAuditLogUncheckedUpdateInput>
  }

  /**
   * SSOAuditLog delete
   */
  export type SSOAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOAuditLog
     */
    select?: SSOAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOAuditLog
     */
    omit?: SSOAuditLogOmit<ExtArgs> | null
    /**
     * Filter which SSOAuditLog to delete.
     */
    where: SSOAuditLogWhereUniqueInput
  }

  /**
   * SSOAuditLog deleteMany
   */
  export type SSOAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SSOAuditLogs to delete
     */
    where?: SSOAuditLogWhereInput
    /**
     * Limit how many SSOAuditLogs to delete.
     */
    limit?: number
  }

  /**
   * SSOAuditLog without action
   */
  export type SSOAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOAuditLog
     */
    select?: SSOAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOAuditLog
     */
    omit?: SSOAuditLogOmit<ExtArgs> | null
  }


  /**
   * Model NotificationPreference
   */

  export type AggregateNotificationPreference = {
    _count: NotificationPreferenceCountAggregateOutputType | null
    _avg: NotificationPreferenceAvgAggregateOutputType | null
    _sum: NotificationPreferenceSumAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  export type NotificationPreferenceAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    lowScoreThreshold: number | null
    highScoreThreshold: number | null
  }

  export type NotificationPreferenceSumAggregateOutputType = {
    id: number | null
    userId: number | null
    lowScoreThreshold: number | null
    highScoreThreshold: number | null
  }

  export type NotificationPreferenceMinAggregateOutputType = {
    id: number | null
    userId: number | null
    emailEnabled: boolean | null
    testComplete: boolean | null
    batchComplete: boolean | null
    scheduledTestComplete: boolean | null
    alertsEnabled: boolean | null
    lowScoreThreshold: number | null
    highScoreThreshold: number | null
    scoreDropAlert: boolean | null
    witnessFailureAlert: boolean | null
    dailyReport: boolean | null
    weeklyReport: boolean | null
    monthlyReport: boolean | null
    reportTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    emailEnabled: boolean | null
    testComplete: boolean | null
    batchComplete: boolean | null
    scheduledTestComplete: boolean | null
    alertsEnabled: boolean | null
    lowScoreThreshold: number | null
    highScoreThreshold: number | null
    scoreDropAlert: boolean | null
    witnessFailureAlert: boolean | null
    dailyReport: boolean | null
    weeklyReport: boolean | null
    monthlyReport: boolean | null
    reportTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceCountAggregateOutputType = {
    id: number
    userId: number
    emailEnabled: number
    testComplete: number
    batchComplete: number
    scheduledTestComplete: number
    alertsEnabled: number
    lowScoreThreshold: number
    highScoreThreshold: number
    scoreDropAlert: number
    witnessFailureAlert: number
    dailyReport: number
    weeklyReport: number
    monthlyReport: number
    reportTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationPreferenceAvgAggregateInputType = {
    id?: true
    userId?: true
    lowScoreThreshold?: true
    highScoreThreshold?: true
  }

  export type NotificationPreferenceSumAggregateInputType = {
    id?: true
    userId?: true
    lowScoreThreshold?: true
    highScoreThreshold?: true
  }

  export type NotificationPreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    emailEnabled?: true
    testComplete?: true
    batchComplete?: true
    scheduledTestComplete?: true
    alertsEnabled?: true
    lowScoreThreshold?: true
    highScoreThreshold?: true
    scoreDropAlert?: true
    witnessFailureAlert?: true
    dailyReport?: true
    weeklyReport?: true
    monthlyReport?: true
    reportTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    emailEnabled?: true
    testComplete?: true
    batchComplete?: true
    scheduledTestComplete?: true
    alertsEnabled?: true
    lowScoreThreshold?: true
    highScoreThreshold?: true
    scoreDropAlert?: true
    witnessFailureAlert?: true
    dailyReport?: true
    weeklyReport?: true
    monthlyReport?: true
    reportTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    emailEnabled?: true
    testComplete?: true
    batchComplete?: true
    scheduledTestComplete?: true
    alertsEnabled?: true
    lowScoreThreshold?: true
    highScoreThreshold?: true
    scoreDropAlert?: true
    witnessFailureAlert?: true
    dailyReport?: true
    weeklyReport?: true
    monthlyReport?: true
    reportTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreference to aggregate.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPreferences
    **/
    _count?: true | NotificationPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationPreferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationPreferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type GetNotificationPreferenceAggregateType<T extends NotificationPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreference[P]>
      : GetScalarType<T[P], AggregateNotificationPreference[P]>
  }




  export type NotificationPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithAggregationInput | NotificationPreferenceOrderByWithAggregationInput[]
    by: NotificationPreferenceScalarFieldEnum[] | NotificationPreferenceScalarFieldEnum
    having?: NotificationPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPreferenceCountAggregateInputType | true
    _avg?: NotificationPreferenceAvgAggregateInputType
    _sum?: NotificationPreferenceSumAggregateInputType
    _min?: NotificationPreferenceMinAggregateInputType
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type NotificationPreferenceGroupByOutputType = {
    id: number
    userId: number
    emailEnabled: boolean
    testComplete: boolean
    batchComplete: boolean
    scheduledTestComplete: boolean
    alertsEnabled: boolean
    lowScoreThreshold: number
    highScoreThreshold: number
    scoreDropAlert: boolean
    witnessFailureAlert: boolean
    dailyReport: boolean
    weeklyReport: boolean
    monthlyReport: boolean
    reportTime: string
    createdAt: Date
    updatedAt: Date
    _count: NotificationPreferenceCountAggregateOutputType | null
    _avg: NotificationPreferenceAvgAggregateOutputType | null
    _sum: NotificationPreferenceSumAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  type GetNotificationPreferenceGroupByPayload<T extends NotificationPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    testComplete?: boolean
    batchComplete?: boolean
    scheduledTestComplete?: boolean
    alertsEnabled?: boolean
    lowScoreThreshold?: boolean
    highScoreThreshold?: boolean
    scoreDropAlert?: boolean
    witnessFailureAlert?: boolean
    dailyReport?: boolean
    weeklyReport?: boolean
    monthlyReport?: boolean
    reportTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    testComplete?: boolean
    batchComplete?: boolean
    scheduledTestComplete?: boolean
    alertsEnabled?: boolean
    lowScoreThreshold?: boolean
    highScoreThreshold?: boolean
    scoreDropAlert?: boolean
    witnessFailureAlert?: boolean
    dailyReport?: boolean
    weeklyReport?: boolean
    monthlyReport?: boolean
    reportTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    testComplete?: boolean
    batchComplete?: boolean
    scheduledTestComplete?: boolean
    alertsEnabled?: boolean
    lowScoreThreshold?: boolean
    highScoreThreshold?: boolean
    scoreDropAlert?: boolean
    witnessFailureAlert?: boolean
    dailyReport?: boolean
    weeklyReport?: boolean
    monthlyReport?: boolean
    reportTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    testComplete?: boolean
    batchComplete?: boolean
    scheduledTestComplete?: boolean
    alertsEnabled?: boolean
    lowScoreThreshold?: boolean
    highScoreThreshold?: boolean
    scoreDropAlert?: boolean
    witnessFailureAlert?: boolean
    dailyReport?: boolean
    weeklyReport?: boolean
    monthlyReport?: boolean
    reportTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationPreferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "emailEnabled" | "testComplete" | "batchComplete" | "scheduledTestComplete" | "alertsEnabled" | "lowScoreThreshold" | "highScoreThreshold" | "scoreDropAlert" | "witnessFailureAlert" | "dailyReport" | "weeklyReport" | "monthlyReport" | "reportTime" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationPreference"]>
  export type NotificationPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      emailEnabled: boolean
      testComplete: boolean
      batchComplete: boolean
      scheduledTestComplete: boolean
      alertsEnabled: boolean
      lowScoreThreshold: number
      highScoreThreshold: number
      scoreDropAlert: boolean
      witnessFailureAlert: boolean
      dailyReport: boolean
      weeklyReport: boolean
      monthlyReport: boolean
      reportTime: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationPreference"]>
    composites: {}
  }

  type NotificationPreferenceGetPayload<S extends boolean | null | undefined | NotificationPreferenceDefaultArgs> = $Result.GetResult<Prisma.$NotificationPreferencePayload, S>

  type NotificationPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationPreferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationPreferenceCountAggregateInputType | true
    }

  export interface NotificationPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPreference'], meta: { name: 'NotificationPreference' } }
    /**
     * Find zero or one NotificationPreference that matches the filter.
     * @param {NotificationPreferenceFindUniqueArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPreferenceFindUniqueArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPreferenceFindFirstArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany()
     * 
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationPreferenceFindManyArgs>(args?: SelectSubset<T, NotificationPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationPreference.
     * @param {NotificationPreferenceCreateArgs} args - Arguments to create a NotificationPreference.
     * @example
     * // Create one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.create({
     *   data: {
     *     // ... data to create a NotificationPreference
     *   }
     * })
     * 
     */
    create<T extends NotificationPreferenceCreateArgs>(args: SelectSubset<T, NotificationPreferenceCreateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationPreferences.
     * @param {NotificationPreferenceCreateManyArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPreferenceCreateManyArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPreferences and returns the data saved in the database.
     * @param {NotificationPreferenceCreateManyAndReturnArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationPreference.
     * @param {NotificationPreferenceDeleteArgs} args - Arguments to delete one NotificationPreference.
     * @example
     * // Delete one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreference
     *   }
     * })
     * 
     */
    delete<T extends NotificationPreferenceDeleteArgs>(args: SelectSubset<T, NotificationPreferenceDeleteArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationPreference.
     * @param {NotificationPreferenceUpdateArgs} args - Arguments to update one NotificationPreference.
     * @example
     * // Update one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPreferenceUpdateArgs>(args: SelectSubset<T, NotificationPreferenceUpdateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferenceDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPreferenceDeleteManyArgs>(args?: SelectSubset<T, NotificationPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPreferenceUpdateManyArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences and returns the data updated in the database.
     * @param {NotificationPreferenceUpdateManyAndReturnArgs} args - Arguments to update many NotificationPreferences.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationPreferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationPreference.
     * @param {NotificationPreferenceUpsertArgs} args - Arguments to update or create a NotificationPreference.
     * @example
     * // Update or create a NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.upsert({
     *   create: {
     *     // ... data to create a NotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreference we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPreferenceUpsertArgs>(args: SelectSubset<T, NotificationPreferenceUpsertArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreference.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends NotificationPreferenceCountArgs>(
      args?: Subset<T, NotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPreferenceAggregateArgs>(args: Subset<T, NotificationPreferenceAggregateArgs>): Prisma.PrismaPromise<GetNotificationPreferenceAggregateType<T>>

    /**
     * Group by NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPreference model
   */
  readonly fields: NotificationPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPreference model
   */
  interface NotificationPreferenceFieldRefs {
    readonly id: FieldRef<"NotificationPreference", 'Int'>
    readonly userId: FieldRef<"NotificationPreference", 'Int'>
    readonly emailEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly testComplete: FieldRef<"NotificationPreference", 'Boolean'>
    readonly batchComplete: FieldRef<"NotificationPreference", 'Boolean'>
    readonly scheduledTestComplete: FieldRef<"NotificationPreference", 'Boolean'>
    readonly alertsEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly lowScoreThreshold: FieldRef<"NotificationPreference", 'Float'>
    readonly highScoreThreshold: FieldRef<"NotificationPreference", 'Float'>
    readonly scoreDropAlert: FieldRef<"NotificationPreference", 'Boolean'>
    readonly witnessFailureAlert: FieldRef<"NotificationPreference", 'Boolean'>
    readonly dailyReport: FieldRef<"NotificationPreference", 'Boolean'>
    readonly weeklyReport: FieldRef<"NotificationPreference", 'Boolean'>
    readonly monthlyReport: FieldRef<"NotificationPreference", 'Boolean'>
    readonly reportTime: FieldRef<"NotificationPreference", 'String'>
    readonly createdAt: FieldRef<"NotificationPreference", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPreference findUnique
   */
  export type NotificationPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findUniqueOrThrow
   */
  export type NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findFirst
   */
  export type NotificationPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findFirstOrThrow
   */
  export type NotificationPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findMany
   */
  export type NotificationPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference create
   */
  export type NotificationPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPreference.
     */
    data: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
  }

  /**
   * NotificationPreference createMany
   */
  export type NotificationPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPreference createManyAndReturn
   */
  export type NotificationPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference update
   */
  export type NotificationPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPreference.
     */
    data: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
    /**
     * Choose, which NotificationPreference to update.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference updateMany
   */
  export type NotificationPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
  }

  /**
   * NotificationPreference updateManyAndReturn
   */
  export type NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference upsert
   */
  export type NotificationPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPreference to update in case it exists.
     */
    where: NotificationPreferenceWhereUniqueInput
    /**
     * In case the NotificationPreference found by the `where` argument doesn't exist, create a new NotificationPreference with this data.
     */
    create: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
    /**
     * In case the NotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
  }

  /**
   * NotificationPreference delete
   */
  export type NotificationPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter which NotificationPreference to delete.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference deleteMany
   */
  export type NotificationPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to delete.
     */
    limit?: number
  }

  /**
   * NotificationPreference without action
   */
  export type NotificationPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model TestResult
   */

  export type AggregateTestResult = {
    _count: TestResultCountAggregateOutputType | null
    _avg: TestResultAvgAggregateOutputType | null
    _sum: TestResultSumAggregateOutputType | null
    _min: TestResultMinAggregateOutputType | null
    _max: TestResultMaxAggregateOutputType | null
  }

  export type TestResultAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    criesScore: number | null
    responseTime: number | null
    tokenCount: number | null
    cost: number | null
  }

  export type TestResultSumAggregateOutputType = {
    id: number | null
    userId: number | null
    criesScore: number | null
    responseTime: number | null
    tokenCount: number | null
    cost: number | null
  }

  export type TestResultMinAggregateOutputType = {
    id: number | null
    userId: number | null
    modelName: string | null
    modelProvider: string | null
    prompt: string | null
    response: string | null
    criesScore: number | null
    responseTime: number | null
    tokenCount: number | null
    cost: number | null
    status: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type TestResultMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    modelName: string | null
    modelProvider: string | null
    prompt: string | null
    response: string | null
    criesScore: number | null
    responseTime: number | null
    tokenCount: number | null
    cost: number | null
    status: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type TestResultCountAggregateOutputType = {
    id: number
    userId: number
    modelName: number
    modelProvider: number
    prompt: number
    response: number
    criesScore: number
    responseTime: number
    tokenCount: number
    cost: number
    status: number
    errorMessage: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type TestResultAvgAggregateInputType = {
    id?: true
    userId?: true
    criesScore?: true
    responseTime?: true
    tokenCount?: true
    cost?: true
  }

  export type TestResultSumAggregateInputType = {
    id?: true
    userId?: true
    criesScore?: true
    responseTime?: true
    tokenCount?: true
    cost?: true
  }

  export type TestResultMinAggregateInputType = {
    id?: true
    userId?: true
    modelName?: true
    modelProvider?: true
    prompt?: true
    response?: true
    criesScore?: true
    responseTime?: true
    tokenCount?: true
    cost?: true
    status?: true
    errorMessage?: true
    createdAt?: true
  }

  export type TestResultMaxAggregateInputType = {
    id?: true
    userId?: true
    modelName?: true
    modelProvider?: true
    prompt?: true
    response?: true
    criesScore?: true
    responseTime?: true
    tokenCount?: true
    cost?: true
    status?: true
    errorMessage?: true
    createdAt?: true
  }

  export type TestResultCountAggregateInputType = {
    id?: true
    userId?: true
    modelName?: true
    modelProvider?: true
    prompt?: true
    response?: true
    criesScore?: true
    responseTime?: true
    tokenCount?: true
    cost?: true
    status?: true
    errorMessage?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type TestResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestResult to aggregate.
     */
    where?: TestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestResults to fetch.
     */
    orderBy?: TestResultOrderByWithRelationInput | TestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestResults
    **/
    _count?: true | TestResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestResultMaxAggregateInputType
  }

  export type GetTestResultAggregateType<T extends TestResultAggregateArgs> = {
        [P in keyof T & keyof AggregateTestResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestResult[P]>
      : GetScalarType<T[P], AggregateTestResult[P]>
  }




  export type TestResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestResultWhereInput
    orderBy?: TestResultOrderByWithAggregationInput | TestResultOrderByWithAggregationInput[]
    by: TestResultScalarFieldEnum[] | TestResultScalarFieldEnum
    having?: TestResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestResultCountAggregateInputType | true
    _avg?: TestResultAvgAggregateInputType
    _sum?: TestResultSumAggregateInputType
    _min?: TestResultMinAggregateInputType
    _max?: TestResultMaxAggregateInputType
  }

  export type TestResultGroupByOutputType = {
    id: number
    userId: number
    modelName: string
    modelProvider: string
    prompt: string
    response: string | null
    criesScore: number | null
    responseTime: number | null
    tokenCount: number | null
    cost: number | null
    status: string
    errorMessage: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: TestResultCountAggregateOutputType | null
    _avg: TestResultAvgAggregateOutputType | null
    _sum: TestResultSumAggregateOutputType | null
    _min: TestResultMinAggregateOutputType | null
    _max: TestResultMaxAggregateOutputType | null
  }

  type GetTestResultGroupByPayload<T extends TestResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestResultGroupByOutputType[P]>
            : GetScalarType<T[P], TestResultGroupByOutputType[P]>
        }
      >
    >


  export type TestResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    modelName?: boolean
    modelProvider?: boolean
    prompt?: boolean
    response?: boolean
    criesScore?: boolean
    responseTime?: boolean
    tokenCount?: boolean
    cost?: boolean
    status?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["testResult"]>

  export type TestResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    modelName?: boolean
    modelProvider?: boolean
    prompt?: boolean
    response?: boolean
    criesScore?: boolean
    responseTime?: boolean
    tokenCount?: boolean
    cost?: boolean
    status?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["testResult"]>

  export type TestResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    modelName?: boolean
    modelProvider?: boolean
    prompt?: boolean
    response?: boolean
    criesScore?: boolean
    responseTime?: boolean
    tokenCount?: boolean
    cost?: boolean
    status?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["testResult"]>

  export type TestResultSelectScalar = {
    id?: boolean
    userId?: boolean
    modelName?: boolean
    modelProvider?: boolean
    prompt?: boolean
    response?: boolean
    criesScore?: boolean
    responseTime?: boolean
    tokenCount?: boolean
    cost?: boolean
    status?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type TestResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "modelName" | "modelProvider" | "prompt" | "response" | "criesScore" | "responseTime" | "tokenCount" | "cost" | "status" | "errorMessage" | "metadata" | "createdAt", ExtArgs["result"]["testResult"]>

  export type $TestResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestResult"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      modelName: string
      modelProvider: string
      prompt: string
      response: string | null
      criesScore: number | null
      responseTime: number | null
      tokenCount: number | null
      cost: number | null
      status: string
      errorMessage: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["testResult"]>
    composites: {}
  }

  type TestResultGetPayload<S extends boolean | null | undefined | TestResultDefaultArgs> = $Result.GetResult<Prisma.$TestResultPayload, S>

  type TestResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestResultCountAggregateInputType | true
    }

  export interface TestResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestResult'], meta: { name: 'TestResult' } }
    /**
     * Find zero or one TestResult that matches the filter.
     * @param {TestResultFindUniqueArgs} args - Arguments to find a TestResult
     * @example
     * // Get one TestResult
     * const testResult = await prisma.testResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestResultFindUniqueArgs>(args: SelectSubset<T, TestResultFindUniqueArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestResultFindUniqueOrThrowArgs} args - Arguments to find a TestResult
     * @example
     * // Get one TestResult
     * const testResult = await prisma.testResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestResultFindUniqueOrThrowArgs>(args: SelectSubset<T, TestResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResultFindFirstArgs} args - Arguments to find a TestResult
     * @example
     * // Get one TestResult
     * const testResult = await prisma.testResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestResultFindFirstArgs>(args?: SelectSubset<T, TestResultFindFirstArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResultFindFirstOrThrowArgs} args - Arguments to find a TestResult
     * @example
     * // Get one TestResult
     * const testResult = await prisma.testResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestResultFindFirstOrThrowArgs>(args?: SelectSubset<T, TestResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestResults
     * const testResults = await prisma.testResult.findMany()
     * 
     * // Get first 10 TestResults
     * const testResults = await prisma.testResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testResultWithIdOnly = await prisma.testResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestResultFindManyArgs>(args?: SelectSubset<T, TestResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestResult.
     * @param {TestResultCreateArgs} args - Arguments to create a TestResult.
     * @example
     * // Create one TestResult
     * const TestResult = await prisma.testResult.create({
     *   data: {
     *     // ... data to create a TestResult
     *   }
     * })
     * 
     */
    create<T extends TestResultCreateArgs>(args: SelectSubset<T, TestResultCreateArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestResults.
     * @param {TestResultCreateManyArgs} args - Arguments to create many TestResults.
     * @example
     * // Create many TestResults
     * const testResult = await prisma.testResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestResultCreateManyArgs>(args?: SelectSubset<T, TestResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestResults and returns the data saved in the database.
     * @param {TestResultCreateManyAndReturnArgs} args - Arguments to create many TestResults.
     * @example
     * // Create many TestResults
     * const testResult = await prisma.testResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestResults and only return the `id`
     * const testResultWithIdOnly = await prisma.testResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestResultCreateManyAndReturnArgs>(args?: SelectSubset<T, TestResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TestResult.
     * @param {TestResultDeleteArgs} args - Arguments to delete one TestResult.
     * @example
     * // Delete one TestResult
     * const TestResult = await prisma.testResult.delete({
     *   where: {
     *     // ... filter to delete one TestResult
     *   }
     * })
     * 
     */
    delete<T extends TestResultDeleteArgs>(args: SelectSubset<T, TestResultDeleteArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestResult.
     * @param {TestResultUpdateArgs} args - Arguments to update one TestResult.
     * @example
     * // Update one TestResult
     * const testResult = await prisma.testResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestResultUpdateArgs>(args: SelectSubset<T, TestResultUpdateArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestResults.
     * @param {TestResultDeleteManyArgs} args - Arguments to filter TestResults to delete.
     * @example
     * // Delete a few TestResults
     * const { count } = await prisma.testResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestResultDeleteManyArgs>(args?: SelectSubset<T, TestResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestResults
     * const testResult = await prisma.testResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestResultUpdateManyArgs>(args: SelectSubset<T, TestResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestResults and returns the data updated in the database.
     * @param {TestResultUpdateManyAndReturnArgs} args - Arguments to update many TestResults.
     * @example
     * // Update many TestResults
     * const testResult = await prisma.testResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TestResults and only return the `id`
     * const testResultWithIdOnly = await prisma.testResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestResultUpdateManyAndReturnArgs>(args: SelectSubset<T, TestResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TestResult.
     * @param {TestResultUpsertArgs} args - Arguments to update or create a TestResult.
     * @example
     * // Update or create a TestResult
     * const testResult = await prisma.testResult.upsert({
     *   create: {
     *     // ... data to create a TestResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestResult we want to update
     *   }
     * })
     */
    upsert<T extends TestResultUpsertArgs>(args: SelectSubset<T, TestResultUpsertArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResultCountArgs} args - Arguments to filter TestResults to count.
     * @example
     * // Count the number of TestResults
     * const count = await prisma.testResult.count({
     *   where: {
     *     // ... the filter for the TestResults we want to count
     *   }
     * })
    **/
    count<T extends TestResultCountArgs>(
      args?: Subset<T, TestResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestResultAggregateArgs>(args: Subset<T, TestResultAggregateArgs>): Prisma.PrismaPromise<GetTestResultAggregateType<T>>

    /**
     * Group by TestResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestResultGroupByArgs['orderBy'] }
        : { orderBy?: TestResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestResult model
   */
  readonly fields: TestResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestResult model
   */
  interface TestResultFieldRefs {
    readonly id: FieldRef<"TestResult", 'Int'>
    readonly userId: FieldRef<"TestResult", 'Int'>
    readonly modelName: FieldRef<"TestResult", 'String'>
    readonly modelProvider: FieldRef<"TestResult", 'String'>
    readonly prompt: FieldRef<"TestResult", 'String'>
    readonly response: FieldRef<"TestResult", 'String'>
    readonly criesScore: FieldRef<"TestResult", 'Float'>
    readonly responseTime: FieldRef<"TestResult", 'Int'>
    readonly tokenCount: FieldRef<"TestResult", 'Int'>
    readonly cost: FieldRef<"TestResult", 'Float'>
    readonly status: FieldRef<"TestResult", 'String'>
    readonly errorMessage: FieldRef<"TestResult", 'String'>
    readonly metadata: FieldRef<"TestResult", 'Json'>
    readonly createdAt: FieldRef<"TestResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TestResult findUnique
   */
  export type TestResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Filter, which TestResult to fetch.
     */
    where: TestResultWhereUniqueInput
  }

  /**
   * TestResult findUniqueOrThrow
   */
  export type TestResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Filter, which TestResult to fetch.
     */
    where: TestResultWhereUniqueInput
  }

  /**
   * TestResult findFirst
   */
  export type TestResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Filter, which TestResult to fetch.
     */
    where?: TestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestResults to fetch.
     */
    orderBy?: TestResultOrderByWithRelationInput | TestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestResults.
     */
    cursor?: TestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestResults.
     */
    distinct?: TestResultScalarFieldEnum | TestResultScalarFieldEnum[]
  }

  /**
   * TestResult findFirstOrThrow
   */
  export type TestResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Filter, which TestResult to fetch.
     */
    where?: TestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestResults to fetch.
     */
    orderBy?: TestResultOrderByWithRelationInput | TestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestResults.
     */
    cursor?: TestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestResults.
     */
    distinct?: TestResultScalarFieldEnum | TestResultScalarFieldEnum[]
  }

  /**
   * TestResult findMany
   */
  export type TestResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Filter, which TestResults to fetch.
     */
    where?: TestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestResults to fetch.
     */
    orderBy?: TestResultOrderByWithRelationInput | TestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestResults.
     */
    cursor?: TestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestResults.
     */
    skip?: number
    distinct?: TestResultScalarFieldEnum | TestResultScalarFieldEnum[]
  }

  /**
   * TestResult create
   */
  export type TestResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * The data needed to create a TestResult.
     */
    data: XOR<TestResultCreateInput, TestResultUncheckedCreateInput>
  }

  /**
   * TestResult createMany
   */
  export type TestResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestResults.
     */
    data: TestResultCreateManyInput | TestResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestResult createManyAndReturn
   */
  export type TestResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * The data used to create many TestResults.
     */
    data: TestResultCreateManyInput | TestResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestResult update
   */
  export type TestResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * The data needed to update a TestResult.
     */
    data: XOR<TestResultUpdateInput, TestResultUncheckedUpdateInput>
    /**
     * Choose, which TestResult to update.
     */
    where: TestResultWhereUniqueInput
  }

  /**
   * TestResult updateMany
   */
  export type TestResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestResults.
     */
    data: XOR<TestResultUpdateManyMutationInput, TestResultUncheckedUpdateManyInput>
    /**
     * Filter which TestResults to update
     */
    where?: TestResultWhereInput
    /**
     * Limit how many TestResults to update.
     */
    limit?: number
  }

  /**
   * TestResult updateManyAndReturn
   */
  export type TestResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * The data used to update TestResults.
     */
    data: XOR<TestResultUpdateManyMutationInput, TestResultUncheckedUpdateManyInput>
    /**
     * Filter which TestResults to update
     */
    where?: TestResultWhereInput
    /**
     * Limit how many TestResults to update.
     */
    limit?: number
  }

  /**
   * TestResult upsert
   */
  export type TestResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * The filter to search for the TestResult to update in case it exists.
     */
    where: TestResultWhereUniqueInput
    /**
     * In case the TestResult found by the `where` argument doesn't exist, create a new TestResult with this data.
     */
    create: XOR<TestResultCreateInput, TestResultUncheckedCreateInput>
    /**
     * In case the TestResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestResultUpdateInput, TestResultUncheckedUpdateInput>
  }

  /**
   * TestResult delete
   */
  export type TestResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Filter which TestResult to delete.
     */
    where: TestResultWhereUniqueInput
  }

  /**
   * TestResult deleteMany
   */
  export type TestResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestResults to delete
     */
    where?: TestResultWhereInput
    /**
     * Limit how many TestResults to delete.
     */
    limit?: number
  }

  /**
   * TestResult without action
   */
  export type TestResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
  }


  /**
   * Model LamportCounter
   */

  export type AggregateLamportCounter = {
    _count: LamportCounterCountAggregateOutputType | null
    _avg: LamportCounterAvgAggregateOutputType | null
    _sum: LamportCounterSumAggregateOutputType | null
    _min: LamportCounterMinAggregateOutputType | null
    _max: LamportCounterMaxAggregateOutputType | null
  }

  export type LamportCounterAvgAggregateOutputType = {
    id: number | null
    currentValue: number | null
    lastReceiptId: number | null
  }

  export type LamportCounterSumAggregateOutputType = {
    id: number | null
    currentValue: number | null
    lastReceiptId: number | null
  }

  export type LamportCounterMinAggregateOutputType = {
    id: number | null
    currentValue: number | null
    lastUpdated: Date | null
    lastReceiptId: number | null
  }

  export type LamportCounterMaxAggregateOutputType = {
    id: number | null
    currentValue: number | null
    lastUpdated: Date | null
    lastReceiptId: number | null
  }

  export type LamportCounterCountAggregateOutputType = {
    id: number
    currentValue: number
    lastUpdated: number
    lastReceiptId: number
    metadata: number
    _all: number
  }


  export type LamportCounterAvgAggregateInputType = {
    id?: true
    currentValue?: true
    lastReceiptId?: true
  }

  export type LamportCounterSumAggregateInputType = {
    id?: true
    currentValue?: true
    lastReceiptId?: true
  }

  export type LamportCounterMinAggregateInputType = {
    id?: true
    currentValue?: true
    lastUpdated?: true
    lastReceiptId?: true
  }

  export type LamportCounterMaxAggregateInputType = {
    id?: true
    currentValue?: true
    lastUpdated?: true
    lastReceiptId?: true
  }

  export type LamportCounterCountAggregateInputType = {
    id?: true
    currentValue?: true
    lastUpdated?: true
    lastReceiptId?: true
    metadata?: true
    _all?: true
  }

  export type LamportCounterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LamportCounter to aggregate.
     */
    where?: LamportCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LamportCounters to fetch.
     */
    orderBy?: LamportCounterOrderByWithRelationInput | LamportCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LamportCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LamportCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LamportCounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LamportCounters
    **/
    _count?: true | LamportCounterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LamportCounterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LamportCounterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LamportCounterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LamportCounterMaxAggregateInputType
  }

  export type GetLamportCounterAggregateType<T extends LamportCounterAggregateArgs> = {
        [P in keyof T & keyof AggregateLamportCounter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLamportCounter[P]>
      : GetScalarType<T[P], AggregateLamportCounter[P]>
  }




  export type LamportCounterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LamportCounterWhereInput
    orderBy?: LamportCounterOrderByWithAggregationInput | LamportCounterOrderByWithAggregationInput[]
    by: LamportCounterScalarFieldEnum[] | LamportCounterScalarFieldEnum
    having?: LamportCounterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LamportCounterCountAggregateInputType | true
    _avg?: LamportCounterAvgAggregateInputType
    _sum?: LamportCounterSumAggregateInputType
    _min?: LamportCounterMinAggregateInputType
    _max?: LamportCounterMaxAggregateInputType
  }

  export type LamportCounterGroupByOutputType = {
    id: number
    currentValue: number
    lastUpdated: Date
    lastReceiptId: number | null
    metadata: JsonValue | null
    _count: LamportCounterCountAggregateOutputType | null
    _avg: LamportCounterAvgAggregateOutputType | null
    _sum: LamportCounterSumAggregateOutputType | null
    _min: LamportCounterMinAggregateOutputType | null
    _max: LamportCounterMaxAggregateOutputType | null
  }

  type GetLamportCounterGroupByPayload<T extends LamportCounterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LamportCounterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LamportCounterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LamportCounterGroupByOutputType[P]>
            : GetScalarType<T[P], LamportCounterGroupByOutputType[P]>
        }
      >
    >


  export type LamportCounterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currentValue?: boolean
    lastUpdated?: boolean
    lastReceiptId?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["lamportCounter"]>

  export type LamportCounterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currentValue?: boolean
    lastUpdated?: boolean
    lastReceiptId?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["lamportCounter"]>

  export type LamportCounterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currentValue?: boolean
    lastUpdated?: boolean
    lastReceiptId?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["lamportCounter"]>

  export type LamportCounterSelectScalar = {
    id?: boolean
    currentValue?: boolean
    lastUpdated?: boolean
    lastReceiptId?: boolean
    metadata?: boolean
  }

  export type LamportCounterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "currentValue" | "lastUpdated" | "lastReceiptId" | "metadata", ExtArgs["result"]["lamportCounter"]>

  export type $LamportCounterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LamportCounter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      currentValue: number
      lastUpdated: Date
      lastReceiptId: number | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["lamportCounter"]>
    composites: {}
  }

  type LamportCounterGetPayload<S extends boolean | null | undefined | LamportCounterDefaultArgs> = $Result.GetResult<Prisma.$LamportCounterPayload, S>

  type LamportCounterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LamportCounterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LamportCounterCountAggregateInputType | true
    }

  export interface LamportCounterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LamportCounter'], meta: { name: 'LamportCounter' } }
    /**
     * Find zero or one LamportCounter that matches the filter.
     * @param {LamportCounterFindUniqueArgs} args - Arguments to find a LamportCounter
     * @example
     * // Get one LamportCounter
     * const lamportCounter = await prisma.lamportCounter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LamportCounterFindUniqueArgs>(args: SelectSubset<T, LamportCounterFindUniqueArgs<ExtArgs>>): Prisma__LamportCounterClient<$Result.GetResult<Prisma.$LamportCounterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LamportCounter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LamportCounterFindUniqueOrThrowArgs} args - Arguments to find a LamportCounter
     * @example
     * // Get one LamportCounter
     * const lamportCounter = await prisma.lamportCounter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LamportCounterFindUniqueOrThrowArgs>(args: SelectSubset<T, LamportCounterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LamportCounterClient<$Result.GetResult<Prisma.$LamportCounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LamportCounter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LamportCounterFindFirstArgs} args - Arguments to find a LamportCounter
     * @example
     * // Get one LamportCounter
     * const lamportCounter = await prisma.lamportCounter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LamportCounterFindFirstArgs>(args?: SelectSubset<T, LamportCounterFindFirstArgs<ExtArgs>>): Prisma__LamportCounterClient<$Result.GetResult<Prisma.$LamportCounterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LamportCounter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LamportCounterFindFirstOrThrowArgs} args - Arguments to find a LamportCounter
     * @example
     * // Get one LamportCounter
     * const lamportCounter = await prisma.lamportCounter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LamportCounterFindFirstOrThrowArgs>(args?: SelectSubset<T, LamportCounterFindFirstOrThrowArgs<ExtArgs>>): Prisma__LamportCounterClient<$Result.GetResult<Prisma.$LamportCounterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LamportCounters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LamportCounterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LamportCounters
     * const lamportCounters = await prisma.lamportCounter.findMany()
     * 
     * // Get first 10 LamportCounters
     * const lamportCounters = await prisma.lamportCounter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lamportCounterWithIdOnly = await prisma.lamportCounter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LamportCounterFindManyArgs>(args?: SelectSubset<T, LamportCounterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LamportCounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LamportCounter.
     * @param {LamportCounterCreateArgs} args - Arguments to create a LamportCounter.
     * @example
     * // Create one LamportCounter
     * const LamportCounter = await prisma.lamportCounter.create({
     *   data: {
     *     // ... data to create a LamportCounter
     *   }
     * })
     * 
     */
    create<T extends LamportCounterCreateArgs>(args: SelectSubset<T, LamportCounterCreateArgs<ExtArgs>>): Prisma__LamportCounterClient<$Result.GetResult<Prisma.$LamportCounterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LamportCounters.
     * @param {LamportCounterCreateManyArgs} args - Arguments to create many LamportCounters.
     * @example
     * // Create many LamportCounters
     * const lamportCounter = await prisma.lamportCounter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LamportCounterCreateManyArgs>(args?: SelectSubset<T, LamportCounterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LamportCounters and returns the data saved in the database.
     * @param {LamportCounterCreateManyAndReturnArgs} args - Arguments to create many LamportCounters.
     * @example
     * // Create many LamportCounters
     * const lamportCounter = await prisma.lamportCounter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LamportCounters and only return the `id`
     * const lamportCounterWithIdOnly = await prisma.lamportCounter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LamportCounterCreateManyAndReturnArgs>(args?: SelectSubset<T, LamportCounterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LamportCounterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LamportCounter.
     * @param {LamportCounterDeleteArgs} args - Arguments to delete one LamportCounter.
     * @example
     * // Delete one LamportCounter
     * const LamportCounter = await prisma.lamportCounter.delete({
     *   where: {
     *     // ... filter to delete one LamportCounter
     *   }
     * })
     * 
     */
    delete<T extends LamportCounterDeleteArgs>(args: SelectSubset<T, LamportCounterDeleteArgs<ExtArgs>>): Prisma__LamportCounterClient<$Result.GetResult<Prisma.$LamportCounterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LamportCounter.
     * @param {LamportCounterUpdateArgs} args - Arguments to update one LamportCounter.
     * @example
     * // Update one LamportCounter
     * const lamportCounter = await prisma.lamportCounter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LamportCounterUpdateArgs>(args: SelectSubset<T, LamportCounterUpdateArgs<ExtArgs>>): Prisma__LamportCounterClient<$Result.GetResult<Prisma.$LamportCounterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LamportCounters.
     * @param {LamportCounterDeleteManyArgs} args - Arguments to filter LamportCounters to delete.
     * @example
     * // Delete a few LamportCounters
     * const { count } = await prisma.lamportCounter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LamportCounterDeleteManyArgs>(args?: SelectSubset<T, LamportCounterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LamportCounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LamportCounterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LamportCounters
     * const lamportCounter = await prisma.lamportCounter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LamportCounterUpdateManyArgs>(args: SelectSubset<T, LamportCounterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LamportCounters and returns the data updated in the database.
     * @param {LamportCounterUpdateManyAndReturnArgs} args - Arguments to update many LamportCounters.
     * @example
     * // Update many LamportCounters
     * const lamportCounter = await prisma.lamportCounter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LamportCounters and only return the `id`
     * const lamportCounterWithIdOnly = await prisma.lamportCounter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LamportCounterUpdateManyAndReturnArgs>(args: SelectSubset<T, LamportCounterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LamportCounterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LamportCounter.
     * @param {LamportCounterUpsertArgs} args - Arguments to update or create a LamportCounter.
     * @example
     * // Update or create a LamportCounter
     * const lamportCounter = await prisma.lamportCounter.upsert({
     *   create: {
     *     // ... data to create a LamportCounter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LamportCounter we want to update
     *   }
     * })
     */
    upsert<T extends LamportCounterUpsertArgs>(args: SelectSubset<T, LamportCounterUpsertArgs<ExtArgs>>): Prisma__LamportCounterClient<$Result.GetResult<Prisma.$LamportCounterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LamportCounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LamportCounterCountArgs} args - Arguments to filter LamportCounters to count.
     * @example
     * // Count the number of LamportCounters
     * const count = await prisma.lamportCounter.count({
     *   where: {
     *     // ... the filter for the LamportCounters we want to count
     *   }
     * })
    **/
    count<T extends LamportCounterCountArgs>(
      args?: Subset<T, LamportCounterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LamportCounterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LamportCounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LamportCounterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LamportCounterAggregateArgs>(args: Subset<T, LamportCounterAggregateArgs>): Prisma.PrismaPromise<GetLamportCounterAggregateType<T>>

    /**
     * Group by LamportCounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LamportCounterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LamportCounterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LamportCounterGroupByArgs['orderBy'] }
        : { orderBy?: LamportCounterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LamportCounterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLamportCounterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LamportCounter model
   */
  readonly fields: LamportCounterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LamportCounter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LamportCounterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LamportCounter model
   */
  interface LamportCounterFieldRefs {
    readonly id: FieldRef<"LamportCounter", 'Int'>
    readonly currentValue: FieldRef<"LamportCounter", 'Int'>
    readonly lastUpdated: FieldRef<"LamportCounter", 'DateTime'>
    readonly lastReceiptId: FieldRef<"LamportCounter", 'Int'>
    readonly metadata: FieldRef<"LamportCounter", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * LamportCounter findUnique
   */
  export type LamportCounterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportCounter
     */
    select?: LamportCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LamportCounter
     */
    omit?: LamportCounterOmit<ExtArgs> | null
    /**
     * Filter, which LamportCounter to fetch.
     */
    where: LamportCounterWhereUniqueInput
  }

  /**
   * LamportCounter findUniqueOrThrow
   */
  export type LamportCounterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportCounter
     */
    select?: LamportCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LamportCounter
     */
    omit?: LamportCounterOmit<ExtArgs> | null
    /**
     * Filter, which LamportCounter to fetch.
     */
    where: LamportCounterWhereUniqueInput
  }

  /**
   * LamportCounter findFirst
   */
  export type LamportCounterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportCounter
     */
    select?: LamportCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LamportCounter
     */
    omit?: LamportCounterOmit<ExtArgs> | null
    /**
     * Filter, which LamportCounter to fetch.
     */
    where?: LamportCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LamportCounters to fetch.
     */
    orderBy?: LamportCounterOrderByWithRelationInput | LamportCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LamportCounters.
     */
    cursor?: LamportCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LamportCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LamportCounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LamportCounters.
     */
    distinct?: LamportCounterScalarFieldEnum | LamportCounterScalarFieldEnum[]
  }

  /**
   * LamportCounter findFirstOrThrow
   */
  export type LamportCounterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportCounter
     */
    select?: LamportCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LamportCounter
     */
    omit?: LamportCounterOmit<ExtArgs> | null
    /**
     * Filter, which LamportCounter to fetch.
     */
    where?: LamportCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LamportCounters to fetch.
     */
    orderBy?: LamportCounterOrderByWithRelationInput | LamportCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LamportCounters.
     */
    cursor?: LamportCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LamportCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LamportCounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LamportCounters.
     */
    distinct?: LamportCounterScalarFieldEnum | LamportCounterScalarFieldEnum[]
  }

  /**
   * LamportCounter findMany
   */
  export type LamportCounterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportCounter
     */
    select?: LamportCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LamportCounter
     */
    omit?: LamportCounterOmit<ExtArgs> | null
    /**
     * Filter, which LamportCounters to fetch.
     */
    where?: LamportCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LamportCounters to fetch.
     */
    orderBy?: LamportCounterOrderByWithRelationInput | LamportCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LamportCounters.
     */
    cursor?: LamportCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LamportCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LamportCounters.
     */
    skip?: number
    distinct?: LamportCounterScalarFieldEnum | LamportCounterScalarFieldEnum[]
  }

  /**
   * LamportCounter create
   */
  export type LamportCounterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportCounter
     */
    select?: LamportCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LamportCounter
     */
    omit?: LamportCounterOmit<ExtArgs> | null
    /**
     * The data needed to create a LamportCounter.
     */
    data?: XOR<LamportCounterCreateInput, LamportCounterUncheckedCreateInput>
  }

  /**
   * LamportCounter createMany
   */
  export type LamportCounterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LamportCounters.
     */
    data: LamportCounterCreateManyInput | LamportCounterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LamportCounter createManyAndReturn
   */
  export type LamportCounterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportCounter
     */
    select?: LamportCounterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LamportCounter
     */
    omit?: LamportCounterOmit<ExtArgs> | null
    /**
     * The data used to create many LamportCounters.
     */
    data: LamportCounterCreateManyInput | LamportCounterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LamportCounter update
   */
  export type LamportCounterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportCounter
     */
    select?: LamportCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LamportCounter
     */
    omit?: LamportCounterOmit<ExtArgs> | null
    /**
     * The data needed to update a LamportCounter.
     */
    data: XOR<LamportCounterUpdateInput, LamportCounterUncheckedUpdateInput>
    /**
     * Choose, which LamportCounter to update.
     */
    where: LamportCounterWhereUniqueInput
  }

  /**
   * LamportCounter updateMany
   */
  export type LamportCounterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LamportCounters.
     */
    data: XOR<LamportCounterUpdateManyMutationInput, LamportCounterUncheckedUpdateManyInput>
    /**
     * Filter which LamportCounters to update
     */
    where?: LamportCounterWhereInput
    /**
     * Limit how many LamportCounters to update.
     */
    limit?: number
  }

  /**
   * LamportCounter updateManyAndReturn
   */
  export type LamportCounterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportCounter
     */
    select?: LamportCounterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LamportCounter
     */
    omit?: LamportCounterOmit<ExtArgs> | null
    /**
     * The data used to update LamportCounters.
     */
    data: XOR<LamportCounterUpdateManyMutationInput, LamportCounterUncheckedUpdateManyInput>
    /**
     * Filter which LamportCounters to update
     */
    where?: LamportCounterWhereInput
    /**
     * Limit how many LamportCounters to update.
     */
    limit?: number
  }

  /**
   * LamportCounter upsert
   */
  export type LamportCounterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportCounter
     */
    select?: LamportCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LamportCounter
     */
    omit?: LamportCounterOmit<ExtArgs> | null
    /**
     * The filter to search for the LamportCounter to update in case it exists.
     */
    where: LamportCounterWhereUniqueInput
    /**
     * In case the LamportCounter found by the `where` argument doesn't exist, create a new LamportCounter with this data.
     */
    create: XOR<LamportCounterCreateInput, LamportCounterUncheckedCreateInput>
    /**
     * In case the LamportCounter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LamportCounterUpdateInput, LamportCounterUncheckedUpdateInput>
  }

  /**
   * LamportCounter delete
   */
  export type LamportCounterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportCounter
     */
    select?: LamportCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LamportCounter
     */
    omit?: LamportCounterOmit<ExtArgs> | null
    /**
     * Filter which LamportCounter to delete.
     */
    where: LamportCounterWhereUniqueInput
  }

  /**
   * LamportCounter deleteMany
   */
  export type LamportCounterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LamportCounters to delete
     */
    where?: LamportCounterWhereInput
    /**
     * Limit how many LamportCounters to delete.
     */
    limit?: number
  }

  /**
   * LamportCounter without action
   */
  export type LamportCounterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LamportCounter
     */
    select?: LamportCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LamportCounter
     */
    omit?: LamportCounterOmit<ExtArgs> | null
  }


  /**
   * Model BENReceipt
   */

  export type AggregateBENReceipt = {
    _count: BENReceiptCountAggregateOutputType | null
    _avg: BENReceiptAvgAggregateOutputType | null
    _sum: BENReceiptSumAggregateOutputType | null
    _min: BENReceiptMinAggregateOutputType | null
    _max: BENReceiptMaxAggregateOutputType | null
  }

  export type BENReceiptAvgAggregateOutputType = {
    id: number | null
    lamportClock: number | null
    userId: number | null
  }

  export type BENReceiptSumAggregateOutputType = {
    id: number | null
    lamportClock: number | null
    userId: number | null
  }

  export type BENReceiptMinAggregateOutputType = {
    id: number | null
    receiptType: $Enums.ReceiptType | null
    lamportClock: number | null
    realTimestamp: Date | null
    userId: number | null
    persona: $Enums.BENPersona | null
    track: $Enums.TrackType | null
    digest: string | null
    previousDigest: string | null
    baselineDigest: string | null
    witnessModel: string | null
    witnessSignature: string | null
    createdAt: Date | null
  }

  export type BENReceiptMaxAggregateOutputType = {
    id: number | null
    receiptType: $Enums.ReceiptType | null
    lamportClock: number | null
    realTimestamp: Date | null
    userId: number | null
    persona: $Enums.BENPersona | null
    track: $Enums.TrackType | null
    digest: string | null
    previousDigest: string | null
    baselineDigest: string | null
    witnessModel: string | null
    witnessSignature: string | null
    createdAt: Date | null
  }

  export type BENReceiptCountAggregateOutputType = {
    id: number
    receiptType: number
    lamportClock: number
    realTimestamp: number
    userId: number
    persona: number
    track: number
    payload: number
    digest: number
    previousDigest: number
    baselineDigest: number
    witnessModel: number
    witnessSignature: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type BENReceiptAvgAggregateInputType = {
    id?: true
    lamportClock?: true
    userId?: true
  }

  export type BENReceiptSumAggregateInputType = {
    id?: true
    lamportClock?: true
    userId?: true
  }

  export type BENReceiptMinAggregateInputType = {
    id?: true
    receiptType?: true
    lamportClock?: true
    realTimestamp?: true
    userId?: true
    persona?: true
    track?: true
    digest?: true
    previousDigest?: true
    baselineDigest?: true
    witnessModel?: true
    witnessSignature?: true
    createdAt?: true
  }

  export type BENReceiptMaxAggregateInputType = {
    id?: true
    receiptType?: true
    lamportClock?: true
    realTimestamp?: true
    userId?: true
    persona?: true
    track?: true
    digest?: true
    previousDigest?: true
    baselineDigest?: true
    witnessModel?: true
    witnessSignature?: true
    createdAt?: true
  }

  export type BENReceiptCountAggregateInputType = {
    id?: true
    receiptType?: true
    lamportClock?: true
    realTimestamp?: true
    userId?: true
    persona?: true
    track?: true
    payload?: true
    digest?: true
    previousDigest?: true
    baselineDigest?: true
    witnessModel?: true
    witnessSignature?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type BENReceiptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BENReceipt to aggregate.
     */
    where?: BENReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BENReceipts to fetch.
     */
    orderBy?: BENReceiptOrderByWithRelationInput | BENReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BENReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BENReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BENReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BENReceipts
    **/
    _count?: true | BENReceiptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BENReceiptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BENReceiptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BENReceiptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BENReceiptMaxAggregateInputType
  }

  export type GetBENReceiptAggregateType<T extends BENReceiptAggregateArgs> = {
        [P in keyof T & keyof AggregateBENReceipt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBENReceipt[P]>
      : GetScalarType<T[P], AggregateBENReceipt[P]>
  }




  export type BENReceiptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BENReceiptWhereInput
    orderBy?: BENReceiptOrderByWithAggregationInput | BENReceiptOrderByWithAggregationInput[]
    by: BENReceiptScalarFieldEnum[] | BENReceiptScalarFieldEnum
    having?: BENReceiptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BENReceiptCountAggregateInputType | true
    _avg?: BENReceiptAvgAggregateInputType
    _sum?: BENReceiptSumAggregateInputType
    _min?: BENReceiptMinAggregateInputType
    _max?: BENReceiptMaxAggregateInputType
  }

  export type BENReceiptGroupByOutputType = {
    id: number
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp: Date
    userId: number | null
    persona: $Enums.BENPersona
    track: $Enums.TrackType | null
    payload: JsonValue
    digest: string
    previousDigest: string | null
    baselineDigest: string | null
    witnessModel: string | null
    witnessSignature: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: BENReceiptCountAggregateOutputType | null
    _avg: BENReceiptAvgAggregateOutputType | null
    _sum: BENReceiptSumAggregateOutputType | null
    _min: BENReceiptMinAggregateOutputType | null
    _max: BENReceiptMaxAggregateOutputType | null
  }

  type GetBENReceiptGroupByPayload<T extends BENReceiptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BENReceiptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BENReceiptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BENReceiptGroupByOutputType[P]>
            : GetScalarType<T[P], BENReceiptGroupByOutputType[P]>
        }
      >
    >


  export type BENReceiptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptType?: boolean
    lamportClock?: boolean
    realTimestamp?: boolean
    userId?: boolean
    persona?: boolean
    track?: boolean
    payload?: boolean
    digest?: boolean
    previousDigest?: boolean
    baselineDigest?: boolean
    witnessModel?: boolean
    witnessSignature?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | BENReceipt$userArgs<ExtArgs>
    handoffsFrom?: boolean | BENReceipt$handoffsFromArgs<ExtArgs>
    handoffsTo?: boolean | BENReceipt$handoffsToArgs<ExtArgs>
    _count?: boolean | BENReceiptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bENReceipt"]>

  export type BENReceiptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptType?: boolean
    lamportClock?: boolean
    realTimestamp?: boolean
    userId?: boolean
    persona?: boolean
    track?: boolean
    payload?: boolean
    digest?: boolean
    previousDigest?: boolean
    baselineDigest?: boolean
    witnessModel?: boolean
    witnessSignature?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | BENReceipt$userArgs<ExtArgs>
  }, ExtArgs["result"]["bENReceipt"]>

  export type BENReceiptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptType?: boolean
    lamportClock?: boolean
    realTimestamp?: boolean
    userId?: boolean
    persona?: boolean
    track?: boolean
    payload?: boolean
    digest?: boolean
    previousDigest?: boolean
    baselineDigest?: boolean
    witnessModel?: boolean
    witnessSignature?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | BENReceipt$userArgs<ExtArgs>
  }, ExtArgs["result"]["bENReceipt"]>

  export type BENReceiptSelectScalar = {
    id?: boolean
    receiptType?: boolean
    lamportClock?: boolean
    realTimestamp?: boolean
    userId?: boolean
    persona?: boolean
    track?: boolean
    payload?: boolean
    digest?: boolean
    previousDigest?: boolean
    baselineDigest?: boolean
    witnessModel?: boolean
    witnessSignature?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type BENReceiptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "receiptType" | "lamportClock" | "realTimestamp" | "userId" | "persona" | "track" | "payload" | "digest" | "previousDigest" | "baselineDigest" | "witnessModel" | "witnessSignature" | "metadata" | "createdAt", ExtArgs["result"]["bENReceipt"]>
  export type BENReceiptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BENReceipt$userArgs<ExtArgs>
    handoffsFrom?: boolean | BENReceipt$handoffsFromArgs<ExtArgs>
    handoffsTo?: boolean | BENReceipt$handoffsToArgs<ExtArgs>
    _count?: boolean | BENReceiptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BENReceiptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BENReceipt$userArgs<ExtArgs>
  }
  export type BENReceiptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BENReceipt$userArgs<ExtArgs>
  }

  export type $BENReceiptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BENReceipt"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      handoffsFrom: Prisma.$TriTrackHandoffPayload<ExtArgs>[]
      handoffsTo: Prisma.$TriTrackHandoffPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      receiptType: $Enums.ReceiptType
      lamportClock: number
      realTimestamp: Date
      userId: number | null
      persona: $Enums.BENPersona
      track: $Enums.TrackType | null
      payload: Prisma.JsonValue
      digest: string
      previousDigest: string | null
      baselineDigest: string | null
      witnessModel: string | null
      witnessSignature: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["bENReceipt"]>
    composites: {}
  }

  type BENReceiptGetPayload<S extends boolean | null | undefined | BENReceiptDefaultArgs> = $Result.GetResult<Prisma.$BENReceiptPayload, S>

  type BENReceiptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BENReceiptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BENReceiptCountAggregateInputType | true
    }

  export interface BENReceiptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BENReceipt'], meta: { name: 'BENReceipt' } }
    /**
     * Find zero or one BENReceipt that matches the filter.
     * @param {BENReceiptFindUniqueArgs} args - Arguments to find a BENReceipt
     * @example
     * // Get one BENReceipt
     * const bENReceipt = await prisma.bENReceipt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BENReceiptFindUniqueArgs>(args: SelectSubset<T, BENReceiptFindUniqueArgs<ExtArgs>>): Prisma__BENReceiptClient<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BENReceipt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BENReceiptFindUniqueOrThrowArgs} args - Arguments to find a BENReceipt
     * @example
     * // Get one BENReceipt
     * const bENReceipt = await prisma.bENReceipt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BENReceiptFindUniqueOrThrowArgs>(args: SelectSubset<T, BENReceiptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BENReceiptClient<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BENReceipt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENReceiptFindFirstArgs} args - Arguments to find a BENReceipt
     * @example
     * // Get one BENReceipt
     * const bENReceipt = await prisma.bENReceipt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BENReceiptFindFirstArgs>(args?: SelectSubset<T, BENReceiptFindFirstArgs<ExtArgs>>): Prisma__BENReceiptClient<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BENReceipt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENReceiptFindFirstOrThrowArgs} args - Arguments to find a BENReceipt
     * @example
     * // Get one BENReceipt
     * const bENReceipt = await prisma.bENReceipt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BENReceiptFindFirstOrThrowArgs>(args?: SelectSubset<T, BENReceiptFindFirstOrThrowArgs<ExtArgs>>): Prisma__BENReceiptClient<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BENReceipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENReceiptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BENReceipts
     * const bENReceipts = await prisma.bENReceipt.findMany()
     * 
     * // Get first 10 BENReceipts
     * const bENReceipts = await prisma.bENReceipt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bENReceiptWithIdOnly = await prisma.bENReceipt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BENReceiptFindManyArgs>(args?: SelectSubset<T, BENReceiptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BENReceipt.
     * @param {BENReceiptCreateArgs} args - Arguments to create a BENReceipt.
     * @example
     * // Create one BENReceipt
     * const BENReceipt = await prisma.bENReceipt.create({
     *   data: {
     *     // ... data to create a BENReceipt
     *   }
     * })
     * 
     */
    create<T extends BENReceiptCreateArgs>(args: SelectSubset<T, BENReceiptCreateArgs<ExtArgs>>): Prisma__BENReceiptClient<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BENReceipts.
     * @param {BENReceiptCreateManyArgs} args - Arguments to create many BENReceipts.
     * @example
     * // Create many BENReceipts
     * const bENReceipt = await prisma.bENReceipt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BENReceiptCreateManyArgs>(args?: SelectSubset<T, BENReceiptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BENReceipts and returns the data saved in the database.
     * @param {BENReceiptCreateManyAndReturnArgs} args - Arguments to create many BENReceipts.
     * @example
     * // Create many BENReceipts
     * const bENReceipt = await prisma.bENReceipt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BENReceipts and only return the `id`
     * const bENReceiptWithIdOnly = await prisma.bENReceipt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BENReceiptCreateManyAndReturnArgs>(args?: SelectSubset<T, BENReceiptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BENReceipt.
     * @param {BENReceiptDeleteArgs} args - Arguments to delete one BENReceipt.
     * @example
     * // Delete one BENReceipt
     * const BENReceipt = await prisma.bENReceipt.delete({
     *   where: {
     *     // ... filter to delete one BENReceipt
     *   }
     * })
     * 
     */
    delete<T extends BENReceiptDeleteArgs>(args: SelectSubset<T, BENReceiptDeleteArgs<ExtArgs>>): Prisma__BENReceiptClient<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BENReceipt.
     * @param {BENReceiptUpdateArgs} args - Arguments to update one BENReceipt.
     * @example
     * // Update one BENReceipt
     * const bENReceipt = await prisma.bENReceipt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BENReceiptUpdateArgs>(args: SelectSubset<T, BENReceiptUpdateArgs<ExtArgs>>): Prisma__BENReceiptClient<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BENReceipts.
     * @param {BENReceiptDeleteManyArgs} args - Arguments to filter BENReceipts to delete.
     * @example
     * // Delete a few BENReceipts
     * const { count } = await prisma.bENReceipt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BENReceiptDeleteManyArgs>(args?: SelectSubset<T, BENReceiptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BENReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENReceiptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BENReceipts
     * const bENReceipt = await prisma.bENReceipt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BENReceiptUpdateManyArgs>(args: SelectSubset<T, BENReceiptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BENReceipts and returns the data updated in the database.
     * @param {BENReceiptUpdateManyAndReturnArgs} args - Arguments to update many BENReceipts.
     * @example
     * // Update many BENReceipts
     * const bENReceipt = await prisma.bENReceipt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BENReceipts and only return the `id`
     * const bENReceiptWithIdOnly = await prisma.bENReceipt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BENReceiptUpdateManyAndReturnArgs>(args: SelectSubset<T, BENReceiptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BENReceipt.
     * @param {BENReceiptUpsertArgs} args - Arguments to update or create a BENReceipt.
     * @example
     * // Update or create a BENReceipt
     * const bENReceipt = await prisma.bENReceipt.upsert({
     *   create: {
     *     // ... data to create a BENReceipt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BENReceipt we want to update
     *   }
     * })
     */
    upsert<T extends BENReceiptUpsertArgs>(args: SelectSubset<T, BENReceiptUpsertArgs<ExtArgs>>): Prisma__BENReceiptClient<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BENReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENReceiptCountArgs} args - Arguments to filter BENReceipts to count.
     * @example
     * // Count the number of BENReceipts
     * const count = await prisma.bENReceipt.count({
     *   where: {
     *     // ... the filter for the BENReceipts we want to count
     *   }
     * })
    **/
    count<T extends BENReceiptCountArgs>(
      args?: Subset<T, BENReceiptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BENReceiptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BENReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENReceiptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BENReceiptAggregateArgs>(args: Subset<T, BENReceiptAggregateArgs>): Prisma.PrismaPromise<GetBENReceiptAggregateType<T>>

    /**
     * Group by BENReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENReceiptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BENReceiptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BENReceiptGroupByArgs['orderBy'] }
        : { orderBy?: BENReceiptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BENReceiptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBENReceiptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BENReceipt model
   */
  readonly fields: BENReceiptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BENReceipt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BENReceiptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends BENReceipt$userArgs<ExtArgs> = {}>(args?: Subset<T, BENReceipt$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    handoffsFrom<T extends BENReceipt$handoffsFromArgs<ExtArgs> = {}>(args?: Subset<T, BENReceipt$handoffsFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    handoffsTo<T extends BENReceipt$handoffsToArgs<ExtArgs> = {}>(args?: Subset<T, BENReceipt$handoffsToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BENReceipt model
   */
  interface BENReceiptFieldRefs {
    readonly id: FieldRef<"BENReceipt", 'Int'>
    readonly receiptType: FieldRef<"BENReceipt", 'ReceiptType'>
    readonly lamportClock: FieldRef<"BENReceipt", 'Int'>
    readonly realTimestamp: FieldRef<"BENReceipt", 'DateTime'>
    readonly userId: FieldRef<"BENReceipt", 'Int'>
    readonly persona: FieldRef<"BENReceipt", 'BENPersona'>
    readonly track: FieldRef<"BENReceipt", 'TrackType'>
    readonly payload: FieldRef<"BENReceipt", 'Json'>
    readonly digest: FieldRef<"BENReceipt", 'String'>
    readonly previousDigest: FieldRef<"BENReceipt", 'String'>
    readonly baselineDigest: FieldRef<"BENReceipt", 'String'>
    readonly witnessModel: FieldRef<"BENReceipt", 'String'>
    readonly witnessSignature: FieldRef<"BENReceipt", 'String'>
    readonly metadata: FieldRef<"BENReceipt", 'Json'>
    readonly createdAt: FieldRef<"BENReceipt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BENReceipt findUnique
   */
  export type BENReceiptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    /**
     * Filter, which BENReceipt to fetch.
     */
    where: BENReceiptWhereUniqueInput
  }

  /**
   * BENReceipt findUniqueOrThrow
   */
  export type BENReceiptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    /**
     * Filter, which BENReceipt to fetch.
     */
    where: BENReceiptWhereUniqueInput
  }

  /**
   * BENReceipt findFirst
   */
  export type BENReceiptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    /**
     * Filter, which BENReceipt to fetch.
     */
    where?: BENReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BENReceipts to fetch.
     */
    orderBy?: BENReceiptOrderByWithRelationInput | BENReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BENReceipts.
     */
    cursor?: BENReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BENReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BENReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BENReceipts.
     */
    distinct?: BENReceiptScalarFieldEnum | BENReceiptScalarFieldEnum[]
  }

  /**
   * BENReceipt findFirstOrThrow
   */
  export type BENReceiptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    /**
     * Filter, which BENReceipt to fetch.
     */
    where?: BENReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BENReceipts to fetch.
     */
    orderBy?: BENReceiptOrderByWithRelationInput | BENReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BENReceipts.
     */
    cursor?: BENReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BENReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BENReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BENReceipts.
     */
    distinct?: BENReceiptScalarFieldEnum | BENReceiptScalarFieldEnum[]
  }

  /**
   * BENReceipt findMany
   */
  export type BENReceiptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    /**
     * Filter, which BENReceipts to fetch.
     */
    where?: BENReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BENReceipts to fetch.
     */
    orderBy?: BENReceiptOrderByWithRelationInput | BENReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BENReceipts.
     */
    cursor?: BENReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BENReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BENReceipts.
     */
    skip?: number
    distinct?: BENReceiptScalarFieldEnum | BENReceiptScalarFieldEnum[]
  }

  /**
   * BENReceipt create
   */
  export type BENReceiptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    /**
     * The data needed to create a BENReceipt.
     */
    data: XOR<BENReceiptCreateInput, BENReceiptUncheckedCreateInput>
  }

  /**
   * BENReceipt createMany
   */
  export type BENReceiptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BENReceipts.
     */
    data: BENReceiptCreateManyInput | BENReceiptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BENReceipt createManyAndReturn
   */
  export type BENReceiptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * The data used to create many BENReceipts.
     */
    data: BENReceiptCreateManyInput | BENReceiptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BENReceipt update
   */
  export type BENReceiptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    /**
     * The data needed to update a BENReceipt.
     */
    data: XOR<BENReceiptUpdateInput, BENReceiptUncheckedUpdateInput>
    /**
     * Choose, which BENReceipt to update.
     */
    where: BENReceiptWhereUniqueInput
  }

  /**
   * BENReceipt updateMany
   */
  export type BENReceiptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BENReceipts.
     */
    data: XOR<BENReceiptUpdateManyMutationInput, BENReceiptUncheckedUpdateManyInput>
    /**
     * Filter which BENReceipts to update
     */
    where?: BENReceiptWhereInput
    /**
     * Limit how many BENReceipts to update.
     */
    limit?: number
  }

  /**
   * BENReceipt updateManyAndReturn
   */
  export type BENReceiptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * The data used to update BENReceipts.
     */
    data: XOR<BENReceiptUpdateManyMutationInput, BENReceiptUncheckedUpdateManyInput>
    /**
     * Filter which BENReceipts to update
     */
    where?: BENReceiptWhereInput
    /**
     * Limit how many BENReceipts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BENReceipt upsert
   */
  export type BENReceiptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    /**
     * The filter to search for the BENReceipt to update in case it exists.
     */
    where: BENReceiptWhereUniqueInput
    /**
     * In case the BENReceipt found by the `where` argument doesn't exist, create a new BENReceipt with this data.
     */
    create: XOR<BENReceiptCreateInput, BENReceiptUncheckedCreateInput>
    /**
     * In case the BENReceipt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BENReceiptUpdateInput, BENReceiptUncheckedUpdateInput>
  }

  /**
   * BENReceipt delete
   */
  export type BENReceiptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    /**
     * Filter which BENReceipt to delete.
     */
    where: BENReceiptWhereUniqueInput
  }

  /**
   * BENReceipt deleteMany
   */
  export type BENReceiptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BENReceipts to delete
     */
    where?: BENReceiptWhereInput
    /**
     * Limit how many BENReceipts to delete.
     */
    limit?: number
  }

  /**
   * BENReceipt.user
   */
  export type BENReceipt$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * BENReceipt.handoffsFrom
   */
  export type BENReceipt$handoffsFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    where?: TriTrackHandoffWhereInput
    orderBy?: TriTrackHandoffOrderByWithRelationInput | TriTrackHandoffOrderByWithRelationInput[]
    cursor?: TriTrackHandoffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TriTrackHandoffScalarFieldEnum | TriTrackHandoffScalarFieldEnum[]
  }

  /**
   * BENReceipt.handoffsTo
   */
  export type BENReceipt$handoffsToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    where?: TriTrackHandoffWhereInput
    orderBy?: TriTrackHandoffOrderByWithRelationInput | TriTrackHandoffOrderByWithRelationInput[]
    cursor?: TriTrackHandoffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TriTrackHandoffScalarFieldEnum | TriTrackHandoffScalarFieldEnum[]
  }

  /**
   * BENReceipt without action
   */
  export type BENReceiptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
  }


  /**
   * Model BENSession
   */

  export type AggregateBENSession = {
    _count: BENSessionCountAggregateOutputType | null
    _avg: BENSessionAvgAggregateOutputType | null
    _sum: BENSessionSumAggregateOutputType | null
    _min: BENSessionMinAggregateOutputType | null
    _max: BENSessionMaxAggregateOutputType | null
  }

  export type BENSessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    priority: number | null
    duration: number | null
    startLamport: number | null
    endLamport: number | null
  }

  export type BENSessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
    priority: number | null
    duration: number | null
    startLamport: number | null
    endLamport: number | null
  }

  export type BENSessionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    persona: $Enums.BENPersona | null
    priority: number | null
    locked: boolean | null
    startedAt: Date | null
    endedAt: Date | null
    duration: number | null
    startLamport: number | null
    endLamport: number | null
    switchReason: string | null
  }

  export type BENSessionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    persona: $Enums.BENPersona | null
    priority: number | null
    locked: boolean | null
    startedAt: Date | null
    endedAt: Date | null
    duration: number | null
    startLamport: number | null
    endLamport: number | null
    switchReason: string | null
  }

  export type BENSessionCountAggregateOutputType = {
    id: number
    userId: number
    persona: number
    priority: number
    locked: number
    startedAt: number
    endedAt: number
    duration: number
    startLamport: number
    endLamport: number
    switchReason: number
    metadata: number
    _all: number
  }


  export type BENSessionAvgAggregateInputType = {
    id?: true
    userId?: true
    priority?: true
    duration?: true
    startLamport?: true
    endLamport?: true
  }

  export type BENSessionSumAggregateInputType = {
    id?: true
    userId?: true
    priority?: true
    duration?: true
    startLamport?: true
    endLamport?: true
  }

  export type BENSessionMinAggregateInputType = {
    id?: true
    userId?: true
    persona?: true
    priority?: true
    locked?: true
    startedAt?: true
    endedAt?: true
    duration?: true
    startLamport?: true
    endLamport?: true
    switchReason?: true
  }

  export type BENSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    persona?: true
    priority?: true
    locked?: true
    startedAt?: true
    endedAt?: true
    duration?: true
    startLamport?: true
    endLamport?: true
    switchReason?: true
  }

  export type BENSessionCountAggregateInputType = {
    id?: true
    userId?: true
    persona?: true
    priority?: true
    locked?: true
    startedAt?: true
    endedAt?: true
    duration?: true
    startLamport?: true
    endLamport?: true
    switchReason?: true
    metadata?: true
    _all?: true
  }

  export type BENSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BENSession to aggregate.
     */
    where?: BENSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BENSessions to fetch.
     */
    orderBy?: BENSessionOrderByWithRelationInput | BENSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BENSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BENSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BENSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BENSessions
    **/
    _count?: true | BENSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BENSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BENSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BENSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BENSessionMaxAggregateInputType
  }

  export type GetBENSessionAggregateType<T extends BENSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateBENSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBENSession[P]>
      : GetScalarType<T[P], AggregateBENSession[P]>
  }




  export type BENSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BENSessionWhereInput
    orderBy?: BENSessionOrderByWithAggregationInput | BENSessionOrderByWithAggregationInput[]
    by: BENSessionScalarFieldEnum[] | BENSessionScalarFieldEnum
    having?: BENSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BENSessionCountAggregateInputType | true
    _avg?: BENSessionAvgAggregateInputType
    _sum?: BENSessionSumAggregateInputType
    _min?: BENSessionMinAggregateInputType
    _max?: BENSessionMaxAggregateInputType
  }

  export type BENSessionGroupByOutputType = {
    id: number
    userId: number
    persona: $Enums.BENPersona
    priority: number
    locked: boolean
    startedAt: Date
    endedAt: Date | null
    duration: number | null
    startLamport: number
    endLamport: number | null
    switchReason: string | null
    metadata: JsonValue | null
    _count: BENSessionCountAggregateOutputType | null
    _avg: BENSessionAvgAggregateOutputType | null
    _sum: BENSessionSumAggregateOutputType | null
    _min: BENSessionMinAggregateOutputType | null
    _max: BENSessionMaxAggregateOutputType | null
  }

  type GetBENSessionGroupByPayload<T extends BENSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BENSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BENSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BENSessionGroupByOutputType[P]>
            : GetScalarType<T[P], BENSessionGroupByOutputType[P]>
        }
      >
    >


  export type BENSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    persona?: boolean
    priority?: boolean
    locked?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    startLamport?: boolean
    endLamport?: boolean
    switchReason?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bENSession"]>

  export type BENSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    persona?: boolean
    priority?: boolean
    locked?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    startLamport?: boolean
    endLamport?: boolean
    switchReason?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bENSession"]>

  export type BENSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    persona?: boolean
    priority?: boolean
    locked?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    startLamport?: boolean
    endLamport?: boolean
    switchReason?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bENSession"]>

  export type BENSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    persona?: boolean
    priority?: boolean
    locked?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    startLamport?: boolean
    endLamport?: boolean
    switchReason?: boolean
    metadata?: boolean
  }

  export type BENSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "persona" | "priority" | "locked" | "startedAt" | "endedAt" | "duration" | "startLamport" | "endLamport" | "switchReason" | "metadata", ExtArgs["result"]["bENSession"]>
  export type BENSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BENSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BENSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BENSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BENSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      persona: $Enums.BENPersona
      priority: number
      locked: boolean
      startedAt: Date
      endedAt: Date | null
      duration: number | null
      startLamport: number
      endLamport: number | null
      switchReason: string | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["bENSession"]>
    composites: {}
  }

  type BENSessionGetPayload<S extends boolean | null | undefined | BENSessionDefaultArgs> = $Result.GetResult<Prisma.$BENSessionPayload, S>

  type BENSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BENSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BENSessionCountAggregateInputType | true
    }

  export interface BENSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BENSession'], meta: { name: 'BENSession' } }
    /**
     * Find zero or one BENSession that matches the filter.
     * @param {BENSessionFindUniqueArgs} args - Arguments to find a BENSession
     * @example
     * // Get one BENSession
     * const bENSession = await prisma.bENSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BENSessionFindUniqueArgs>(args: SelectSubset<T, BENSessionFindUniqueArgs<ExtArgs>>): Prisma__BENSessionClient<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BENSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BENSessionFindUniqueOrThrowArgs} args - Arguments to find a BENSession
     * @example
     * // Get one BENSession
     * const bENSession = await prisma.bENSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BENSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, BENSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BENSessionClient<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BENSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENSessionFindFirstArgs} args - Arguments to find a BENSession
     * @example
     * // Get one BENSession
     * const bENSession = await prisma.bENSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BENSessionFindFirstArgs>(args?: SelectSubset<T, BENSessionFindFirstArgs<ExtArgs>>): Prisma__BENSessionClient<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BENSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENSessionFindFirstOrThrowArgs} args - Arguments to find a BENSession
     * @example
     * // Get one BENSession
     * const bENSession = await prisma.bENSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BENSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, BENSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BENSessionClient<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BENSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BENSessions
     * const bENSessions = await prisma.bENSession.findMany()
     * 
     * // Get first 10 BENSessions
     * const bENSessions = await prisma.bENSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bENSessionWithIdOnly = await prisma.bENSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BENSessionFindManyArgs>(args?: SelectSubset<T, BENSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BENSession.
     * @param {BENSessionCreateArgs} args - Arguments to create a BENSession.
     * @example
     * // Create one BENSession
     * const BENSession = await prisma.bENSession.create({
     *   data: {
     *     // ... data to create a BENSession
     *   }
     * })
     * 
     */
    create<T extends BENSessionCreateArgs>(args: SelectSubset<T, BENSessionCreateArgs<ExtArgs>>): Prisma__BENSessionClient<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BENSessions.
     * @param {BENSessionCreateManyArgs} args - Arguments to create many BENSessions.
     * @example
     * // Create many BENSessions
     * const bENSession = await prisma.bENSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BENSessionCreateManyArgs>(args?: SelectSubset<T, BENSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BENSessions and returns the data saved in the database.
     * @param {BENSessionCreateManyAndReturnArgs} args - Arguments to create many BENSessions.
     * @example
     * // Create many BENSessions
     * const bENSession = await prisma.bENSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BENSessions and only return the `id`
     * const bENSessionWithIdOnly = await prisma.bENSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BENSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, BENSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BENSession.
     * @param {BENSessionDeleteArgs} args - Arguments to delete one BENSession.
     * @example
     * // Delete one BENSession
     * const BENSession = await prisma.bENSession.delete({
     *   where: {
     *     // ... filter to delete one BENSession
     *   }
     * })
     * 
     */
    delete<T extends BENSessionDeleteArgs>(args: SelectSubset<T, BENSessionDeleteArgs<ExtArgs>>): Prisma__BENSessionClient<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BENSession.
     * @param {BENSessionUpdateArgs} args - Arguments to update one BENSession.
     * @example
     * // Update one BENSession
     * const bENSession = await prisma.bENSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BENSessionUpdateArgs>(args: SelectSubset<T, BENSessionUpdateArgs<ExtArgs>>): Prisma__BENSessionClient<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BENSessions.
     * @param {BENSessionDeleteManyArgs} args - Arguments to filter BENSessions to delete.
     * @example
     * // Delete a few BENSessions
     * const { count } = await prisma.bENSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BENSessionDeleteManyArgs>(args?: SelectSubset<T, BENSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BENSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BENSessions
     * const bENSession = await prisma.bENSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BENSessionUpdateManyArgs>(args: SelectSubset<T, BENSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BENSessions and returns the data updated in the database.
     * @param {BENSessionUpdateManyAndReturnArgs} args - Arguments to update many BENSessions.
     * @example
     * // Update many BENSessions
     * const bENSession = await prisma.bENSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BENSessions and only return the `id`
     * const bENSessionWithIdOnly = await prisma.bENSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BENSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, BENSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BENSession.
     * @param {BENSessionUpsertArgs} args - Arguments to update or create a BENSession.
     * @example
     * // Update or create a BENSession
     * const bENSession = await prisma.bENSession.upsert({
     *   create: {
     *     // ... data to create a BENSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BENSession we want to update
     *   }
     * })
     */
    upsert<T extends BENSessionUpsertArgs>(args: SelectSubset<T, BENSessionUpsertArgs<ExtArgs>>): Prisma__BENSessionClient<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BENSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENSessionCountArgs} args - Arguments to filter BENSessions to count.
     * @example
     * // Count the number of BENSessions
     * const count = await prisma.bENSession.count({
     *   where: {
     *     // ... the filter for the BENSessions we want to count
     *   }
     * })
    **/
    count<T extends BENSessionCountArgs>(
      args?: Subset<T, BENSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BENSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BENSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BENSessionAggregateArgs>(args: Subset<T, BENSessionAggregateArgs>): Prisma.PrismaPromise<GetBENSessionAggregateType<T>>

    /**
     * Group by BENSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BENSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BENSessionGroupByArgs['orderBy'] }
        : { orderBy?: BENSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BENSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBENSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BENSession model
   */
  readonly fields: BENSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BENSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BENSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BENSession model
   */
  interface BENSessionFieldRefs {
    readonly id: FieldRef<"BENSession", 'Int'>
    readonly userId: FieldRef<"BENSession", 'Int'>
    readonly persona: FieldRef<"BENSession", 'BENPersona'>
    readonly priority: FieldRef<"BENSession", 'Int'>
    readonly locked: FieldRef<"BENSession", 'Boolean'>
    readonly startedAt: FieldRef<"BENSession", 'DateTime'>
    readonly endedAt: FieldRef<"BENSession", 'DateTime'>
    readonly duration: FieldRef<"BENSession", 'Int'>
    readonly startLamport: FieldRef<"BENSession", 'Int'>
    readonly endLamport: FieldRef<"BENSession", 'Int'>
    readonly switchReason: FieldRef<"BENSession", 'String'>
    readonly metadata: FieldRef<"BENSession", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * BENSession findUnique
   */
  export type BENSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
    /**
     * Filter, which BENSession to fetch.
     */
    where: BENSessionWhereUniqueInput
  }

  /**
   * BENSession findUniqueOrThrow
   */
  export type BENSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
    /**
     * Filter, which BENSession to fetch.
     */
    where: BENSessionWhereUniqueInput
  }

  /**
   * BENSession findFirst
   */
  export type BENSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
    /**
     * Filter, which BENSession to fetch.
     */
    where?: BENSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BENSessions to fetch.
     */
    orderBy?: BENSessionOrderByWithRelationInput | BENSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BENSessions.
     */
    cursor?: BENSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BENSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BENSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BENSessions.
     */
    distinct?: BENSessionScalarFieldEnum | BENSessionScalarFieldEnum[]
  }

  /**
   * BENSession findFirstOrThrow
   */
  export type BENSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
    /**
     * Filter, which BENSession to fetch.
     */
    where?: BENSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BENSessions to fetch.
     */
    orderBy?: BENSessionOrderByWithRelationInput | BENSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BENSessions.
     */
    cursor?: BENSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BENSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BENSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BENSessions.
     */
    distinct?: BENSessionScalarFieldEnum | BENSessionScalarFieldEnum[]
  }

  /**
   * BENSession findMany
   */
  export type BENSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
    /**
     * Filter, which BENSessions to fetch.
     */
    where?: BENSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BENSessions to fetch.
     */
    orderBy?: BENSessionOrderByWithRelationInput | BENSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BENSessions.
     */
    cursor?: BENSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BENSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BENSessions.
     */
    skip?: number
    distinct?: BENSessionScalarFieldEnum | BENSessionScalarFieldEnum[]
  }

  /**
   * BENSession create
   */
  export type BENSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a BENSession.
     */
    data: XOR<BENSessionCreateInput, BENSessionUncheckedCreateInput>
  }

  /**
   * BENSession createMany
   */
  export type BENSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BENSessions.
     */
    data: BENSessionCreateManyInput | BENSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BENSession createManyAndReturn
   */
  export type BENSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * The data used to create many BENSessions.
     */
    data: BENSessionCreateManyInput | BENSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BENSession update
   */
  export type BENSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a BENSession.
     */
    data: XOR<BENSessionUpdateInput, BENSessionUncheckedUpdateInput>
    /**
     * Choose, which BENSession to update.
     */
    where: BENSessionWhereUniqueInput
  }

  /**
   * BENSession updateMany
   */
  export type BENSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BENSessions.
     */
    data: XOR<BENSessionUpdateManyMutationInput, BENSessionUncheckedUpdateManyInput>
    /**
     * Filter which BENSessions to update
     */
    where?: BENSessionWhereInput
    /**
     * Limit how many BENSessions to update.
     */
    limit?: number
  }

  /**
   * BENSession updateManyAndReturn
   */
  export type BENSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * The data used to update BENSessions.
     */
    data: XOR<BENSessionUpdateManyMutationInput, BENSessionUncheckedUpdateManyInput>
    /**
     * Filter which BENSessions to update
     */
    where?: BENSessionWhereInput
    /**
     * Limit how many BENSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BENSession upsert
   */
  export type BENSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the BENSession to update in case it exists.
     */
    where: BENSessionWhereUniqueInput
    /**
     * In case the BENSession found by the `where` argument doesn't exist, create a new BENSession with this data.
     */
    create: XOR<BENSessionCreateInput, BENSessionUncheckedCreateInput>
    /**
     * In case the BENSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BENSessionUpdateInput, BENSessionUncheckedUpdateInput>
  }

  /**
   * BENSession delete
   */
  export type BENSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
    /**
     * Filter which BENSession to delete.
     */
    where: BENSessionWhereUniqueInput
  }

  /**
   * BENSession deleteMany
   */
  export type BENSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BENSessions to delete
     */
    where?: BENSessionWhereInput
    /**
     * Limit how many BENSessions to delete.
     */
    limit?: number
  }

  /**
   * BENSession without action
   */
  export type BENSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
  }


  /**
   * Model TriTrackHandoff
   */

  export type AggregateTriTrackHandoff = {
    _count: TriTrackHandoffCountAggregateOutputType | null
    _avg: TriTrackHandoffAvgAggregateOutputType | null
    _sum: TriTrackHandoffSumAggregateOutputType | null
    _min: TriTrackHandoffMinAggregateOutputType | null
    _max: TriTrackHandoffMaxAggregateOutputType | null
  }

  export type TriTrackHandoffAvgAggregateOutputType = {
    id: number | null
    fromReceiptId: number | null
    toReceiptId: number | null
    latencyMs: number | null
  }

  export type TriTrackHandoffSumAggregateOutputType = {
    id: number | null
    fromReceiptId: number | null
    toReceiptId: number | null
    latencyMs: number | null
  }

  export type TriTrackHandoffMinAggregateOutputType = {
    id: number | null
    fromTrack: $Enums.TrackType | null
    toTrack: $Enums.TrackType | null
    status: $Enums.HandoffStatus | null
    fromReceiptId: number | null
    toReceiptId: number | null
    initiatedAt: Date | null
    completedAt: Date | null
    latencyMs: number | null
    exceededLimit: boolean | null
    errorMessage: string | null
  }

  export type TriTrackHandoffMaxAggregateOutputType = {
    id: number | null
    fromTrack: $Enums.TrackType | null
    toTrack: $Enums.TrackType | null
    status: $Enums.HandoffStatus | null
    fromReceiptId: number | null
    toReceiptId: number | null
    initiatedAt: Date | null
    completedAt: Date | null
    latencyMs: number | null
    exceededLimit: boolean | null
    errorMessage: string | null
  }

  export type TriTrackHandoffCountAggregateOutputType = {
    id: number
    fromTrack: number
    toTrack: number
    status: number
    fromReceiptId: number
    toReceiptId: number
    initiatedAt: number
    completedAt: number
    latencyMs: number
    exceededLimit: number
    payload: number
    result: number
    errorMessage: number
    metadata: number
    _all: number
  }


  export type TriTrackHandoffAvgAggregateInputType = {
    id?: true
    fromReceiptId?: true
    toReceiptId?: true
    latencyMs?: true
  }

  export type TriTrackHandoffSumAggregateInputType = {
    id?: true
    fromReceiptId?: true
    toReceiptId?: true
    latencyMs?: true
  }

  export type TriTrackHandoffMinAggregateInputType = {
    id?: true
    fromTrack?: true
    toTrack?: true
    status?: true
    fromReceiptId?: true
    toReceiptId?: true
    initiatedAt?: true
    completedAt?: true
    latencyMs?: true
    exceededLimit?: true
    errorMessage?: true
  }

  export type TriTrackHandoffMaxAggregateInputType = {
    id?: true
    fromTrack?: true
    toTrack?: true
    status?: true
    fromReceiptId?: true
    toReceiptId?: true
    initiatedAt?: true
    completedAt?: true
    latencyMs?: true
    exceededLimit?: true
    errorMessage?: true
  }

  export type TriTrackHandoffCountAggregateInputType = {
    id?: true
    fromTrack?: true
    toTrack?: true
    status?: true
    fromReceiptId?: true
    toReceiptId?: true
    initiatedAt?: true
    completedAt?: true
    latencyMs?: true
    exceededLimit?: true
    payload?: true
    result?: true
    errorMessage?: true
    metadata?: true
    _all?: true
  }

  export type TriTrackHandoffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TriTrackHandoff to aggregate.
     */
    where?: TriTrackHandoffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriTrackHandoffs to fetch.
     */
    orderBy?: TriTrackHandoffOrderByWithRelationInput | TriTrackHandoffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TriTrackHandoffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriTrackHandoffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriTrackHandoffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TriTrackHandoffs
    **/
    _count?: true | TriTrackHandoffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TriTrackHandoffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TriTrackHandoffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TriTrackHandoffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TriTrackHandoffMaxAggregateInputType
  }

  export type GetTriTrackHandoffAggregateType<T extends TriTrackHandoffAggregateArgs> = {
        [P in keyof T & keyof AggregateTriTrackHandoff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTriTrackHandoff[P]>
      : GetScalarType<T[P], AggregateTriTrackHandoff[P]>
  }




  export type TriTrackHandoffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TriTrackHandoffWhereInput
    orderBy?: TriTrackHandoffOrderByWithAggregationInput | TriTrackHandoffOrderByWithAggregationInput[]
    by: TriTrackHandoffScalarFieldEnum[] | TriTrackHandoffScalarFieldEnum
    having?: TriTrackHandoffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TriTrackHandoffCountAggregateInputType | true
    _avg?: TriTrackHandoffAvgAggregateInputType
    _sum?: TriTrackHandoffSumAggregateInputType
    _min?: TriTrackHandoffMinAggregateInputType
    _max?: TriTrackHandoffMaxAggregateInputType
  }

  export type TriTrackHandoffGroupByOutputType = {
    id: number
    fromTrack: $Enums.TrackType
    toTrack: $Enums.TrackType
    status: $Enums.HandoffStatus
    fromReceiptId: number
    toReceiptId: number | null
    initiatedAt: Date
    completedAt: Date | null
    latencyMs: number | null
    exceededLimit: boolean
    payload: JsonValue
    result: JsonValue | null
    errorMessage: string | null
    metadata: JsonValue | null
    _count: TriTrackHandoffCountAggregateOutputType | null
    _avg: TriTrackHandoffAvgAggregateOutputType | null
    _sum: TriTrackHandoffSumAggregateOutputType | null
    _min: TriTrackHandoffMinAggregateOutputType | null
    _max: TriTrackHandoffMaxAggregateOutputType | null
  }

  type GetTriTrackHandoffGroupByPayload<T extends TriTrackHandoffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TriTrackHandoffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TriTrackHandoffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TriTrackHandoffGroupByOutputType[P]>
            : GetScalarType<T[P], TriTrackHandoffGroupByOutputType[P]>
        }
      >
    >


  export type TriTrackHandoffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromTrack?: boolean
    toTrack?: boolean
    status?: boolean
    fromReceiptId?: boolean
    toReceiptId?: boolean
    initiatedAt?: boolean
    completedAt?: boolean
    latencyMs?: boolean
    exceededLimit?: boolean
    payload?: boolean
    result?: boolean
    errorMessage?: boolean
    metadata?: boolean
    fromReceipt?: boolean | BENReceiptDefaultArgs<ExtArgs>
    toReceipt?: boolean | TriTrackHandoff$toReceiptArgs<ExtArgs>
  }, ExtArgs["result"]["triTrackHandoff"]>

  export type TriTrackHandoffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromTrack?: boolean
    toTrack?: boolean
    status?: boolean
    fromReceiptId?: boolean
    toReceiptId?: boolean
    initiatedAt?: boolean
    completedAt?: boolean
    latencyMs?: boolean
    exceededLimit?: boolean
    payload?: boolean
    result?: boolean
    errorMessage?: boolean
    metadata?: boolean
    fromReceipt?: boolean | BENReceiptDefaultArgs<ExtArgs>
    toReceipt?: boolean | TriTrackHandoff$toReceiptArgs<ExtArgs>
  }, ExtArgs["result"]["triTrackHandoff"]>

  export type TriTrackHandoffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromTrack?: boolean
    toTrack?: boolean
    status?: boolean
    fromReceiptId?: boolean
    toReceiptId?: boolean
    initiatedAt?: boolean
    completedAt?: boolean
    latencyMs?: boolean
    exceededLimit?: boolean
    payload?: boolean
    result?: boolean
    errorMessage?: boolean
    metadata?: boolean
    fromReceipt?: boolean | BENReceiptDefaultArgs<ExtArgs>
    toReceipt?: boolean | TriTrackHandoff$toReceiptArgs<ExtArgs>
  }, ExtArgs["result"]["triTrackHandoff"]>

  export type TriTrackHandoffSelectScalar = {
    id?: boolean
    fromTrack?: boolean
    toTrack?: boolean
    status?: boolean
    fromReceiptId?: boolean
    toReceiptId?: boolean
    initiatedAt?: boolean
    completedAt?: boolean
    latencyMs?: boolean
    exceededLimit?: boolean
    payload?: boolean
    result?: boolean
    errorMessage?: boolean
    metadata?: boolean
  }

  export type TriTrackHandoffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fromTrack" | "toTrack" | "status" | "fromReceiptId" | "toReceiptId" | "initiatedAt" | "completedAt" | "latencyMs" | "exceededLimit" | "payload" | "result" | "errorMessage" | "metadata", ExtArgs["result"]["triTrackHandoff"]>
  export type TriTrackHandoffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromReceipt?: boolean | BENReceiptDefaultArgs<ExtArgs>
    toReceipt?: boolean | TriTrackHandoff$toReceiptArgs<ExtArgs>
  }
  export type TriTrackHandoffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromReceipt?: boolean | BENReceiptDefaultArgs<ExtArgs>
    toReceipt?: boolean | TriTrackHandoff$toReceiptArgs<ExtArgs>
  }
  export type TriTrackHandoffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromReceipt?: boolean | BENReceiptDefaultArgs<ExtArgs>
    toReceipt?: boolean | TriTrackHandoff$toReceiptArgs<ExtArgs>
  }

  export type $TriTrackHandoffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TriTrackHandoff"
    objects: {
      fromReceipt: Prisma.$BENReceiptPayload<ExtArgs>
      toReceipt: Prisma.$BENReceiptPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fromTrack: $Enums.TrackType
      toTrack: $Enums.TrackType
      status: $Enums.HandoffStatus
      fromReceiptId: number
      toReceiptId: number | null
      initiatedAt: Date
      completedAt: Date | null
      latencyMs: number | null
      exceededLimit: boolean
      payload: Prisma.JsonValue
      result: Prisma.JsonValue | null
      errorMessage: string | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["triTrackHandoff"]>
    composites: {}
  }

  type TriTrackHandoffGetPayload<S extends boolean | null | undefined | TriTrackHandoffDefaultArgs> = $Result.GetResult<Prisma.$TriTrackHandoffPayload, S>

  type TriTrackHandoffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TriTrackHandoffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TriTrackHandoffCountAggregateInputType | true
    }

  export interface TriTrackHandoffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TriTrackHandoff'], meta: { name: 'TriTrackHandoff' } }
    /**
     * Find zero or one TriTrackHandoff that matches the filter.
     * @param {TriTrackHandoffFindUniqueArgs} args - Arguments to find a TriTrackHandoff
     * @example
     * // Get one TriTrackHandoff
     * const triTrackHandoff = await prisma.triTrackHandoff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TriTrackHandoffFindUniqueArgs>(args: SelectSubset<T, TriTrackHandoffFindUniqueArgs<ExtArgs>>): Prisma__TriTrackHandoffClient<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TriTrackHandoff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TriTrackHandoffFindUniqueOrThrowArgs} args - Arguments to find a TriTrackHandoff
     * @example
     * // Get one TriTrackHandoff
     * const triTrackHandoff = await prisma.triTrackHandoff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TriTrackHandoffFindUniqueOrThrowArgs>(args: SelectSubset<T, TriTrackHandoffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TriTrackHandoffClient<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TriTrackHandoff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriTrackHandoffFindFirstArgs} args - Arguments to find a TriTrackHandoff
     * @example
     * // Get one TriTrackHandoff
     * const triTrackHandoff = await prisma.triTrackHandoff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TriTrackHandoffFindFirstArgs>(args?: SelectSubset<T, TriTrackHandoffFindFirstArgs<ExtArgs>>): Prisma__TriTrackHandoffClient<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TriTrackHandoff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriTrackHandoffFindFirstOrThrowArgs} args - Arguments to find a TriTrackHandoff
     * @example
     * // Get one TriTrackHandoff
     * const triTrackHandoff = await prisma.triTrackHandoff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TriTrackHandoffFindFirstOrThrowArgs>(args?: SelectSubset<T, TriTrackHandoffFindFirstOrThrowArgs<ExtArgs>>): Prisma__TriTrackHandoffClient<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TriTrackHandoffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriTrackHandoffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TriTrackHandoffs
     * const triTrackHandoffs = await prisma.triTrackHandoff.findMany()
     * 
     * // Get first 10 TriTrackHandoffs
     * const triTrackHandoffs = await prisma.triTrackHandoff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const triTrackHandoffWithIdOnly = await prisma.triTrackHandoff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TriTrackHandoffFindManyArgs>(args?: SelectSubset<T, TriTrackHandoffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TriTrackHandoff.
     * @param {TriTrackHandoffCreateArgs} args - Arguments to create a TriTrackHandoff.
     * @example
     * // Create one TriTrackHandoff
     * const TriTrackHandoff = await prisma.triTrackHandoff.create({
     *   data: {
     *     // ... data to create a TriTrackHandoff
     *   }
     * })
     * 
     */
    create<T extends TriTrackHandoffCreateArgs>(args: SelectSubset<T, TriTrackHandoffCreateArgs<ExtArgs>>): Prisma__TriTrackHandoffClient<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TriTrackHandoffs.
     * @param {TriTrackHandoffCreateManyArgs} args - Arguments to create many TriTrackHandoffs.
     * @example
     * // Create many TriTrackHandoffs
     * const triTrackHandoff = await prisma.triTrackHandoff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TriTrackHandoffCreateManyArgs>(args?: SelectSubset<T, TriTrackHandoffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TriTrackHandoffs and returns the data saved in the database.
     * @param {TriTrackHandoffCreateManyAndReturnArgs} args - Arguments to create many TriTrackHandoffs.
     * @example
     * // Create many TriTrackHandoffs
     * const triTrackHandoff = await prisma.triTrackHandoff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TriTrackHandoffs and only return the `id`
     * const triTrackHandoffWithIdOnly = await prisma.triTrackHandoff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TriTrackHandoffCreateManyAndReturnArgs>(args?: SelectSubset<T, TriTrackHandoffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TriTrackHandoff.
     * @param {TriTrackHandoffDeleteArgs} args - Arguments to delete one TriTrackHandoff.
     * @example
     * // Delete one TriTrackHandoff
     * const TriTrackHandoff = await prisma.triTrackHandoff.delete({
     *   where: {
     *     // ... filter to delete one TriTrackHandoff
     *   }
     * })
     * 
     */
    delete<T extends TriTrackHandoffDeleteArgs>(args: SelectSubset<T, TriTrackHandoffDeleteArgs<ExtArgs>>): Prisma__TriTrackHandoffClient<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TriTrackHandoff.
     * @param {TriTrackHandoffUpdateArgs} args - Arguments to update one TriTrackHandoff.
     * @example
     * // Update one TriTrackHandoff
     * const triTrackHandoff = await prisma.triTrackHandoff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TriTrackHandoffUpdateArgs>(args: SelectSubset<T, TriTrackHandoffUpdateArgs<ExtArgs>>): Prisma__TriTrackHandoffClient<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TriTrackHandoffs.
     * @param {TriTrackHandoffDeleteManyArgs} args - Arguments to filter TriTrackHandoffs to delete.
     * @example
     * // Delete a few TriTrackHandoffs
     * const { count } = await prisma.triTrackHandoff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TriTrackHandoffDeleteManyArgs>(args?: SelectSubset<T, TriTrackHandoffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TriTrackHandoffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriTrackHandoffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TriTrackHandoffs
     * const triTrackHandoff = await prisma.triTrackHandoff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TriTrackHandoffUpdateManyArgs>(args: SelectSubset<T, TriTrackHandoffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TriTrackHandoffs and returns the data updated in the database.
     * @param {TriTrackHandoffUpdateManyAndReturnArgs} args - Arguments to update many TriTrackHandoffs.
     * @example
     * // Update many TriTrackHandoffs
     * const triTrackHandoff = await prisma.triTrackHandoff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TriTrackHandoffs and only return the `id`
     * const triTrackHandoffWithIdOnly = await prisma.triTrackHandoff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TriTrackHandoffUpdateManyAndReturnArgs>(args: SelectSubset<T, TriTrackHandoffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TriTrackHandoff.
     * @param {TriTrackHandoffUpsertArgs} args - Arguments to update or create a TriTrackHandoff.
     * @example
     * // Update or create a TriTrackHandoff
     * const triTrackHandoff = await prisma.triTrackHandoff.upsert({
     *   create: {
     *     // ... data to create a TriTrackHandoff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TriTrackHandoff we want to update
     *   }
     * })
     */
    upsert<T extends TriTrackHandoffUpsertArgs>(args: SelectSubset<T, TriTrackHandoffUpsertArgs<ExtArgs>>): Prisma__TriTrackHandoffClient<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TriTrackHandoffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriTrackHandoffCountArgs} args - Arguments to filter TriTrackHandoffs to count.
     * @example
     * // Count the number of TriTrackHandoffs
     * const count = await prisma.triTrackHandoff.count({
     *   where: {
     *     // ... the filter for the TriTrackHandoffs we want to count
     *   }
     * })
    **/
    count<T extends TriTrackHandoffCountArgs>(
      args?: Subset<T, TriTrackHandoffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TriTrackHandoffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TriTrackHandoff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriTrackHandoffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TriTrackHandoffAggregateArgs>(args: Subset<T, TriTrackHandoffAggregateArgs>): Prisma.PrismaPromise<GetTriTrackHandoffAggregateType<T>>

    /**
     * Group by TriTrackHandoff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriTrackHandoffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TriTrackHandoffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TriTrackHandoffGroupByArgs['orderBy'] }
        : { orderBy?: TriTrackHandoffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TriTrackHandoffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTriTrackHandoffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TriTrackHandoff model
   */
  readonly fields: TriTrackHandoffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TriTrackHandoff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TriTrackHandoffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromReceipt<T extends BENReceiptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BENReceiptDefaultArgs<ExtArgs>>): Prisma__BENReceiptClient<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toReceipt<T extends TriTrackHandoff$toReceiptArgs<ExtArgs> = {}>(args?: Subset<T, TriTrackHandoff$toReceiptArgs<ExtArgs>>): Prisma__BENReceiptClient<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TriTrackHandoff model
   */
  interface TriTrackHandoffFieldRefs {
    readonly id: FieldRef<"TriTrackHandoff", 'Int'>
    readonly fromTrack: FieldRef<"TriTrackHandoff", 'TrackType'>
    readonly toTrack: FieldRef<"TriTrackHandoff", 'TrackType'>
    readonly status: FieldRef<"TriTrackHandoff", 'HandoffStatus'>
    readonly fromReceiptId: FieldRef<"TriTrackHandoff", 'Int'>
    readonly toReceiptId: FieldRef<"TriTrackHandoff", 'Int'>
    readonly initiatedAt: FieldRef<"TriTrackHandoff", 'DateTime'>
    readonly completedAt: FieldRef<"TriTrackHandoff", 'DateTime'>
    readonly latencyMs: FieldRef<"TriTrackHandoff", 'Int'>
    readonly exceededLimit: FieldRef<"TriTrackHandoff", 'Boolean'>
    readonly payload: FieldRef<"TriTrackHandoff", 'Json'>
    readonly result: FieldRef<"TriTrackHandoff", 'Json'>
    readonly errorMessage: FieldRef<"TriTrackHandoff", 'String'>
    readonly metadata: FieldRef<"TriTrackHandoff", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * TriTrackHandoff findUnique
   */
  export type TriTrackHandoffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    /**
     * Filter, which TriTrackHandoff to fetch.
     */
    where: TriTrackHandoffWhereUniqueInput
  }

  /**
   * TriTrackHandoff findUniqueOrThrow
   */
  export type TriTrackHandoffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    /**
     * Filter, which TriTrackHandoff to fetch.
     */
    where: TriTrackHandoffWhereUniqueInput
  }

  /**
   * TriTrackHandoff findFirst
   */
  export type TriTrackHandoffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    /**
     * Filter, which TriTrackHandoff to fetch.
     */
    where?: TriTrackHandoffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriTrackHandoffs to fetch.
     */
    orderBy?: TriTrackHandoffOrderByWithRelationInput | TriTrackHandoffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TriTrackHandoffs.
     */
    cursor?: TriTrackHandoffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriTrackHandoffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriTrackHandoffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TriTrackHandoffs.
     */
    distinct?: TriTrackHandoffScalarFieldEnum | TriTrackHandoffScalarFieldEnum[]
  }

  /**
   * TriTrackHandoff findFirstOrThrow
   */
  export type TriTrackHandoffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    /**
     * Filter, which TriTrackHandoff to fetch.
     */
    where?: TriTrackHandoffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriTrackHandoffs to fetch.
     */
    orderBy?: TriTrackHandoffOrderByWithRelationInput | TriTrackHandoffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TriTrackHandoffs.
     */
    cursor?: TriTrackHandoffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriTrackHandoffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriTrackHandoffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TriTrackHandoffs.
     */
    distinct?: TriTrackHandoffScalarFieldEnum | TriTrackHandoffScalarFieldEnum[]
  }

  /**
   * TriTrackHandoff findMany
   */
  export type TriTrackHandoffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    /**
     * Filter, which TriTrackHandoffs to fetch.
     */
    where?: TriTrackHandoffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriTrackHandoffs to fetch.
     */
    orderBy?: TriTrackHandoffOrderByWithRelationInput | TriTrackHandoffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TriTrackHandoffs.
     */
    cursor?: TriTrackHandoffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriTrackHandoffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriTrackHandoffs.
     */
    skip?: number
    distinct?: TriTrackHandoffScalarFieldEnum | TriTrackHandoffScalarFieldEnum[]
  }

  /**
   * TriTrackHandoff create
   */
  export type TriTrackHandoffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    /**
     * The data needed to create a TriTrackHandoff.
     */
    data: XOR<TriTrackHandoffCreateInput, TriTrackHandoffUncheckedCreateInput>
  }

  /**
   * TriTrackHandoff createMany
   */
  export type TriTrackHandoffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TriTrackHandoffs.
     */
    data: TriTrackHandoffCreateManyInput | TriTrackHandoffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TriTrackHandoff createManyAndReturn
   */
  export type TriTrackHandoffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * The data used to create many TriTrackHandoffs.
     */
    data: TriTrackHandoffCreateManyInput | TriTrackHandoffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TriTrackHandoff update
   */
  export type TriTrackHandoffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    /**
     * The data needed to update a TriTrackHandoff.
     */
    data: XOR<TriTrackHandoffUpdateInput, TriTrackHandoffUncheckedUpdateInput>
    /**
     * Choose, which TriTrackHandoff to update.
     */
    where: TriTrackHandoffWhereUniqueInput
  }

  /**
   * TriTrackHandoff updateMany
   */
  export type TriTrackHandoffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TriTrackHandoffs.
     */
    data: XOR<TriTrackHandoffUpdateManyMutationInput, TriTrackHandoffUncheckedUpdateManyInput>
    /**
     * Filter which TriTrackHandoffs to update
     */
    where?: TriTrackHandoffWhereInput
    /**
     * Limit how many TriTrackHandoffs to update.
     */
    limit?: number
  }

  /**
   * TriTrackHandoff updateManyAndReturn
   */
  export type TriTrackHandoffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * The data used to update TriTrackHandoffs.
     */
    data: XOR<TriTrackHandoffUpdateManyMutationInput, TriTrackHandoffUncheckedUpdateManyInput>
    /**
     * Filter which TriTrackHandoffs to update
     */
    where?: TriTrackHandoffWhereInput
    /**
     * Limit how many TriTrackHandoffs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TriTrackHandoff upsert
   */
  export type TriTrackHandoffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    /**
     * The filter to search for the TriTrackHandoff to update in case it exists.
     */
    where: TriTrackHandoffWhereUniqueInput
    /**
     * In case the TriTrackHandoff found by the `where` argument doesn't exist, create a new TriTrackHandoff with this data.
     */
    create: XOR<TriTrackHandoffCreateInput, TriTrackHandoffUncheckedCreateInput>
    /**
     * In case the TriTrackHandoff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TriTrackHandoffUpdateInput, TriTrackHandoffUncheckedUpdateInput>
  }

  /**
   * TriTrackHandoff delete
   */
  export type TriTrackHandoffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    /**
     * Filter which TriTrackHandoff to delete.
     */
    where: TriTrackHandoffWhereUniqueInput
  }

  /**
   * TriTrackHandoff deleteMany
   */
  export type TriTrackHandoffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TriTrackHandoffs to delete
     */
    where?: TriTrackHandoffWhereInput
    /**
     * Limit how many TriTrackHandoffs to delete.
     */
    limit?: number
  }

  /**
   * TriTrackHandoff.toReceipt
   */
  export type TriTrackHandoff$toReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    where?: BENReceiptWhereInput
  }

  /**
   * TriTrackHandoff without action
   */
  export type TriTrackHandoffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
  }


  /**
   * Model WitnessSignature
   */

  export type AggregateWitnessSignature = {
    _count: WitnessSignatureCountAggregateOutputType | null
    _avg: WitnessSignatureAvgAggregateOutputType | null
    _sum: WitnessSignatureSumAggregateOutputType | null
    _min: WitnessSignatureMinAggregateOutputType | null
    _max: WitnessSignatureMaxAggregateOutputType | null
  }

  export type WitnessSignatureAvgAggregateOutputType = {
    id: number | null
    receiptId: number | null
    lamportClock: number | null
  }

  export type WitnessSignatureSumAggregateOutputType = {
    id: number | null
    receiptId: number | null
    lamportClock: number | null
  }

  export type WitnessSignatureMinAggregateOutputType = {
    id: number | null
    modelName: string | null
    modelFingerprint: string | null
    receiptId: number | null
    receiptDigest: string | null
    signature: string | null
    signedAt: Date | null
    lamportClock: number | null
    verified: boolean | null
    verifiedAt: Date | null
  }

  export type WitnessSignatureMaxAggregateOutputType = {
    id: number | null
    modelName: string | null
    modelFingerprint: string | null
    receiptId: number | null
    receiptDigest: string | null
    signature: string | null
    signedAt: Date | null
    lamportClock: number | null
    verified: boolean | null
    verifiedAt: Date | null
  }

  export type WitnessSignatureCountAggregateOutputType = {
    id: number
    modelName: number
    modelFingerprint: number
    receiptId: number
    receiptDigest: number
    signature: number
    signedAt: number
    lamportClock: number
    verified: number
    verifiedAt: number
    verificationData: number
    metadata: number
    _all: number
  }


  export type WitnessSignatureAvgAggregateInputType = {
    id?: true
    receiptId?: true
    lamportClock?: true
  }

  export type WitnessSignatureSumAggregateInputType = {
    id?: true
    receiptId?: true
    lamportClock?: true
  }

  export type WitnessSignatureMinAggregateInputType = {
    id?: true
    modelName?: true
    modelFingerprint?: true
    receiptId?: true
    receiptDigest?: true
    signature?: true
    signedAt?: true
    lamportClock?: true
    verified?: true
    verifiedAt?: true
  }

  export type WitnessSignatureMaxAggregateInputType = {
    id?: true
    modelName?: true
    modelFingerprint?: true
    receiptId?: true
    receiptDigest?: true
    signature?: true
    signedAt?: true
    lamportClock?: true
    verified?: true
    verifiedAt?: true
  }

  export type WitnessSignatureCountAggregateInputType = {
    id?: true
    modelName?: true
    modelFingerprint?: true
    receiptId?: true
    receiptDigest?: true
    signature?: true
    signedAt?: true
    lamportClock?: true
    verified?: true
    verifiedAt?: true
    verificationData?: true
    metadata?: true
    _all?: true
  }

  export type WitnessSignatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WitnessSignature to aggregate.
     */
    where?: WitnessSignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WitnessSignatures to fetch.
     */
    orderBy?: WitnessSignatureOrderByWithRelationInput | WitnessSignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WitnessSignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WitnessSignatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WitnessSignatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WitnessSignatures
    **/
    _count?: true | WitnessSignatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WitnessSignatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WitnessSignatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WitnessSignatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WitnessSignatureMaxAggregateInputType
  }

  export type GetWitnessSignatureAggregateType<T extends WitnessSignatureAggregateArgs> = {
        [P in keyof T & keyof AggregateWitnessSignature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWitnessSignature[P]>
      : GetScalarType<T[P], AggregateWitnessSignature[P]>
  }




  export type WitnessSignatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WitnessSignatureWhereInput
    orderBy?: WitnessSignatureOrderByWithAggregationInput | WitnessSignatureOrderByWithAggregationInput[]
    by: WitnessSignatureScalarFieldEnum[] | WitnessSignatureScalarFieldEnum
    having?: WitnessSignatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WitnessSignatureCountAggregateInputType | true
    _avg?: WitnessSignatureAvgAggregateInputType
    _sum?: WitnessSignatureSumAggregateInputType
    _min?: WitnessSignatureMinAggregateInputType
    _max?: WitnessSignatureMaxAggregateInputType
  }

  export type WitnessSignatureGroupByOutputType = {
    id: number
    modelName: string
    modelFingerprint: string
    receiptId: number | null
    receiptDigest: string
    signature: string
    signedAt: Date
    lamportClock: number
    verified: boolean
    verifiedAt: Date | null
    verificationData: JsonValue | null
    metadata: JsonValue | null
    _count: WitnessSignatureCountAggregateOutputType | null
    _avg: WitnessSignatureAvgAggregateOutputType | null
    _sum: WitnessSignatureSumAggregateOutputType | null
    _min: WitnessSignatureMinAggregateOutputType | null
    _max: WitnessSignatureMaxAggregateOutputType | null
  }

  type GetWitnessSignatureGroupByPayload<T extends WitnessSignatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WitnessSignatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WitnessSignatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WitnessSignatureGroupByOutputType[P]>
            : GetScalarType<T[P], WitnessSignatureGroupByOutputType[P]>
        }
      >
    >


  export type WitnessSignatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelName?: boolean
    modelFingerprint?: boolean
    receiptId?: boolean
    receiptDigest?: boolean
    signature?: boolean
    signedAt?: boolean
    lamportClock?: boolean
    verified?: boolean
    verifiedAt?: boolean
    verificationData?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["witnessSignature"]>

  export type WitnessSignatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelName?: boolean
    modelFingerprint?: boolean
    receiptId?: boolean
    receiptDigest?: boolean
    signature?: boolean
    signedAt?: boolean
    lamportClock?: boolean
    verified?: boolean
    verifiedAt?: boolean
    verificationData?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["witnessSignature"]>

  export type WitnessSignatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelName?: boolean
    modelFingerprint?: boolean
    receiptId?: boolean
    receiptDigest?: boolean
    signature?: boolean
    signedAt?: boolean
    lamportClock?: boolean
    verified?: boolean
    verifiedAt?: boolean
    verificationData?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["witnessSignature"]>

  export type WitnessSignatureSelectScalar = {
    id?: boolean
    modelName?: boolean
    modelFingerprint?: boolean
    receiptId?: boolean
    receiptDigest?: boolean
    signature?: boolean
    signedAt?: boolean
    lamportClock?: boolean
    verified?: boolean
    verifiedAt?: boolean
    verificationData?: boolean
    metadata?: boolean
  }

  export type WitnessSignatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "modelName" | "modelFingerprint" | "receiptId" | "receiptDigest" | "signature" | "signedAt" | "lamportClock" | "verified" | "verifiedAt" | "verificationData" | "metadata", ExtArgs["result"]["witnessSignature"]>

  export type $WitnessSignaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WitnessSignature"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      modelName: string
      modelFingerprint: string
      receiptId: number | null
      receiptDigest: string
      signature: string
      signedAt: Date
      lamportClock: number
      verified: boolean
      verifiedAt: Date | null
      verificationData: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["witnessSignature"]>
    composites: {}
  }

  type WitnessSignatureGetPayload<S extends boolean | null | undefined | WitnessSignatureDefaultArgs> = $Result.GetResult<Prisma.$WitnessSignaturePayload, S>

  type WitnessSignatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WitnessSignatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WitnessSignatureCountAggregateInputType | true
    }

  export interface WitnessSignatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WitnessSignature'], meta: { name: 'WitnessSignature' } }
    /**
     * Find zero or one WitnessSignature that matches the filter.
     * @param {WitnessSignatureFindUniqueArgs} args - Arguments to find a WitnessSignature
     * @example
     * // Get one WitnessSignature
     * const witnessSignature = await prisma.witnessSignature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WitnessSignatureFindUniqueArgs>(args: SelectSubset<T, WitnessSignatureFindUniqueArgs<ExtArgs>>): Prisma__WitnessSignatureClient<$Result.GetResult<Prisma.$WitnessSignaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WitnessSignature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WitnessSignatureFindUniqueOrThrowArgs} args - Arguments to find a WitnessSignature
     * @example
     * // Get one WitnessSignature
     * const witnessSignature = await prisma.witnessSignature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WitnessSignatureFindUniqueOrThrowArgs>(args: SelectSubset<T, WitnessSignatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WitnessSignatureClient<$Result.GetResult<Prisma.$WitnessSignaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WitnessSignature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessSignatureFindFirstArgs} args - Arguments to find a WitnessSignature
     * @example
     * // Get one WitnessSignature
     * const witnessSignature = await prisma.witnessSignature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WitnessSignatureFindFirstArgs>(args?: SelectSubset<T, WitnessSignatureFindFirstArgs<ExtArgs>>): Prisma__WitnessSignatureClient<$Result.GetResult<Prisma.$WitnessSignaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WitnessSignature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessSignatureFindFirstOrThrowArgs} args - Arguments to find a WitnessSignature
     * @example
     * // Get one WitnessSignature
     * const witnessSignature = await prisma.witnessSignature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WitnessSignatureFindFirstOrThrowArgs>(args?: SelectSubset<T, WitnessSignatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__WitnessSignatureClient<$Result.GetResult<Prisma.$WitnessSignaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WitnessSignatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessSignatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WitnessSignatures
     * const witnessSignatures = await prisma.witnessSignature.findMany()
     * 
     * // Get first 10 WitnessSignatures
     * const witnessSignatures = await prisma.witnessSignature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const witnessSignatureWithIdOnly = await prisma.witnessSignature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WitnessSignatureFindManyArgs>(args?: SelectSubset<T, WitnessSignatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WitnessSignaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WitnessSignature.
     * @param {WitnessSignatureCreateArgs} args - Arguments to create a WitnessSignature.
     * @example
     * // Create one WitnessSignature
     * const WitnessSignature = await prisma.witnessSignature.create({
     *   data: {
     *     // ... data to create a WitnessSignature
     *   }
     * })
     * 
     */
    create<T extends WitnessSignatureCreateArgs>(args: SelectSubset<T, WitnessSignatureCreateArgs<ExtArgs>>): Prisma__WitnessSignatureClient<$Result.GetResult<Prisma.$WitnessSignaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WitnessSignatures.
     * @param {WitnessSignatureCreateManyArgs} args - Arguments to create many WitnessSignatures.
     * @example
     * // Create many WitnessSignatures
     * const witnessSignature = await prisma.witnessSignature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WitnessSignatureCreateManyArgs>(args?: SelectSubset<T, WitnessSignatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WitnessSignatures and returns the data saved in the database.
     * @param {WitnessSignatureCreateManyAndReturnArgs} args - Arguments to create many WitnessSignatures.
     * @example
     * // Create many WitnessSignatures
     * const witnessSignature = await prisma.witnessSignature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WitnessSignatures and only return the `id`
     * const witnessSignatureWithIdOnly = await prisma.witnessSignature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WitnessSignatureCreateManyAndReturnArgs>(args?: SelectSubset<T, WitnessSignatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WitnessSignaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WitnessSignature.
     * @param {WitnessSignatureDeleteArgs} args - Arguments to delete one WitnessSignature.
     * @example
     * // Delete one WitnessSignature
     * const WitnessSignature = await prisma.witnessSignature.delete({
     *   where: {
     *     // ... filter to delete one WitnessSignature
     *   }
     * })
     * 
     */
    delete<T extends WitnessSignatureDeleteArgs>(args: SelectSubset<T, WitnessSignatureDeleteArgs<ExtArgs>>): Prisma__WitnessSignatureClient<$Result.GetResult<Prisma.$WitnessSignaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WitnessSignature.
     * @param {WitnessSignatureUpdateArgs} args - Arguments to update one WitnessSignature.
     * @example
     * // Update one WitnessSignature
     * const witnessSignature = await prisma.witnessSignature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WitnessSignatureUpdateArgs>(args: SelectSubset<T, WitnessSignatureUpdateArgs<ExtArgs>>): Prisma__WitnessSignatureClient<$Result.GetResult<Prisma.$WitnessSignaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WitnessSignatures.
     * @param {WitnessSignatureDeleteManyArgs} args - Arguments to filter WitnessSignatures to delete.
     * @example
     * // Delete a few WitnessSignatures
     * const { count } = await prisma.witnessSignature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WitnessSignatureDeleteManyArgs>(args?: SelectSubset<T, WitnessSignatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WitnessSignatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessSignatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WitnessSignatures
     * const witnessSignature = await prisma.witnessSignature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WitnessSignatureUpdateManyArgs>(args: SelectSubset<T, WitnessSignatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WitnessSignatures and returns the data updated in the database.
     * @param {WitnessSignatureUpdateManyAndReturnArgs} args - Arguments to update many WitnessSignatures.
     * @example
     * // Update many WitnessSignatures
     * const witnessSignature = await prisma.witnessSignature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WitnessSignatures and only return the `id`
     * const witnessSignatureWithIdOnly = await prisma.witnessSignature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WitnessSignatureUpdateManyAndReturnArgs>(args: SelectSubset<T, WitnessSignatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WitnessSignaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WitnessSignature.
     * @param {WitnessSignatureUpsertArgs} args - Arguments to update or create a WitnessSignature.
     * @example
     * // Update or create a WitnessSignature
     * const witnessSignature = await prisma.witnessSignature.upsert({
     *   create: {
     *     // ... data to create a WitnessSignature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WitnessSignature we want to update
     *   }
     * })
     */
    upsert<T extends WitnessSignatureUpsertArgs>(args: SelectSubset<T, WitnessSignatureUpsertArgs<ExtArgs>>): Prisma__WitnessSignatureClient<$Result.GetResult<Prisma.$WitnessSignaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WitnessSignatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessSignatureCountArgs} args - Arguments to filter WitnessSignatures to count.
     * @example
     * // Count the number of WitnessSignatures
     * const count = await prisma.witnessSignature.count({
     *   where: {
     *     // ... the filter for the WitnessSignatures we want to count
     *   }
     * })
    **/
    count<T extends WitnessSignatureCountArgs>(
      args?: Subset<T, WitnessSignatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WitnessSignatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WitnessSignature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessSignatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WitnessSignatureAggregateArgs>(args: Subset<T, WitnessSignatureAggregateArgs>): Prisma.PrismaPromise<GetWitnessSignatureAggregateType<T>>

    /**
     * Group by WitnessSignature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WitnessSignatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WitnessSignatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WitnessSignatureGroupByArgs['orderBy'] }
        : { orderBy?: WitnessSignatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WitnessSignatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWitnessSignatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WitnessSignature model
   */
  readonly fields: WitnessSignatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WitnessSignature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WitnessSignatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WitnessSignature model
   */
  interface WitnessSignatureFieldRefs {
    readonly id: FieldRef<"WitnessSignature", 'Int'>
    readonly modelName: FieldRef<"WitnessSignature", 'String'>
    readonly modelFingerprint: FieldRef<"WitnessSignature", 'String'>
    readonly receiptId: FieldRef<"WitnessSignature", 'Int'>
    readonly receiptDigest: FieldRef<"WitnessSignature", 'String'>
    readonly signature: FieldRef<"WitnessSignature", 'String'>
    readonly signedAt: FieldRef<"WitnessSignature", 'DateTime'>
    readonly lamportClock: FieldRef<"WitnessSignature", 'Int'>
    readonly verified: FieldRef<"WitnessSignature", 'Boolean'>
    readonly verifiedAt: FieldRef<"WitnessSignature", 'DateTime'>
    readonly verificationData: FieldRef<"WitnessSignature", 'Json'>
    readonly metadata: FieldRef<"WitnessSignature", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * WitnessSignature findUnique
   */
  export type WitnessSignatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessSignature
     */
    select?: WitnessSignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WitnessSignature
     */
    omit?: WitnessSignatureOmit<ExtArgs> | null
    /**
     * Filter, which WitnessSignature to fetch.
     */
    where: WitnessSignatureWhereUniqueInput
  }

  /**
   * WitnessSignature findUniqueOrThrow
   */
  export type WitnessSignatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessSignature
     */
    select?: WitnessSignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WitnessSignature
     */
    omit?: WitnessSignatureOmit<ExtArgs> | null
    /**
     * Filter, which WitnessSignature to fetch.
     */
    where: WitnessSignatureWhereUniqueInput
  }

  /**
   * WitnessSignature findFirst
   */
  export type WitnessSignatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessSignature
     */
    select?: WitnessSignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WitnessSignature
     */
    omit?: WitnessSignatureOmit<ExtArgs> | null
    /**
     * Filter, which WitnessSignature to fetch.
     */
    where?: WitnessSignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WitnessSignatures to fetch.
     */
    orderBy?: WitnessSignatureOrderByWithRelationInput | WitnessSignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WitnessSignatures.
     */
    cursor?: WitnessSignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WitnessSignatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WitnessSignatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WitnessSignatures.
     */
    distinct?: WitnessSignatureScalarFieldEnum | WitnessSignatureScalarFieldEnum[]
  }

  /**
   * WitnessSignature findFirstOrThrow
   */
  export type WitnessSignatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessSignature
     */
    select?: WitnessSignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WitnessSignature
     */
    omit?: WitnessSignatureOmit<ExtArgs> | null
    /**
     * Filter, which WitnessSignature to fetch.
     */
    where?: WitnessSignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WitnessSignatures to fetch.
     */
    orderBy?: WitnessSignatureOrderByWithRelationInput | WitnessSignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WitnessSignatures.
     */
    cursor?: WitnessSignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WitnessSignatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WitnessSignatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WitnessSignatures.
     */
    distinct?: WitnessSignatureScalarFieldEnum | WitnessSignatureScalarFieldEnum[]
  }

  /**
   * WitnessSignature findMany
   */
  export type WitnessSignatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessSignature
     */
    select?: WitnessSignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WitnessSignature
     */
    omit?: WitnessSignatureOmit<ExtArgs> | null
    /**
     * Filter, which WitnessSignatures to fetch.
     */
    where?: WitnessSignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WitnessSignatures to fetch.
     */
    orderBy?: WitnessSignatureOrderByWithRelationInput | WitnessSignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WitnessSignatures.
     */
    cursor?: WitnessSignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WitnessSignatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WitnessSignatures.
     */
    skip?: number
    distinct?: WitnessSignatureScalarFieldEnum | WitnessSignatureScalarFieldEnum[]
  }

  /**
   * WitnessSignature create
   */
  export type WitnessSignatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessSignature
     */
    select?: WitnessSignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WitnessSignature
     */
    omit?: WitnessSignatureOmit<ExtArgs> | null
    /**
     * The data needed to create a WitnessSignature.
     */
    data: XOR<WitnessSignatureCreateInput, WitnessSignatureUncheckedCreateInput>
  }

  /**
   * WitnessSignature createMany
   */
  export type WitnessSignatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WitnessSignatures.
     */
    data: WitnessSignatureCreateManyInput | WitnessSignatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WitnessSignature createManyAndReturn
   */
  export type WitnessSignatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessSignature
     */
    select?: WitnessSignatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WitnessSignature
     */
    omit?: WitnessSignatureOmit<ExtArgs> | null
    /**
     * The data used to create many WitnessSignatures.
     */
    data: WitnessSignatureCreateManyInput | WitnessSignatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WitnessSignature update
   */
  export type WitnessSignatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessSignature
     */
    select?: WitnessSignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WitnessSignature
     */
    omit?: WitnessSignatureOmit<ExtArgs> | null
    /**
     * The data needed to update a WitnessSignature.
     */
    data: XOR<WitnessSignatureUpdateInput, WitnessSignatureUncheckedUpdateInput>
    /**
     * Choose, which WitnessSignature to update.
     */
    where: WitnessSignatureWhereUniqueInput
  }

  /**
   * WitnessSignature updateMany
   */
  export type WitnessSignatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WitnessSignatures.
     */
    data: XOR<WitnessSignatureUpdateManyMutationInput, WitnessSignatureUncheckedUpdateManyInput>
    /**
     * Filter which WitnessSignatures to update
     */
    where?: WitnessSignatureWhereInput
    /**
     * Limit how many WitnessSignatures to update.
     */
    limit?: number
  }

  /**
   * WitnessSignature updateManyAndReturn
   */
  export type WitnessSignatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessSignature
     */
    select?: WitnessSignatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WitnessSignature
     */
    omit?: WitnessSignatureOmit<ExtArgs> | null
    /**
     * The data used to update WitnessSignatures.
     */
    data: XOR<WitnessSignatureUpdateManyMutationInput, WitnessSignatureUncheckedUpdateManyInput>
    /**
     * Filter which WitnessSignatures to update
     */
    where?: WitnessSignatureWhereInput
    /**
     * Limit how many WitnessSignatures to update.
     */
    limit?: number
  }

  /**
   * WitnessSignature upsert
   */
  export type WitnessSignatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessSignature
     */
    select?: WitnessSignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WitnessSignature
     */
    omit?: WitnessSignatureOmit<ExtArgs> | null
    /**
     * The filter to search for the WitnessSignature to update in case it exists.
     */
    where: WitnessSignatureWhereUniqueInput
    /**
     * In case the WitnessSignature found by the `where` argument doesn't exist, create a new WitnessSignature with this data.
     */
    create: XOR<WitnessSignatureCreateInput, WitnessSignatureUncheckedCreateInput>
    /**
     * In case the WitnessSignature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WitnessSignatureUpdateInput, WitnessSignatureUncheckedUpdateInput>
  }

  /**
   * WitnessSignature delete
   */
  export type WitnessSignatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessSignature
     */
    select?: WitnessSignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WitnessSignature
     */
    omit?: WitnessSignatureOmit<ExtArgs> | null
    /**
     * Filter which WitnessSignature to delete.
     */
    where: WitnessSignatureWhereUniqueInput
  }

  /**
   * WitnessSignature deleteMany
   */
  export type WitnessSignatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WitnessSignatures to delete
     */
    where?: WitnessSignatureWhereInput
    /**
     * Limit how many WitnessSignatures to delete.
     */
    limit?: number
  }

  /**
   * WitnessSignature without action
   */
  export type WitnessSignatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WitnessSignature
     */
    select?: WitnessSignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WitnessSignature
     */
    omit?: WitnessSignatureOmit<ExtArgs> | null
  }


  /**
   * Model CRIESComputation
   */

  export type AggregateCRIESComputation = {
    _count: CRIESComputationCountAggregateOutputType | null
    _avg: CRIESComputationAvgAggregateOutputType | null
    _sum: CRIESComputationSumAggregateOutputType | null
    _min: CRIESComputationMinAggregateOutputType | null
    _max: CRIESComputationMaxAggregateOutputType | null
  }

  export type CRIESComputationAvgAggregateOutputType = {
    id: number | null
    testResultId: number | null
    userId: number | null
    sigmaWindow: number | null
    tauThreshold: number | null
    piPolicy: number | null
    citationQuality: number | null
    criesScore: number | null
    lamportClock: number | null
    receiptId: number | null
  }

  export type CRIESComputationSumAggregateOutputType = {
    id: number | null
    testResultId: number | null
    userId: number | null
    sigmaWindow: number | null
    tauThreshold: number | null
    piPolicy: number | null
    citationQuality: number | null
    criesScore: number | null
    lamportClock: number | null
    receiptId: number | null
  }

  export type CRIESComputationMinAggregateOutputType = {
    id: number | null
    testResultId: number | null
    userId: number | null
    sigmaWindow: number | null
    tauThreshold: number | null
    piPolicy: number | null
    citationQuality: number | null
    criesScore: number | null
    lamportClock: number | null
    computedAt: Date | null
    receiptId: number | null
  }

  export type CRIESComputationMaxAggregateOutputType = {
    id: number | null
    testResultId: number | null
    userId: number | null
    sigmaWindow: number | null
    tauThreshold: number | null
    piPolicy: number | null
    citationQuality: number | null
    criesScore: number | null
    lamportClock: number | null
    computedAt: Date | null
    receiptId: number | null
  }

  export type CRIESComputationCountAggregateOutputType = {
    id: number
    testResultId: number
    userId: number
    sigmaWindow: number
    tauThreshold: number
    piPolicy: number
    citationQuality: number
    criesScore: number
    lamportClock: number
    computedAt: number
    receiptId: number
    analysisData: number
    metadata: number
    _all: number
  }


  export type CRIESComputationAvgAggregateInputType = {
    id?: true
    testResultId?: true
    userId?: true
    sigmaWindow?: true
    tauThreshold?: true
    piPolicy?: true
    citationQuality?: true
    criesScore?: true
    lamportClock?: true
    receiptId?: true
  }

  export type CRIESComputationSumAggregateInputType = {
    id?: true
    testResultId?: true
    userId?: true
    sigmaWindow?: true
    tauThreshold?: true
    piPolicy?: true
    citationQuality?: true
    criesScore?: true
    lamportClock?: true
    receiptId?: true
  }

  export type CRIESComputationMinAggregateInputType = {
    id?: true
    testResultId?: true
    userId?: true
    sigmaWindow?: true
    tauThreshold?: true
    piPolicy?: true
    citationQuality?: true
    criesScore?: true
    lamportClock?: true
    computedAt?: true
    receiptId?: true
  }

  export type CRIESComputationMaxAggregateInputType = {
    id?: true
    testResultId?: true
    userId?: true
    sigmaWindow?: true
    tauThreshold?: true
    piPolicy?: true
    citationQuality?: true
    criesScore?: true
    lamportClock?: true
    computedAt?: true
    receiptId?: true
  }

  export type CRIESComputationCountAggregateInputType = {
    id?: true
    testResultId?: true
    userId?: true
    sigmaWindow?: true
    tauThreshold?: true
    piPolicy?: true
    citationQuality?: true
    criesScore?: true
    lamportClock?: true
    computedAt?: true
    receiptId?: true
    analysisData?: true
    metadata?: true
    _all?: true
  }

  export type CRIESComputationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CRIESComputation to aggregate.
     */
    where?: CRIESComputationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CRIESComputations to fetch.
     */
    orderBy?: CRIESComputationOrderByWithRelationInput | CRIESComputationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CRIESComputationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CRIESComputations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CRIESComputations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CRIESComputations
    **/
    _count?: true | CRIESComputationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CRIESComputationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CRIESComputationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CRIESComputationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CRIESComputationMaxAggregateInputType
  }

  export type GetCRIESComputationAggregateType<T extends CRIESComputationAggregateArgs> = {
        [P in keyof T & keyof AggregateCRIESComputation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCRIESComputation[P]>
      : GetScalarType<T[P], AggregateCRIESComputation[P]>
  }




  export type CRIESComputationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CRIESComputationWhereInput
    orderBy?: CRIESComputationOrderByWithAggregationInput | CRIESComputationOrderByWithAggregationInput[]
    by: CRIESComputationScalarFieldEnum[] | CRIESComputationScalarFieldEnum
    having?: CRIESComputationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CRIESComputationCountAggregateInputType | true
    _avg?: CRIESComputationAvgAggregateInputType
    _sum?: CRIESComputationSumAggregateInputType
    _min?: CRIESComputationMinAggregateInputType
    _max?: CRIESComputationMaxAggregateInputType
  }

  export type CRIESComputationGroupByOutputType = {
    id: number
    testResultId: number | null
    userId: number | null
    sigmaWindow: number
    tauThreshold: number
    piPolicy: number
    citationQuality: number
    criesScore: number
    lamportClock: number
    computedAt: Date
    receiptId: number | null
    analysisData: JsonValue | null
    metadata: JsonValue | null
    _count: CRIESComputationCountAggregateOutputType | null
    _avg: CRIESComputationAvgAggregateOutputType | null
    _sum: CRIESComputationSumAggregateOutputType | null
    _min: CRIESComputationMinAggregateOutputType | null
    _max: CRIESComputationMaxAggregateOutputType | null
  }

  type GetCRIESComputationGroupByPayload<T extends CRIESComputationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CRIESComputationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CRIESComputationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CRIESComputationGroupByOutputType[P]>
            : GetScalarType<T[P], CRIESComputationGroupByOutputType[P]>
        }
      >
    >


  export type CRIESComputationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testResultId?: boolean
    userId?: boolean
    sigmaWindow?: boolean
    tauThreshold?: boolean
    piPolicy?: boolean
    citationQuality?: boolean
    criesScore?: boolean
    lamportClock?: boolean
    computedAt?: boolean
    receiptId?: boolean
    analysisData?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["cRIESComputation"]>

  export type CRIESComputationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testResultId?: boolean
    userId?: boolean
    sigmaWindow?: boolean
    tauThreshold?: boolean
    piPolicy?: boolean
    citationQuality?: boolean
    criesScore?: boolean
    lamportClock?: boolean
    computedAt?: boolean
    receiptId?: boolean
    analysisData?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["cRIESComputation"]>

  export type CRIESComputationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testResultId?: boolean
    userId?: boolean
    sigmaWindow?: boolean
    tauThreshold?: boolean
    piPolicy?: boolean
    citationQuality?: boolean
    criesScore?: boolean
    lamportClock?: boolean
    computedAt?: boolean
    receiptId?: boolean
    analysisData?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["cRIESComputation"]>

  export type CRIESComputationSelectScalar = {
    id?: boolean
    testResultId?: boolean
    userId?: boolean
    sigmaWindow?: boolean
    tauThreshold?: boolean
    piPolicy?: boolean
    citationQuality?: boolean
    criesScore?: boolean
    lamportClock?: boolean
    computedAt?: boolean
    receiptId?: boolean
    analysisData?: boolean
    metadata?: boolean
  }

  export type CRIESComputationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "testResultId" | "userId" | "sigmaWindow" | "tauThreshold" | "piPolicy" | "citationQuality" | "criesScore" | "lamportClock" | "computedAt" | "receiptId" | "analysisData" | "metadata", ExtArgs["result"]["cRIESComputation"]>

  export type $CRIESComputationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CRIESComputation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      testResultId: number | null
      userId: number | null
      sigmaWindow: number
      tauThreshold: number
      piPolicy: number
      citationQuality: number
      criesScore: number
      lamportClock: number
      computedAt: Date
      receiptId: number | null
      analysisData: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["cRIESComputation"]>
    composites: {}
  }

  type CRIESComputationGetPayload<S extends boolean | null | undefined | CRIESComputationDefaultArgs> = $Result.GetResult<Prisma.$CRIESComputationPayload, S>

  type CRIESComputationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CRIESComputationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CRIESComputationCountAggregateInputType | true
    }

  export interface CRIESComputationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CRIESComputation'], meta: { name: 'CRIESComputation' } }
    /**
     * Find zero or one CRIESComputation that matches the filter.
     * @param {CRIESComputationFindUniqueArgs} args - Arguments to find a CRIESComputation
     * @example
     * // Get one CRIESComputation
     * const cRIESComputation = await prisma.cRIESComputation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CRIESComputationFindUniqueArgs>(args: SelectSubset<T, CRIESComputationFindUniqueArgs<ExtArgs>>): Prisma__CRIESComputationClient<$Result.GetResult<Prisma.$CRIESComputationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CRIESComputation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CRIESComputationFindUniqueOrThrowArgs} args - Arguments to find a CRIESComputation
     * @example
     * // Get one CRIESComputation
     * const cRIESComputation = await prisma.cRIESComputation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CRIESComputationFindUniqueOrThrowArgs>(args: SelectSubset<T, CRIESComputationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CRIESComputationClient<$Result.GetResult<Prisma.$CRIESComputationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CRIESComputation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CRIESComputationFindFirstArgs} args - Arguments to find a CRIESComputation
     * @example
     * // Get one CRIESComputation
     * const cRIESComputation = await prisma.cRIESComputation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CRIESComputationFindFirstArgs>(args?: SelectSubset<T, CRIESComputationFindFirstArgs<ExtArgs>>): Prisma__CRIESComputationClient<$Result.GetResult<Prisma.$CRIESComputationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CRIESComputation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CRIESComputationFindFirstOrThrowArgs} args - Arguments to find a CRIESComputation
     * @example
     * // Get one CRIESComputation
     * const cRIESComputation = await prisma.cRIESComputation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CRIESComputationFindFirstOrThrowArgs>(args?: SelectSubset<T, CRIESComputationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CRIESComputationClient<$Result.GetResult<Prisma.$CRIESComputationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CRIESComputations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CRIESComputationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CRIESComputations
     * const cRIESComputations = await prisma.cRIESComputation.findMany()
     * 
     * // Get first 10 CRIESComputations
     * const cRIESComputations = await prisma.cRIESComputation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cRIESComputationWithIdOnly = await prisma.cRIESComputation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CRIESComputationFindManyArgs>(args?: SelectSubset<T, CRIESComputationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CRIESComputationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CRIESComputation.
     * @param {CRIESComputationCreateArgs} args - Arguments to create a CRIESComputation.
     * @example
     * // Create one CRIESComputation
     * const CRIESComputation = await prisma.cRIESComputation.create({
     *   data: {
     *     // ... data to create a CRIESComputation
     *   }
     * })
     * 
     */
    create<T extends CRIESComputationCreateArgs>(args: SelectSubset<T, CRIESComputationCreateArgs<ExtArgs>>): Prisma__CRIESComputationClient<$Result.GetResult<Prisma.$CRIESComputationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CRIESComputations.
     * @param {CRIESComputationCreateManyArgs} args - Arguments to create many CRIESComputations.
     * @example
     * // Create many CRIESComputations
     * const cRIESComputation = await prisma.cRIESComputation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CRIESComputationCreateManyArgs>(args?: SelectSubset<T, CRIESComputationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CRIESComputations and returns the data saved in the database.
     * @param {CRIESComputationCreateManyAndReturnArgs} args - Arguments to create many CRIESComputations.
     * @example
     * // Create many CRIESComputations
     * const cRIESComputation = await prisma.cRIESComputation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CRIESComputations and only return the `id`
     * const cRIESComputationWithIdOnly = await prisma.cRIESComputation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CRIESComputationCreateManyAndReturnArgs>(args?: SelectSubset<T, CRIESComputationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CRIESComputationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CRIESComputation.
     * @param {CRIESComputationDeleteArgs} args - Arguments to delete one CRIESComputation.
     * @example
     * // Delete one CRIESComputation
     * const CRIESComputation = await prisma.cRIESComputation.delete({
     *   where: {
     *     // ... filter to delete one CRIESComputation
     *   }
     * })
     * 
     */
    delete<T extends CRIESComputationDeleteArgs>(args: SelectSubset<T, CRIESComputationDeleteArgs<ExtArgs>>): Prisma__CRIESComputationClient<$Result.GetResult<Prisma.$CRIESComputationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CRIESComputation.
     * @param {CRIESComputationUpdateArgs} args - Arguments to update one CRIESComputation.
     * @example
     * // Update one CRIESComputation
     * const cRIESComputation = await prisma.cRIESComputation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CRIESComputationUpdateArgs>(args: SelectSubset<T, CRIESComputationUpdateArgs<ExtArgs>>): Prisma__CRIESComputationClient<$Result.GetResult<Prisma.$CRIESComputationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CRIESComputations.
     * @param {CRIESComputationDeleteManyArgs} args - Arguments to filter CRIESComputations to delete.
     * @example
     * // Delete a few CRIESComputations
     * const { count } = await prisma.cRIESComputation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CRIESComputationDeleteManyArgs>(args?: SelectSubset<T, CRIESComputationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CRIESComputations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CRIESComputationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CRIESComputations
     * const cRIESComputation = await prisma.cRIESComputation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CRIESComputationUpdateManyArgs>(args: SelectSubset<T, CRIESComputationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CRIESComputations and returns the data updated in the database.
     * @param {CRIESComputationUpdateManyAndReturnArgs} args - Arguments to update many CRIESComputations.
     * @example
     * // Update many CRIESComputations
     * const cRIESComputation = await prisma.cRIESComputation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CRIESComputations and only return the `id`
     * const cRIESComputationWithIdOnly = await prisma.cRIESComputation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CRIESComputationUpdateManyAndReturnArgs>(args: SelectSubset<T, CRIESComputationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CRIESComputationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CRIESComputation.
     * @param {CRIESComputationUpsertArgs} args - Arguments to update or create a CRIESComputation.
     * @example
     * // Update or create a CRIESComputation
     * const cRIESComputation = await prisma.cRIESComputation.upsert({
     *   create: {
     *     // ... data to create a CRIESComputation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CRIESComputation we want to update
     *   }
     * })
     */
    upsert<T extends CRIESComputationUpsertArgs>(args: SelectSubset<T, CRIESComputationUpsertArgs<ExtArgs>>): Prisma__CRIESComputationClient<$Result.GetResult<Prisma.$CRIESComputationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CRIESComputations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CRIESComputationCountArgs} args - Arguments to filter CRIESComputations to count.
     * @example
     * // Count the number of CRIESComputations
     * const count = await prisma.cRIESComputation.count({
     *   where: {
     *     // ... the filter for the CRIESComputations we want to count
     *   }
     * })
    **/
    count<T extends CRIESComputationCountArgs>(
      args?: Subset<T, CRIESComputationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CRIESComputationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CRIESComputation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CRIESComputationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CRIESComputationAggregateArgs>(args: Subset<T, CRIESComputationAggregateArgs>): Prisma.PrismaPromise<GetCRIESComputationAggregateType<T>>

    /**
     * Group by CRIESComputation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CRIESComputationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CRIESComputationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CRIESComputationGroupByArgs['orderBy'] }
        : { orderBy?: CRIESComputationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CRIESComputationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCRIESComputationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CRIESComputation model
   */
  readonly fields: CRIESComputationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CRIESComputation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CRIESComputationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CRIESComputation model
   */
  interface CRIESComputationFieldRefs {
    readonly id: FieldRef<"CRIESComputation", 'Int'>
    readonly testResultId: FieldRef<"CRIESComputation", 'Int'>
    readonly userId: FieldRef<"CRIESComputation", 'Int'>
    readonly sigmaWindow: FieldRef<"CRIESComputation", 'Float'>
    readonly tauThreshold: FieldRef<"CRIESComputation", 'Float'>
    readonly piPolicy: FieldRef<"CRIESComputation", 'Float'>
    readonly citationQuality: FieldRef<"CRIESComputation", 'Float'>
    readonly criesScore: FieldRef<"CRIESComputation", 'Float'>
    readonly lamportClock: FieldRef<"CRIESComputation", 'Int'>
    readonly computedAt: FieldRef<"CRIESComputation", 'DateTime'>
    readonly receiptId: FieldRef<"CRIESComputation", 'Int'>
    readonly analysisData: FieldRef<"CRIESComputation", 'Json'>
    readonly metadata: FieldRef<"CRIESComputation", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * CRIESComputation findUnique
   */
  export type CRIESComputationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CRIESComputation
     */
    select?: CRIESComputationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CRIESComputation
     */
    omit?: CRIESComputationOmit<ExtArgs> | null
    /**
     * Filter, which CRIESComputation to fetch.
     */
    where: CRIESComputationWhereUniqueInput
  }

  /**
   * CRIESComputation findUniqueOrThrow
   */
  export type CRIESComputationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CRIESComputation
     */
    select?: CRIESComputationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CRIESComputation
     */
    omit?: CRIESComputationOmit<ExtArgs> | null
    /**
     * Filter, which CRIESComputation to fetch.
     */
    where: CRIESComputationWhereUniqueInput
  }

  /**
   * CRIESComputation findFirst
   */
  export type CRIESComputationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CRIESComputation
     */
    select?: CRIESComputationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CRIESComputation
     */
    omit?: CRIESComputationOmit<ExtArgs> | null
    /**
     * Filter, which CRIESComputation to fetch.
     */
    where?: CRIESComputationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CRIESComputations to fetch.
     */
    orderBy?: CRIESComputationOrderByWithRelationInput | CRIESComputationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CRIESComputations.
     */
    cursor?: CRIESComputationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CRIESComputations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CRIESComputations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CRIESComputations.
     */
    distinct?: CRIESComputationScalarFieldEnum | CRIESComputationScalarFieldEnum[]
  }

  /**
   * CRIESComputation findFirstOrThrow
   */
  export type CRIESComputationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CRIESComputation
     */
    select?: CRIESComputationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CRIESComputation
     */
    omit?: CRIESComputationOmit<ExtArgs> | null
    /**
     * Filter, which CRIESComputation to fetch.
     */
    where?: CRIESComputationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CRIESComputations to fetch.
     */
    orderBy?: CRIESComputationOrderByWithRelationInput | CRIESComputationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CRIESComputations.
     */
    cursor?: CRIESComputationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CRIESComputations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CRIESComputations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CRIESComputations.
     */
    distinct?: CRIESComputationScalarFieldEnum | CRIESComputationScalarFieldEnum[]
  }

  /**
   * CRIESComputation findMany
   */
  export type CRIESComputationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CRIESComputation
     */
    select?: CRIESComputationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CRIESComputation
     */
    omit?: CRIESComputationOmit<ExtArgs> | null
    /**
     * Filter, which CRIESComputations to fetch.
     */
    where?: CRIESComputationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CRIESComputations to fetch.
     */
    orderBy?: CRIESComputationOrderByWithRelationInput | CRIESComputationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CRIESComputations.
     */
    cursor?: CRIESComputationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CRIESComputations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CRIESComputations.
     */
    skip?: number
    distinct?: CRIESComputationScalarFieldEnum | CRIESComputationScalarFieldEnum[]
  }

  /**
   * CRIESComputation create
   */
  export type CRIESComputationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CRIESComputation
     */
    select?: CRIESComputationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CRIESComputation
     */
    omit?: CRIESComputationOmit<ExtArgs> | null
    /**
     * The data needed to create a CRIESComputation.
     */
    data: XOR<CRIESComputationCreateInput, CRIESComputationUncheckedCreateInput>
  }

  /**
   * CRIESComputation createMany
   */
  export type CRIESComputationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CRIESComputations.
     */
    data: CRIESComputationCreateManyInput | CRIESComputationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CRIESComputation createManyAndReturn
   */
  export type CRIESComputationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CRIESComputation
     */
    select?: CRIESComputationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CRIESComputation
     */
    omit?: CRIESComputationOmit<ExtArgs> | null
    /**
     * The data used to create many CRIESComputations.
     */
    data: CRIESComputationCreateManyInput | CRIESComputationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CRIESComputation update
   */
  export type CRIESComputationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CRIESComputation
     */
    select?: CRIESComputationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CRIESComputation
     */
    omit?: CRIESComputationOmit<ExtArgs> | null
    /**
     * The data needed to update a CRIESComputation.
     */
    data: XOR<CRIESComputationUpdateInput, CRIESComputationUncheckedUpdateInput>
    /**
     * Choose, which CRIESComputation to update.
     */
    where: CRIESComputationWhereUniqueInput
  }

  /**
   * CRIESComputation updateMany
   */
  export type CRIESComputationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CRIESComputations.
     */
    data: XOR<CRIESComputationUpdateManyMutationInput, CRIESComputationUncheckedUpdateManyInput>
    /**
     * Filter which CRIESComputations to update
     */
    where?: CRIESComputationWhereInput
    /**
     * Limit how many CRIESComputations to update.
     */
    limit?: number
  }

  /**
   * CRIESComputation updateManyAndReturn
   */
  export type CRIESComputationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CRIESComputation
     */
    select?: CRIESComputationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CRIESComputation
     */
    omit?: CRIESComputationOmit<ExtArgs> | null
    /**
     * The data used to update CRIESComputations.
     */
    data: XOR<CRIESComputationUpdateManyMutationInput, CRIESComputationUncheckedUpdateManyInput>
    /**
     * Filter which CRIESComputations to update
     */
    where?: CRIESComputationWhereInput
    /**
     * Limit how many CRIESComputations to update.
     */
    limit?: number
  }

  /**
   * CRIESComputation upsert
   */
  export type CRIESComputationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CRIESComputation
     */
    select?: CRIESComputationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CRIESComputation
     */
    omit?: CRIESComputationOmit<ExtArgs> | null
    /**
     * The filter to search for the CRIESComputation to update in case it exists.
     */
    where: CRIESComputationWhereUniqueInput
    /**
     * In case the CRIESComputation found by the `where` argument doesn't exist, create a new CRIESComputation with this data.
     */
    create: XOR<CRIESComputationCreateInput, CRIESComputationUncheckedCreateInput>
    /**
     * In case the CRIESComputation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CRIESComputationUpdateInput, CRIESComputationUncheckedUpdateInput>
  }

  /**
   * CRIESComputation delete
   */
  export type CRIESComputationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CRIESComputation
     */
    select?: CRIESComputationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CRIESComputation
     */
    omit?: CRIESComputationOmit<ExtArgs> | null
    /**
     * Filter which CRIESComputation to delete.
     */
    where: CRIESComputationWhereUniqueInput
  }

  /**
   * CRIESComputation deleteMany
   */
  export type CRIESComputationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CRIESComputations to delete
     */
    where?: CRIESComputationWhereInput
    /**
     * Limit how many CRIESComputations to delete.
     */
    limit?: number
  }

  /**
   * CRIESComputation without action
   */
  export type CRIESComputationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CRIESComputation
     */
    select?: CRIESComputationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CRIESComputation
     */
    omit?: CRIESComputationOmit<ExtArgs> | null
  }


  /**
   * Model ZScanVerification
   */

  export type AggregateZScanVerification = {
    _count: ZScanVerificationCountAggregateOutputType | null
    _avg: ZScanVerificationAvgAggregateOutputType | null
    _sum: ZScanVerificationSumAggregateOutputType | null
    _min: ZScanVerificationMinAggregateOutputType | null
    _max: ZScanVerificationMaxAggregateOutputType | null
  }

  export type ZScanVerificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    totalRules: number | null
    passed: number | null
    warnings: number | null
    critical: number | null
  }

  export type ZScanVerificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
    totalRules: number | null
    passed: number | null
    warnings: number | null
    critical: number | null
  }

  export type ZScanVerificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    totalRules: number | null
    passed: number | null
    warnings: number | null
    critical: number | null
    createdAt: Date | null
  }

  export type ZScanVerificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    totalRules: number | null
    passed: number | null
    warnings: number | null
    critical: number | null
    createdAt: Date | null
  }

  export type ZScanVerificationCountAggregateOutputType = {
    id: number
    userId: number
    totalRules: number
    passed: number
    warnings: number
    critical: number
    results: number
    config: number
    createdAt: number
    _all: number
  }


  export type ZScanVerificationAvgAggregateInputType = {
    id?: true
    userId?: true
    totalRules?: true
    passed?: true
    warnings?: true
    critical?: true
  }

  export type ZScanVerificationSumAggregateInputType = {
    id?: true
    userId?: true
    totalRules?: true
    passed?: true
    warnings?: true
    critical?: true
  }

  export type ZScanVerificationMinAggregateInputType = {
    id?: true
    userId?: true
    totalRules?: true
    passed?: true
    warnings?: true
    critical?: true
    createdAt?: true
  }

  export type ZScanVerificationMaxAggregateInputType = {
    id?: true
    userId?: true
    totalRules?: true
    passed?: true
    warnings?: true
    critical?: true
    createdAt?: true
  }

  export type ZScanVerificationCountAggregateInputType = {
    id?: true
    userId?: true
    totalRules?: true
    passed?: true
    warnings?: true
    critical?: true
    results?: true
    config?: true
    createdAt?: true
    _all?: true
  }

  export type ZScanVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZScanVerification to aggregate.
     */
    where?: ZScanVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZScanVerifications to fetch.
     */
    orderBy?: ZScanVerificationOrderByWithRelationInput | ZScanVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZScanVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZScanVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZScanVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ZScanVerifications
    **/
    _count?: true | ZScanVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZScanVerificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZScanVerificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZScanVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZScanVerificationMaxAggregateInputType
  }

  export type GetZScanVerificationAggregateType<T extends ZScanVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateZScanVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZScanVerification[P]>
      : GetScalarType<T[P], AggregateZScanVerification[P]>
  }




  export type ZScanVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZScanVerificationWhereInput
    orderBy?: ZScanVerificationOrderByWithAggregationInput | ZScanVerificationOrderByWithAggregationInput[]
    by: ZScanVerificationScalarFieldEnum[] | ZScanVerificationScalarFieldEnum
    having?: ZScanVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZScanVerificationCountAggregateInputType | true
    _avg?: ZScanVerificationAvgAggregateInputType
    _sum?: ZScanVerificationSumAggregateInputType
    _min?: ZScanVerificationMinAggregateInputType
    _max?: ZScanVerificationMaxAggregateInputType
  }

  export type ZScanVerificationGroupByOutputType = {
    id: number
    userId: number | null
    totalRules: number
    passed: number
    warnings: number
    critical: number
    results: JsonValue
    config: JsonValue
    createdAt: Date
    _count: ZScanVerificationCountAggregateOutputType | null
    _avg: ZScanVerificationAvgAggregateOutputType | null
    _sum: ZScanVerificationSumAggregateOutputType | null
    _min: ZScanVerificationMinAggregateOutputType | null
    _max: ZScanVerificationMaxAggregateOutputType | null
  }

  type GetZScanVerificationGroupByPayload<T extends ZScanVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZScanVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZScanVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZScanVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], ZScanVerificationGroupByOutputType[P]>
        }
      >
    >


  export type ZScanVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalRules?: boolean
    passed?: boolean
    warnings?: boolean
    critical?: boolean
    results?: boolean
    config?: boolean
    createdAt?: boolean
    user?: boolean | ZScanVerification$userArgs<ExtArgs>
  }, ExtArgs["result"]["zScanVerification"]>

  export type ZScanVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalRules?: boolean
    passed?: boolean
    warnings?: boolean
    critical?: boolean
    results?: boolean
    config?: boolean
    createdAt?: boolean
    user?: boolean | ZScanVerification$userArgs<ExtArgs>
  }, ExtArgs["result"]["zScanVerification"]>

  export type ZScanVerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalRules?: boolean
    passed?: boolean
    warnings?: boolean
    critical?: boolean
    results?: boolean
    config?: boolean
    createdAt?: boolean
    user?: boolean | ZScanVerification$userArgs<ExtArgs>
  }, ExtArgs["result"]["zScanVerification"]>

  export type ZScanVerificationSelectScalar = {
    id?: boolean
    userId?: boolean
    totalRules?: boolean
    passed?: boolean
    warnings?: boolean
    critical?: boolean
    results?: boolean
    config?: boolean
    createdAt?: boolean
  }

  export type ZScanVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "totalRules" | "passed" | "warnings" | "critical" | "results" | "config" | "createdAt", ExtArgs["result"]["zScanVerification"]>
  export type ZScanVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ZScanVerification$userArgs<ExtArgs>
  }
  export type ZScanVerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ZScanVerification$userArgs<ExtArgs>
  }
  export type ZScanVerificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ZScanVerification$userArgs<ExtArgs>
  }

  export type $ZScanVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ZScanVerification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      totalRules: number
      passed: number
      warnings: number
      critical: number
      results: Prisma.JsonValue
      config: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["zScanVerification"]>
    composites: {}
  }

  type ZScanVerificationGetPayload<S extends boolean | null | undefined | ZScanVerificationDefaultArgs> = $Result.GetResult<Prisma.$ZScanVerificationPayload, S>

  type ZScanVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ZScanVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZScanVerificationCountAggregateInputType | true
    }

  export interface ZScanVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ZScanVerification'], meta: { name: 'ZScanVerification' } }
    /**
     * Find zero or one ZScanVerification that matches the filter.
     * @param {ZScanVerificationFindUniqueArgs} args - Arguments to find a ZScanVerification
     * @example
     * // Get one ZScanVerification
     * const zScanVerification = await prisma.zScanVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZScanVerificationFindUniqueArgs>(args: SelectSubset<T, ZScanVerificationFindUniqueArgs<ExtArgs>>): Prisma__ZScanVerificationClient<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ZScanVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ZScanVerificationFindUniqueOrThrowArgs} args - Arguments to find a ZScanVerification
     * @example
     * // Get one ZScanVerification
     * const zScanVerification = await prisma.zScanVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZScanVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, ZScanVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZScanVerificationClient<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ZScanVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZScanVerificationFindFirstArgs} args - Arguments to find a ZScanVerification
     * @example
     * // Get one ZScanVerification
     * const zScanVerification = await prisma.zScanVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZScanVerificationFindFirstArgs>(args?: SelectSubset<T, ZScanVerificationFindFirstArgs<ExtArgs>>): Prisma__ZScanVerificationClient<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ZScanVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZScanVerificationFindFirstOrThrowArgs} args - Arguments to find a ZScanVerification
     * @example
     * // Get one ZScanVerification
     * const zScanVerification = await prisma.zScanVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZScanVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, ZScanVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZScanVerificationClient<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ZScanVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZScanVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ZScanVerifications
     * const zScanVerifications = await prisma.zScanVerification.findMany()
     * 
     * // Get first 10 ZScanVerifications
     * const zScanVerifications = await prisma.zScanVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zScanVerificationWithIdOnly = await prisma.zScanVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ZScanVerificationFindManyArgs>(args?: SelectSubset<T, ZScanVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ZScanVerification.
     * @param {ZScanVerificationCreateArgs} args - Arguments to create a ZScanVerification.
     * @example
     * // Create one ZScanVerification
     * const ZScanVerification = await prisma.zScanVerification.create({
     *   data: {
     *     // ... data to create a ZScanVerification
     *   }
     * })
     * 
     */
    create<T extends ZScanVerificationCreateArgs>(args: SelectSubset<T, ZScanVerificationCreateArgs<ExtArgs>>): Prisma__ZScanVerificationClient<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ZScanVerifications.
     * @param {ZScanVerificationCreateManyArgs} args - Arguments to create many ZScanVerifications.
     * @example
     * // Create many ZScanVerifications
     * const zScanVerification = await prisma.zScanVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZScanVerificationCreateManyArgs>(args?: SelectSubset<T, ZScanVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ZScanVerifications and returns the data saved in the database.
     * @param {ZScanVerificationCreateManyAndReturnArgs} args - Arguments to create many ZScanVerifications.
     * @example
     * // Create many ZScanVerifications
     * const zScanVerification = await prisma.zScanVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ZScanVerifications and only return the `id`
     * const zScanVerificationWithIdOnly = await prisma.zScanVerification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZScanVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, ZScanVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ZScanVerification.
     * @param {ZScanVerificationDeleteArgs} args - Arguments to delete one ZScanVerification.
     * @example
     * // Delete one ZScanVerification
     * const ZScanVerification = await prisma.zScanVerification.delete({
     *   where: {
     *     // ... filter to delete one ZScanVerification
     *   }
     * })
     * 
     */
    delete<T extends ZScanVerificationDeleteArgs>(args: SelectSubset<T, ZScanVerificationDeleteArgs<ExtArgs>>): Prisma__ZScanVerificationClient<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ZScanVerification.
     * @param {ZScanVerificationUpdateArgs} args - Arguments to update one ZScanVerification.
     * @example
     * // Update one ZScanVerification
     * const zScanVerification = await prisma.zScanVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZScanVerificationUpdateArgs>(args: SelectSubset<T, ZScanVerificationUpdateArgs<ExtArgs>>): Prisma__ZScanVerificationClient<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ZScanVerifications.
     * @param {ZScanVerificationDeleteManyArgs} args - Arguments to filter ZScanVerifications to delete.
     * @example
     * // Delete a few ZScanVerifications
     * const { count } = await prisma.zScanVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZScanVerificationDeleteManyArgs>(args?: SelectSubset<T, ZScanVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZScanVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZScanVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ZScanVerifications
     * const zScanVerification = await prisma.zScanVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZScanVerificationUpdateManyArgs>(args: SelectSubset<T, ZScanVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZScanVerifications and returns the data updated in the database.
     * @param {ZScanVerificationUpdateManyAndReturnArgs} args - Arguments to update many ZScanVerifications.
     * @example
     * // Update many ZScanVerifications
     * const zScanVerification = await prisma.zScanVerification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ZScanVerifications and only return the `id`
     * const zScanVerificationWithIdOnly = await prisma.zScanVerification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ZScanVerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, ZScanVerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ZScanVerification.
     * @param {ZScanVerificationUpsertArgs} args - Arguments to update or create a ZScanVerification.
     * @example
     * // Update or create a ZScanVerification
     * const zScanVerification = await prisma.zScanVerification.upsert({
     *   create: {
     *     // ... data to create a ZScanVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ZScanVerification we want to update
     *   }
     * })
     */
    upsert<T extends ZScanVerificationUpsertArgs>(args: SelectSubset<T, ZScanVerificationUpsertArgs<ExtArgs>>): Prisma__ZScanVerificationClient<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ZScanVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZScanVerificationCountArgs} args - Arguments to filter ZScanVerifications to count.
     * @example
     * // Count the number of ZScanVerifications
     * const count = await prisma.zScanVerification.count({
     *   where: {
     *     // ... the filter for the ZScanVerifications we want to count
     *   }
     * })
    **/
    count<T extends ZScanVerificationCountArgs>(
      args?: Subset<T, ZScanVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZScanVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ZScanVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZScanVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZScanVerificationAggregateArgs>(args: Subset<T, ZScanVerificationAggregateArgs>): Prisma.PrismaPromise<GetZScanVerificationAggregateType<T>>

    /**
     * Group by ZScanVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZScanVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZScanVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZScanVerificationGroupByArgs['orderBy'] }
        : { orderBy?: ZScanVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZScanVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZScanVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ZScanVerification model
   */
  readonly fields: ZScanVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ZScanVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZScanVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ZScanVerification$userArgs<ExtArgs> = {}>(args?: Subset<T, ZScanVerification$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ZScanVerification model
   */
  interface ZScanVerificationFieldRefs {
    readonly id: FieldRef<"ZScanVerification", 'Int'>
    readonly userId: FieldRef<"ZScanVerification", 'Int'>
    readonly totalRules: FieldRef<"ZScanVerification", 'Int'>
    readonly passed: FieldRef<"ZScanVerification", 'Int'>
    readonly warnings: FieldRef<"ZScanVerification", 'Int'>
    readonly critical: FieldRef<"ZScanVerification", 'Int'>
    readonly results: FieldRef<"ZScanVerification", 'Json'>
    readonly config: FieldRef<"ZScanVerification", 'Json'>
    readonly createdAt: FieldRef<"ZScanVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ZScanVerification findUnique
   */
  export type ZScanVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
    /**
     * Filter, which ZScanVerification to fetch.
     */
    where: ZScanVerificationWhereUniqueInput
  }

  /**
   * ZScanVerification findUniqueOrThrow
   */
  export type ZScanVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
    /**
     * Filter, which ZScanVerification to fetch.
     */
    where: ZScanVerificationWhereUniqueInput
  }

  /**
   * ZScanVerification findFirst
   */
  export type ZScanVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
    /**
     * Filter, which ZScanVerification to fetch.
     */
    where?: ZScanVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZScanVerifications to fetch.
     */
    orderBy?: ZScanVerificationOrderByWithRelationInput | ZScanVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZScanVerifications.
     */
    cursor?: ZScanVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZScanVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZScanVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZScanVerifications.
     */
    distinct?: ZScanVerificationScalarFieldEnum | ZScanVerificationScalarFieldEnum[]
  }

  /**
   * ZScanVerification findFirstOrThrow
   */
  export type ZScanVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
    /**
     * Filter, which ZScanVerification to fetch.
     */
    where?: ZScanVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZScanVerifications to fetch.
     */
    orderBy?: ZScanVerificationOrderByWithRelationInput | ZScanVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZScanVerifications.
     */
    cursor?: ZScanVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZScanVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZScanVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZScanVerifications.
     */
    distinct?: ZScanVerificationScalarFieldEnum | ZScanVerificationScalarFieldEnum[]
  }

  /**
   * ZScanVerification findMany
   */
  export type ZScanVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
    /**
     * Filter, which ZScanVerifications to fetch.
     */
    where?: ZScanVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZScanVerifications to fetch.
     */
    orderBy?: ZScanVerificationOrderByWithRelationInput | ZScanVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ZScanVerifications.
     */
    cursor?: ZScanVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZScanVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZScanVerifications.
     */
    skip?: number
    distinct?: ZScanVerificationScalarFieldEnum | ZScanVerificationScalarFieldEnum[]
  }

  /**
   * ZScanVerification create
   */
  export type ZScanVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a ZScanVerification.
     */
    data: XOR<ZScanVerificationCreateInput, ZScanVerificationUncheckedCreateInput>
  }

  /**
   * ZScanVerification createMany
   */
  export type ZScanVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ZScanVerifications.
     */
    data: ZScanVerificationCreateManyInput | ZScanVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ZScanVerification createManyAndReturn
   */
  export type ZScanVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * The data used to create many ZScanVerifications.
     */
    data: ZScanVerificationCreateManyInput | ZScanVerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ZScanVerification update
   */
  export type ZScanVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a ZScanVerification.
     */
    data: XOR<ZScanVerificationUpdateInput, ZScanVerificationUncheckedUpdateInput>
    /**
     * Choose, which ZScanVerification to update.
     */
    where: ZScanVerificationWhereUniqueInput
  }

  /**
   * ZScanVerification updateMany
   */
  export type ZScanVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ZScanVerifications.
     */
    data: XOR<ZScanVerificationUpdateManyMutationInput, ZScanVerificationUncheckedUpdateManyInput>
    /**
     * Filter which ZScanVerifications to update
     */
    where?: ZScanVerificationWhereInput
    /**
     * Limit how many ZScanVerifications to update.
     */
    limit?: number
  }

  /**
   * ZScanVerification updateManyAndReturn
   */
  export type ZScanVerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * The data used to update ZScanVerifications.
     */
    data: XOR<ZScanVerificationUpdateManyMutationInput, ZScanVerificationUncheckedUpdateManyInput>
    /**
     * Filter which ZScanVerifications to update
     */
    where?: ZScanVerificationWhereInput
    /**
     * Limit how many ZScanVerifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ZScanVerification upsert
   */
  export type ZScanVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the ZScanVerification to update in case it exists.
     */
    where: ZScanVerificationWhereUniqueInput
    /**
     * In case the ZScanVerification found by the `where` argument doesn't exist, create a new ZScanVerification with this data.
     */
    create: XOR<ZScanVerificationCreateInput, ZScanVerificationUncheckedCreateInput>
    /**
     * In case the ZScanVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZScanVerificationUpdateInput, ZScanVerificationUncheckedUpdateInput>
  }

  /**
   * ZScanVerification delete
   */
  export type ZScanVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
    /**
     * Filter which ZScanVerification to delete.
     */
    where: ZScanVerificationWhereUniqueInput
  }

  /**
   * ZScanVerification deleteMany
   */
  export type ZScanVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZScanVerifications to delete
     */
    where?: ZScanVerificationWhereInput
    /**
     * Limit how many ZScanVerifications to delete.
     */
    limit?: number
  }

  /**
   * ZScanVerification.user
   */
  export type ZScanVerification$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ZScanVerification without action
   */
  export type ZScanVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    tier: 'tier',
    permissions: 'permissions',
    orgId: 'orgId',
    status: 'status',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    twoFactorEnabled: 'twoFactorEnabled',
    twoFactorSecret: 'twoFactorSecret',
    backupCodes: 'backupCodes',
    failedLoginAttempts: 'failedLoginAttempts',
    lockedUntil: 'lockedUntil',
    passwordChangedAt: 'passwordChangedAt',
    ssoProvider: 'ssoProvider',
    ssoId: 'ssoId',
    ssoMetadata: 'ssoMetadata',
    currentPersona: 'currentPersona',
    personaLocked: 'personaLocked',
    lamportCounter: 'lamportCounter',
    lastReceiptId: 'lastReceiptId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    plan: 'plan',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    orgId: 'orgId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    userId: 'userId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const SharedTestCollectionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    teamId: 'teamId',
    createdBy: 'createdBy',
    isPublic: 'isPublic',
    tags: 'tags',
    testIds: 'testIds',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SharedTestCollectionScalarFieldEnum = (typeof SharedTestCollectionScalarFieldEnum)[keyof typeof SharedTestCollectionScalarFieldEnum]


  export const RateLimitQuotaScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    endpoint: 'endpoint',
    limit: 'limit',
    used: 'used',
    resetAt: 'resetAt',
    windowMinutes: 'windowMinutes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RateLimitQuotaScalarFieldEnum = (typeof RateLimitQuotaScalarFieldEnum)[keyof typeof RateLimitQuotaScalarFieldEnum]


  export const TestTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    userId: 'userId',
    teamId: 'teamId',
    isPublic: 'isPublic',
    isPredefined: 'isPredefined',
    tags: 'tags',
    config: 'config',
    sharedWith: 'sharedWith',
    useCount: 'useCount',
    favoriteCount: 'favoriteCount',
    version: 'version',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TestTemplateScalarFieldEnum = (typeof TestTemplateScalarFieldEnum)[keyof typeof TestTemplateScalarFieldEnum]


  export const WebhookScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    userId: 'userId',
    teamId: 'teamId',
    url: 'url',
    secret: 'secret',
    events: 'events',
    method: 'method',
    headers: 'headers',
    payloadTemplate: 'payloadTemplate',
    isActive: 'isActive',
    retryEnabled: 'retryEnabled',
    maxRetries: 'maxRetries',
    retryDelay: 'retryDelay',
    totalCalls: 'totalCalls',
    successCount: 'successCount',
    failureCount: 'failureCount',
    lastTriggered: 'lastTriggered',
    lastSuccess: 'lastSuccess',
    lastFailure: 'lastFailure',
    lastError: 'lastError',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebhookScalarFieldEnum = (typeof WebhookScalarFieldEnum)[keyof typeof WebhookScalarFieldEnum]


  export const WebhookLogScalarFieldEnum: {
    id: 'id',
    webhookId: 'webhookId',
    event: 'event',
    payload: 'payload',
    url: 'url',
    method: 'method',
    headers: 'headers',
    statusCode: 'statusCode',
    responseBody: 'responseBody',
    responseTime: 'responseTime',
    attempt: 'attempt',
    success: 'success',
    error: 'error',
    createdAt: 'createdAt'
  };

  export type WebhookLogScalarFieldEnum = (typeof WebhookLogScalarFieldEnum)[keyof typeof WebhookLogScalarFieldEnum]


  export const ApiRateLimitScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    limitType: 'limitType',
    limitPeriod: 'limitPeriod',
    maxLimit: 'maxLimit',
    currentUsage: 'currentUsage',
    resetAt: 'resetAt',
    warningThreshold: 'warningThreshold',
    lastWarningAt: 'lastWarningAt',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApiRateLimitScalarFieldEnum = (typeof ApiRateLimitScalarFieldEnum)[keyof typeof ApiRateLimitScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    expiresAt: 'expiresAt',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt',
    lastUsedAt: 'lastUsedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AuditRecordScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    category: 'category',
    details: 'details',
    metadata: 'metadata',
    status: 'status',
    lamport: 'lamport',
    hashPointer: 'hashPointer',
    createdAt: 'createdAt'
  };

  export type AuditRecordScalarFieldEnum = (typeof AuditRecordScalarFieldEnum)[keyof typeof AuditRecordScalarFieldEnum]


  export const LamportStateScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    lamport: 'lamport',
    metadata: 'metadata',
    modified: 'modified'
  };

  export type LamportStateScalarFieldEnum = (typeof LamportStateScalarFieldEnum)[keyof typeof LamportStateScalarFieldEnum]


  export const BudgetScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    limit: 'limit',
    period: 'period',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BudgetScalarFieldEnum = (typeof BudgetScalarFieldEnum)[keyof typeof BudgetScalarFieldEnum]


  export const RegressionBaselineScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    modelName: 'modelName',
    modelVersion: 'modelVersion',
    testType: 'testType',
    avgResponseTime: 'avgResponseTime',
    avgCost: 'avgCost',
    avgQualityScore: 'avgQualityScore',
    avgAccuracy: 'avgAccuracy',
    successRate: 'successRate',
    alertThreshold: 'alertThreshold',
    sampleSize: 'sampleSize',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RegressionBaselineScalarFieldEnum = (typeof RegressionBaselineScalarFieldEnum)[keyof typeof RegressionBaselineScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    category: 'category',
    priority: 'priority',
    subject: 'subject',
    message: 'message',
    url: 'url',
    userAgent: 'userAgent',
    metadata: 'metadata',
    attachmentUrls: 'attachmentUrls',
    status: 'status',
    assignedTo: 'assignedTo',
    response: 'response',
    respondedAt: 'respondedAt',
    respondedBy: 'respondedBy',
    sentiment: 'sentiment',
    sentimentScore: 'sentimentScore',
    upvotes: 'upvotes',
    isPublic: 'isPublic',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    resolvedAt: 'resolvedAt'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const IpWhitelistScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    orgId: 'orgId',
    ipAddress: 'ipAddress',
    description: 'description',
    isActive: 'isActive',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastUsedAt: 'lastUsedAt'
  };

  export type IpWhitelistScalarFieldEnum = (typeof IpWhitelistScalarFieldEnum)[keyof typeof IpWhitelistScalarFieldEnum]


  export const SecurityEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    eventType: 'eventType',
    severity: 'severity',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    description: 'description',
    metadata: 'metadata',
    resolved: 'resolved',
    resolvedBy: 'resolvedBy',
    resolvedAt: 'resolvedAt',
    createdAt: 'createdAt'
  };

  export type SecurityEventScalarFieldEnum = (typeof SecurityEventScalarFieldEnum)[keyof typeof SecurityEventScalarFieldEnum]


  export const TwoFactorBackupScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    code: 'code',
    used: 'used',
    usedAt: 'usedAt',
    createdAt: 'createdAt'
  };

  export type TwoFactorBackupScalarFieldEnum = (typeof TwoFactorBackupScalarFieldEnum)[keyof typeof TwoFactorBackupScalarFieldEnum]


  export const SSOConfigurationScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    provider: 'provider',
    enabled: 'enabled',
    samlEntryPoint: 'samlEntryPoint',
    samlIssuer: 'samlIssuer',
    samlCert: 'samlCert',
    samlCallbackUrl: 'samlCallbackUrl',
    samlLogoutUrl: 'samlLogoutUrl',
    oauthClientId: 'oauthClientId',
    oauthClientSecret: 'oauthClientSecret',
    oauthAuthUrl: 'oauthAuthUrl',
    oauthTokenUrl: 'oauthTokenUrl',
    oauthUserInfoUrl: 'oauthUserInfoUrl',
    oauthScopes: 'oauthScopes',
    domainRestriction: 'domainRestriction',
    jitProvisioning: 'jitProvisioning',
    defaultRole: 'defaultRole',
    defaultTier: 'defaultTier',
    metadata: 'metadata',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastUsedAt: 'lastUsedAt'
  };

  export type SSOConfigurationScalarFieldEnum = (typeof SSOConfigurationScalarFieldEnum)[keyof typeof SSOConfigurationScalarFieldEnum]


  export const SSOSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    sessionId: 'sessionId',
    nameId: 'nameId',
    sessionIndex: 'sessionIndex',
    attributes: 'attributes',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    lastActivityAt: 'lastActivityAt'
  };

  export type SSOSessionScalarFieldEnum = (typeof SSOSessionScalarFieldEnum)[keyof typeof SSOSessionScalarFieldEnum]


  export const SSOAuditLogScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    userId: 'userId',
    provider: 'provider',
    eventType: 'eventType',
    success: 'success',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    errorMessage: 'errorMessage',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type SSOAuditLogScalarFieldEnum = (typeof SSOAuditLogScalarFieldEnum)[keyof typeof SSOAuditLogScalarFieldEnum]


  export const NotificationPreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    emailEnabled: 'emailEnabled',
    testComplete: 'testComplete',
    batchComplete: 'batchComplete',
    scheduledTestComplete: 'scheduledTestComplete',
    alertsEnabled: 'alertsEnabled',
    lowScoreThreshold: 'lowScoreThreshold',
    highScoreThreshold: 'highScoreThreshold',
    scoreDropAlert: 'scoreDropAlert',
    witnessFailureAlert: 'witnessFailureAlert',
    dailyReport: 'dailyReport',
    weeklyReport: 'weeklyReport',
    monthlyReport: 'monthlyReport',
    reportTime: 'reportTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


  export const TestResultScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    modelName: 'modelName',
    modelProvider: 'modelProvider',
    prompt: 'prompt',
    response: 'response',
    criesScore: 'criesScore',
    responseTime: 'responseTime',
    tokenCount: 'tokenCount',
    cost: 'cost',
    status: 'status',
    errorMessage: 'errorMessage',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type TestResultScalarFieldEnum = (typeof TestResultScalarFieldEnum)[keyof typeof TestResultScalarFieldEnum]


  export const LamportCounterScalarFieldEnum: {
    id: 'id',
    currentValue: 'currentValue',
    lastUpdated: 'lastUpdated',
    lastReceiptId: 'lastReceiptId',
    metadata: 'metadata'
  };

  export type LamportCounterScalarFieldEnum = (typeof LamportCounterScalarFieldEnum)[keyof typeof LamportCounterScalarFieldEnum]


  export const BENReceiptScalarFieldEnum: {
    id: 'id',
    receiptType: 'receiptType',
    lamportClock: 'lamportClock',
    realTimestamp: 'realTimestamp',
    userId: 'userId',
    persona: 'persona',
    track: 'track',
    payload: 'payload',
    digest: 'digest',
    previousDigest: 'previousDigest',
    baselineDigest: 'baselineDigest',
    witnessModel: 'witnessModel',
    witnessSignature: 'witnessSignature',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type BENReceiptScalarFieldEnum = (typeof BENReceiptScalarFieldEnum)[keyof typeof BENReceiptScalarFieldEnum]


  export const BENSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    persona: 'persona',
    priority: 'priority',
    locked: 'locked',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    duration: 'duration',
    startLamport: 'startLamport',
    endLamport: 'endLamport',
    switchReason: 'switchReason',
    metadata: 'metadata'
  };

  export type BENSessionScalarFieldEnum = (typeof BENSessionScalarFieldEnum)[keyof typeof BENSessionScalarFieldEnum]


  export const TriTrackHandoffScalarFieldEnum: {
    id: 'id',
    fromTrack: 'fromTrack',
    toTrack: 'toTrack',
    status: 'status',
    fromReceiptId: 'fromReceiptId',
    toReceiptId: 'toReceiptId',
    initiatedAt: 'initiatedAt',
    completedAt: 'completedAt',
    latencyMs: 'latencyMs',
    exceededLimit: 'exceededLimit',
    payload: 'payload',
    result: 'result',
    errorMessage: 'errorMessage',
    metadata: 'metadata'
  };

  export type TriTrackHandoffScalarFieldEnum = (typeof TriTrackHandoffScalarFieldEnum)[keyof typeof TriTrackHandoffScalarFieldEnum]


  export const WitnessSignatureScalarFieldEnum: {
    id: 'id',
    modelName: 'modelName',
    modelFingerprint: 'modelFingerprint',
    receiptId: 'receiptId',
    receiptDigest: 'receiptDigest',
    signature: 'signature',
    signedAt: 'signedAt',
    lamportClock: 'lamportClock',
    verified: 'verified',
    verifiedAt: 'verifiedAt',
    verificationData: 'verificationData',
    metadata: 'metadata'
  };

  export type WitnessSignatureScalarFieldEnum = (typeof WitnessSignatureScalarFieldEnum)[keyof typeof WitnessSignatureScalarFieldEnum]


  export const CRIESComputationScalarFieldEnum: {
    id: 'id',
    testResultId: 'testResultId',
    userId: 'userId',
    sigmaWindow: 'sigmaWindow',
    tauThreshold: 'tauThreshold',
    piPolicy: 'piPolicy',
    citationQuality: 'citationQuality',
    criesScore: 'criesScore',
    lamportClock: 'lamportClock',
    computedAt: 'computedAt',
    receiptId: 'receiptId',
    analysisData: 'analysisData',
    metadata: 'metadata'
  };

  export type CRIESComputationScalarFieldEnum = (typeof CRIESComputationScalarFieldEnum)[keyof typeof CRIESComputationScalarFieldEnum]


  export const ZScanVerificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    totalRules: 'totalRules',
    passed: 'passed',
    warnings: 'warnings',
    critical: 'critical',
    results: 'results',
    config: 'config',
    createdAt: 'createdAt'
  };

  export type ZScanVerificationScalarFieldEnum = (typeof ZScanVerificationScalarFieldEnum)[keyof typeof ZScanVerificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'UserTier'
   */
  export type EnumUserTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserTier'>
    


  /**
   * Reference to a field of type 'UserTier[]'
   */
  export type ListEnumUserTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserTier[]'>
    


  /**
   * Reference to a field of type 'Permission[]'
   */
  export type ListEnumPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Permission[]'>
    


  /**
   * Reference to a field of type 'Permission'
   */
  export type EnumPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Permission'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'BENPersona'
   */
  export type EnumBENPersonaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BENPersona'>
    


  /**
   * Reference to a field of type 'BENPersona[]'
   */
  export type ListEnumBENPersonaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BENPersona[]'>
    


  /**
   * Reference to a field of type 'PlanType'
   */
  export type EnumPlanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanType'>
    


  /**
   * Reference to a field of type 'PlanType[]'
   */
  export type ListEnumPlanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanType[]'>
    


  /**
   * Reference to a field of type 'OrgStatus'
   */
  export type EnumOrgStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrgStatus'>
    


  /**
   * Reference to a field of type 'OrgStatus[]'
   */
  export type ListEnumOrgStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrgStatus[]'>
    


  /**
   * Reference to a field of type 'TeamRole'
   */
  export type EnumTeamRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamRole'>
    


  /**
   * Reference to a field of type 'TeamRole[]'
   */
  export type ListEnumTeamRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamRole[]'>
    


  /**
   * Reference to a field of type 'AuditCategory'
   */
  export type EnumAuditCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditCategory'>
    


  /**
   * Reference to a field of type 'AuditCategory[]'
   */
  export type ListEnumAuditCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditCategory[]'>
    


  /**
   * Reference to a field of type 'AuditStatus'
   */
  export type EnumAuditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditStatus'>
    


  /**
   * Reference to a field of type 'AuditStatus[]'
   */
  export type ListEnumAuditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'FeedbackType'
   */
  export type EnumFeedbackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackType'>
    


  /**
   * Reference to a field of type 'FeedbackType[]'
   */
  export type ListEnumFeedbackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackType[]'>
    


  /**
   * Reference to a field of type 'FeedbackCategory'
   */
  export type EnumFeedbackCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackCategory'>
    


  /**
   * Reference to a field of type 'FeedbackCategory[]'
   */
  export type ListEnumFeedbackCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackCategory[]'>
    


  /**
   * Reference to a field of type 'FeedbackPriority'
   */
  export type EnumFeedbackPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackPriority'>
    


  /**
   * Reference to a field of type 'FeedbackPriority[]'
   */
  export type ListEnumFeedbackPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackPriority[]'>
    


  /**
   * Reference to a field of type 'FeedbackStatus'
   */
  export type EnumFeedbackStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackStatus'>
    


  /**
   * Reference to a field of type 'FeedbackStatus[]'
   */
  export type ListEnumFeedbackStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackStatus[]'>
    


  /**
   * Reference to a field of type 'SecurityEventType'
   */
  export type EnumSecurityEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SecurityEventType'>
    


  /**
   * Reference to a field of type 'SecurityEventType[]'
   */
  export type ListEnumSecurityEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SecurityEventType[]'>
    


  /**
   * Reference to a field of type 'SecuritySeverity'
   */
  export type EnumSecuritySeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SecuritySeverity'>
    


  /**
   * Reference to a field of type 'SecuritySeverity[]'
   */
  export type ListEnumSecuritySeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SecuritySeverity[]'>
    


  /**
   * Reference to a field of type 'SSOProvider'
   */
  export type EnumSSOProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SSOProvider'>
    


  /**
   * Reference to a field of type 'SSOProvider[]'
   */
  export type ListEnumSSOProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SSOProvider[]'>
    


  /**
   * Reference to a field of type 'SSOEventType'
   */
  export type EnumSSOEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SSOEventType'>
    


  /**
   * Reference to a field of type 'SSOEventType[]'
   */
  export type ListEnumSSOEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SSOEventType[]'>
    


  /**
   * Reference to a field of type 'ReceiptType'
   */
  export type EnumReceiptTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReceiptType'>
    


  /**
   * Reference to a field of type 'ReceiptType[]'
   */
  export type ListEnumReceiptTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReceiptType[]'>
    


  /**
   * Reference to a field of type 'TrackType'
   */
  export type EnumTrackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrackType'>
    


  /**
   * Reference to a field of type 'TrackType[]'
   */
  export type ListEnumTrackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrackType[]'>
    


  /**
   * Reference to a field of type 'HandoffStatus'
   */
  export type EnumHandoffStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HandoffStatus'>
    


  /**
   * Reference to a field of type 'HandoffStatus[]'
   */
  export type ListEnumHandoffStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HandoffStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    tier?: EnumUserTierFilter<"User"> | $Enums.UserTier
    permissions?: EnumPermissionNullableListFilter<"User">
    orgId?: IntNullableFilter<"User"> | number | null
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    backupCodes?: StringNullableListFilter<"User">
    failedLoginAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordChangedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    ssoProvider?: StringNullableFilter<"User"> | string | null
    ssoId?: StringNullableFilter<"User"> | string | null
    ssoMetadata?: JsonNullableFilter<"User">
    currentPersona?: EnumBENPersonaFilter<"User"> | $Enums.BENPersona
    personaLocked?: BoolFilter<"User"> | boolean
    lamportCounter?: IntFilter<"User"> | number
    lastReceiptId?: IntNullableFilter<"User"> | number | null
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    sessions?: SessionListRelationFilter
    audits?: AuditRecordListRelationFilter
    teams?: TeamMemberListRelationFilter
    notifications?: XOR<NotificationPreferenceNullableScalarRelationFilter, NotificationPreferenceWhereInput> | null
    budgets?: BudgetListRelationFilter
    regressionBaselines?: RegressionBaselineListRelationFilter
    feedbacks?: FeedbackListRelationFilter
    benReceipts?: BENReceiptListRelationFilter
    benSessions?: BENSessionListRelationFilter
    zscans?: ZScanVerificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    tier?: SortOrder
    permissions?: SortOrder
    orgId?: SortOrderInput | SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    backupCodes?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    passwordChangedAt?: SortOrderInput | SortOrder
    ssoProvider?: SortOrderInput | SortOrder
    ssoId?: SortOrderInput | SortOrder
    ssoMetadata?: SortOrderInput | SortOrder
    currentPersona?: SortOrder
    personaLocked?: SortOrder
    lamportCounter?: SortOrder
    lastReceiptId?: SortOrderInput | SortOrder
    organization?: OrganizationOrderByWithRelationInput
    sessions?: SessionOrderByRelationAggregateInput
    audits?: AuditRecordOrderByRelationAggregateInput
    teams?: TeamMemberOrderByRelationAggregateInput
    notifications?: NotificationPreferenceOrderByWithRelationInput
    budgets?: BudgetOrderByRelationAggregateInput
    regressionBaselines?: RegressionBaselineOrderByRelationAggregateInput
    feedbacks?: FeedbackOrderByRelationAggregateInput
    benReceipts?: BENReceiptOrderByRelationAggregateInput
    benSessions?: BENSessionOrderByRelationAggregateInput
    zscans?: ZScanVerificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    ssoId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    tier?: EnumUserTierFilter<"User"> | $Enums.UserTier
    permissions?: EnumPermissionNullableListFilter<"User">
    orgId?: IntNullableFilter<"User"> | number | null
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    backupCodes?: StringNullableListFilter<"User">
    failedLoginAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordChangedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    ssoProvider?: StringNullableFilter<"User"> | string | null
    ssoMetadata?: JsonNullableFilter<"User">
    currentPersona?: EnumBENPersonaFilter<"User"> | $Enums.BENPersona
    personaLocked?: BoolFilter<"User"> | boolean
    lamportCounter?: IntFilter<"User"> | number
    lastReceiptId?: IntNullableFilter<"User"> | number | null
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    sessions?: SessionListRelationFilter
    audits?: AuditRecordListRelationFilter
    teams?: TeamMemberListRelationFilter
    notifications?: XOR<NotificationPreferenceNullableScalarRelationFilter, NotificationPreferenceWhereInput> | null
    budgets?: BudgetListRelationFilter
    regressionBaselines?: RegressionBaselineListRelationFilter
    feedbacks?: FeedbackListRelationFilter
    benReceipts?: BENReceiptListRelationFilter
    benSessions?: BENSessionListRelationFilter
    zscans?: ZScanVerificationListRelationFilter
  }, "id" | "email" | "ssoId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    tier?: SortOrder
    permissions?: SortOrder
    orgId?: SortOrderInput | SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    backupCodes?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    passwordChangedAt?: SortOrderInput | SortOrder
    ssoProvider?: SortOrderInput | SortOrder
    ssoId?: SortOrderInput | SortOrder
    ssoMetadata?: SortOrderInput | SortOrder
    currentPersona?: SortOrder
    personaLocked?: SortOrder
    lamportCounter?: SortOrder
    lastReceiptId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    tier?: EnumUserTierWithAggregatesFilter<"User"> | $Enums.UserTier
    permissions?: EnumPermissionNullableListFilter<"User">
    orgId?: IntNullableWithAggregatesFilter<"User"> | number | null
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    backupCodes?: StringNullableListFilter<"User">
    failedLoginAttempts?: IntWithAggregatesFilter<"User"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    passwordChangedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    ssoProvider?: StringNullableWithAggregatesFilter<"User"> | string | null
    ssoId?: StringNullableWithAggregatesFilter<"User"> | string | null
    ssoMetadata?: JsonNullableWithAggregatesFilter<"User">
    currentPersona?: EnumBENPersonaWithAggregatesFilter<"User"> | $Enums.BENPersona
    personaLocked?: BoolWithAggregatesFilter<"User"> | boolean
    lamportCounter?: IntWithAggregatesFilter<"User"> | number
    lastReceiptId?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: IntFilter<"Organization"> | number
    name?: StringFilter<"Organization"> | string
    plan?: EnumPlanTypeFilter<"Organization"> | $Enums.PlanType
    status?: EnumOrgStatusFilter<"Organization"> | $Enums.OrgStatus
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    users?: UserListRelationFilter
    teams?: TeamListRelationFilter
    ssoConfigs?: SSOConfigurationListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    teams?: TeamOrderByRelationAggregateInput
    ssoConfigs?: SSOConfigurationOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    plan?: EnumPlanTypeFilter<"Organization"> | $Enums.PlanType
    status?: EnumOrgStatusFilter<"Organization"> | $Enums.OrgStatus
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    users?: UserListRelationFilter
    teams?: TeamListRelationFilter
    ssoConfigs?: SSOConfigurationListRelationFilter
  }, "id">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _avg?: OrganizationAvgOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
    _sum?: OrganizationSumOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Organization"> | number
    name?: StringWithAggregatesFilter<"Organization"> | string
    plan?: EnumPlanTypeWithAggregatesFilter<"Organization"> | $Enums.PlanType
    status?: EnumOrgStatusWithAggregatesFilter<"Organization"> | $Enums.OrgStatus
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: IntFilter<"Team"> | number
    name?: StringFilter<"Team"> | string
    orgId?: IntFilter<"Team"> | number
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    members?: TeamMemberListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    members?: TeamMemberOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    orgId?: IntFilter<"Team"> | number
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    members?: TeamMemberListRelationFilter
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _avg?: TeamAvgOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
    _sum?: TeamSumOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Team"> | number
    name?: StringWithAggregatesFilter<"Team"> | string
    orgId?: IntWithAggregatesFilter<"Team"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    id?: IntFilter<"TeamMember"> | number
    teamId?: IntFilter<"TeamMember"> | number
    userId?: IntFilter<"TeamMember"> | number
    role?: EnumTeamRoleFilter<"TeamMember"> | $Enums.TeamRole
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"TeamMember"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    teamId_userId?: TeamMemberTeamIdUserIdCompoundUniqueInput
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    teamId?: IntFilter<"TeamMember"> | number
    userId?: IntFilter<"TeamMember"> | number
    role?: EnumTeamRoleFilter<"TeamMember"> | $Enums.TeamRole
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"TeamMember"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "teamId_userId">

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _avg?: TeamMemberAvgOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
    _sum?: TeamMemberSumOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    OR?: TeamMemberScalarWhereWithAggregatesInput[]
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TeamMember"> | number
    teamId?: IntWithAggregatesFilter<"TeamMember"> | number
    userId?: IntWithAggregatesFilter<"TeamMember"> | number
    role?: EnumTeamRoleWithAggregatesFilter<"TeamMember"> | $Enums.TeamRole
    createdAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
  }

  export type SharedTestCollectionWhereInput = {
    AND?: SharedTestCollectionWhereInput | SharedTestCollectionWhereInput[]
    OR?: SharedTestCollectionWhereInput[]
    NOT?: SharedTestCollectionWhereInput | SharedTestCollectionWhereInput[]
    id?: IntFilter<"SharedTestCollection"> | number
    name?: StringFilter<"SharedTestCollection"> | string
    description?: StringNullableFilter<"SharedTestCollection"> | string | null
    teamId?: IntFilter<"SharedTestCollection"> | number
    createdBy?: IntFilter<"SharedTestCollection"> | number
    isPublic?: BoolFilter<"SharedTestCollection"> | boolean
    tags?: StringNullableListFilter<"SharedTestCollection">
    testIds?: IntNullableListFilter<"SharedTestCollection">
    metadata?: JsonNullableFilter<"SharedTestCollection">
    createdAt?: DateTimeFilter<"SharedTestCollection"> | Date | string
    updatedAt?: DateTimeFilter<"SharedTestCollection"> | Date | string
  }

  export type SharedTestCollectionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    teamId?: SortOrder
    createdBy?: SortOrder
    isPublic?: SortOrder
    tags?: SortOrder
    testIds?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SharedTestCollectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SharedTestCollectionWhereInput | SharedTestCollectionWhereInput[]
    OR?: SharedTestCollectionWhereInput[]
    NOT?: SharedTestCollectionWhereInput | SharedTestCollectionWhereInput[]
    name?: StringFilter<"SharedTestCollection"> | string
    description?: StringNullableFilter<"SharedTestCollection"> | string | null
    teamId?: IntFilter<"SharedTestCollection"> | number
    createdBy?: IntFilter<"SharedTestCollection"> | number
    isPublic?: BoolFilter<"SharedTestCollection"> | boolean
    tags?: StringNullableListFilter<"SharedTestCollection">
    testIds?: IntNullableListFilter<"SharedTestCollection">
    metadata?: JsonNullableFilter<"SharedTestCollection">
    createdAt?: DateTimeFilter<"SharedTestCollection"> | Date | string
    updatedAt?: DateTimeFilter<"SharedTestCollection"> | Date | string
  }, "id">

  export type SharedTestCollectionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    teamId?: SortOrder
    createdBy?: SortOrder
    isPublic?: SortOrder
    tags?: SortOrder
    testIds?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SharedTestCollectionCountOrderByAggregateInput
    _avg?: SharedTestCollectionAvgOrderByAggregateInput
    _max?: SharedTestCollectionMaxOrderByAggregateInput
    _min?: SharedTestCollectionMinOrderByAggregateInput
    _sum?: SharedTestCollectionSumOrderByAggregateInput
  }

  export type SharedTestCollectionScalarWhereWithAggregatesInput = {
    AND?: SharedTestCollectionScalarWhereWithAggregatesInput | SharedTestCollectionScalarWhereWithAggregatesInput[]
    OR?: SharedTestCollectionScalarWhereWithAggregatesInput[]
    NOT?: SharedTestCollectionScalarWhereWithAggregatesInput | SharedTestCollectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SharedTestCollection"> | number
    name?: StringWithAggregatesFilter<"SharedTestCollection"> | string
    description?: StringNullableWithAggregatesFilter<"SharedTestCollection"> | string | null
    teamId?: IntWithAggregatesFilter<"SharedTestCollection"> | number
    createdBy?: IntWithAggregatesFilter<"SharedTestCollection"> | number
    isPublic?: BoolWithAggregatesFilter<"SharedTestCollection"> | boolean
    tags?: StringNullableListFilter<"SharedTestCollection">
    testIds?: IntNullableListFilter<"SharedTestCollection">
    metadata?: JsonNullableWithAggregatesFilter<"SharedTestCollection">
    createdAt?: DateTimeWithAggregatesFilter<"SharedTestCollection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SharedTestCollection"> | Date | string
  }

  export type RateLimitQuotaWhereInput = {
    AND?: RateLimitQuotaWhereInput | RateLimitQuotaWhereInput[]
    OR?: RateLimitQuotaWhereInput[]
    NOT?: RateLimitQuotaWhereInput | RateLimitQuotaWhereInput[]
    id?: IntFilter<"RateLimitQuota"> | number
    userId?: IntFilter<"RateLimitQuota"> | number
    provider?: StringFilter<"RateLimitQuota"> | string
    endpoint?: StringFilter<"RateLimitQuota"> | string
    limit?: IntFilter<"RateLimitQuota"> | number
    used?: IntFilter<"RateLimitQuota"> | number
    resetAt?: DateTimeFilter<"RateLimitQuota"> | Date | string
    windowMinutes?: IntFilter<"RateLimitQuota"> | number
    createdAt?: DateTimeFilter<"RateLimitQuota"> | Date | string
    updatedAt?: DateTimeFilter<"RateLimitQuota"> | Date | string
  }

  export type RateLimitQuotaOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    endpoint?: SortOrder
    limit?: SortOrder
    used?: SortOrder
    resetAt?: SortOrder
    windowMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RateLimitQuotaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_provider_endpoint?: RateLimitQuotaUserIdProviderEndpointCompoundUniqueInput
    AND?: RateLimitQuotaWhereInput | RateLimitQuotaWhereInput[]
    OR?: RateLimitQuotaWhereInput[]
    NOT?: RateLimitQuotaWhereInput | RateLimitQuotaWhereInput[]
    userId?: IntFilter<"RateLimitQuota"> | number
    provider?: StringFilter<"RateLimitQuota"> | string
    endpoint?: StringFilter<"RateLimitQuota"> | string
    limit?: IntFilter<"RateLimitQuota"> | number
    used?: IntFilter<"RateLimitQuota"> | number
    resetAt?: DateTimeFilter<"RateLimitQuota"> | Date | string
    windowMinutes?: IntFilter<"RateLimitQuota"> | number
    createdAt?: DateTimeFilter<"RateLimitQuota"> | Date | string
    updatedAt?: DateTimeFilter<"RateLimitQuota"> | Date | string
  }, "id" | "userId_provider_endpoint">

  export type RateLimitQuotaOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    endpoint?: SortOrder
    limit?: SortOrder
    used?: SortOrder
    resetAt?: SortOrder
    windowMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RateLimitQuotaCountOrderByAggregateInput
    _avg?: RateLimitQuotaAvgOrderByAggregateInput
    _max?: RateLimitQuotaMaxOrderByAggregateInput
    _min?: RateLimitQuotaMinOrderByAggregateInput
    _sum?: RateLimitQuotaSumOrderByAggregateInput
  }

  export type RateLimitQuotaScalarWhereWithAggregatesInput = {
    AND?: RateLimitQuotaScalarWhereWithAggregatesInput | RateLimitQuotaScalarWhereWithAggregatesInput[]
    OR?: RateLimitQuotaScalarWhereWithAggregatesInput[]
    NOT?: RateLimitQuotaScalarWhereWithAggregatesInput | RateLimitQuotaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RateLimitQuota"> | number
    userId?: IntWithAggregatesFilter<"RateLimitQuota"> | number
    provider?: StringWithAggregatesFilter<"RateLimitQuota"> | string
    endpoint?: StringWithAggregatesFilter<"RateLimitQuota"> | string
    limit?: IntWithAggregatesFilter<"RateLimitQuota"> | number
    used?: IntWithAggregatesFilter<"RateLimitQuota"> | number
    resetAt?: DateTimeWithAggregatesFilter<"RateLimitQuota"> | Date | string
    windowMinutes?: IntWithAggregatesFilter<"RateLimitQuota"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RateLimitQuota"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RateLimitQuota"> | Date | string
  }

  export type TestTemplateWhereInput = {
    AND?: TestTemplateWhereInput | TestTemplateWhereInput[]
    OR?: TestTemplateWhereInput[]
    NOT?: TestTemplateWhereInput | TestTemplateWhereInput[]
    id?: IntFilter<"TestTemplate"> | number
    name?: StringFilter<"TestTemplate"> | string
    description?: StringNullableFilter<"TestTemplate"> | string | null
    category?: StringFilter<"TestTemplate"> | string
    userId?: IntFilter<"TestTemplate"> | number
    teamId?: IntNullableFilter<"TestTemplate"> | number | null
    isPublic?: BoolFilter<"TestTemplate"> | boolean
    isPredefined?: BoolFilter<"TestTemplate"> | boolean
    tags?: StringNullableListFilter<"TestTemplate">
    config?: JsonFilter<"TestTemplate">
    sharedWith?: IntNullableListFilter<"TestTemplate">
    useCount?: IntFilter<"TestTemplate"> | number
    favoriteCount?: IntFilter<"TestTemplate"> | number
    version?: StringFilter<"TestTemplate"> | string
    metadata?: JsonNullableFilter<"TestTemplate">
    createdAt?: DateTimeFilter<"TestTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"TestTemplate"> | Date | string
  }

  export type TestTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    userId?: SortOrder
    teamId?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    isPredefined?: SortOrder
    tags?: SortOrder
    config?: SortOrder
    sharedWith?: SortOrder
    useCount?: SortOrder
    favoriteCount?: SortOrder
    version?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TestTemplateWhereInput | TestTemplateWhereInput[]
    OR?: TestTemplateWhereInput[]
    NOT?: TestTemplateWhereInput | TestTemplateWhereInput[]
    name?: StringFilter<"TestTemplate"> | string
    description?: StringNullableFilter<"TestTemplate"> | string | null
    category?: StringFilter<"TestTemplate"> | string
    userId?: IntFilter<"TestTemplate"> | number
    teamId?: IntNullableFilter<"TestTemplate"> | number | null
    isPublic?: BoolFilter<"TestTemplate"> | boolean
    isPredefined?: BoolFilter<"TestTemplate"> | boolean
    tags?: StringNullableListFilter<"TestTemplate">
    config?: JsonFilter<"TestTemplate">
    sharedWith?: IntNullableListFilter<"TestTemplate">
    useCount?: IntFilter<"TestTemplate"> | number
    favoriteCount?: IntFilter<"TestTemplate"> | number
    version?: StringFilter<"TestTemplate"> | string
    metadata?: JsonNullableFilter<"TestTemplate">
    createdAt?: DateTimeFilter<"TestTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"TestTemplate"> | Date | string
  }, "id">

  export type TestTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    userId?: SortOrder
    teamId?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    isPredefined?: SortOrder
    tags?: SortOrder
    config?: SortOrder
    sharedWith?: SortOrder
    useCount?: SortOrder
    favoriteCount?: SortOrder
    version?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestTemplateCountOrderByAggregateInput
    _avg?: TestTemplateAvgOrderByAggregateInput
    _max?: TestTemplateMaxOrderByAggregateInput
    _min?: TestTemplateMinOrderByAggregateInput
    _sum?: TestTemplateSumOrderByAggregateInput
  }

  export type TestTemplateScalarWhereWithAggregatesInput = {
    AND?: TestTemplateScalarWhereWithAggregatesInput | TestTemplateScalarWhereWithAggregatesInput[]
    OR?: TestTemplateScalarWhereWithAggregatesInput[]
    NOT?: TestTemplateScalarWhereWithAggregatesInput | TestTemplateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TestTemplate"> | number
    name?: StringWithAggregatesFilter<"TestTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"TestTemplate"> | string | null
    category?: StringWithAggregatesFilter<"TestTemplate"> | string
    userId?: IntWithAggregatesFilter<"TestTemplate"> | number
    teamId?: IntNullableWithAggregatesFilter<"TestTemplate"> | number | null
    isPublic?: BoolWithAggregatesFilter<"TestTemplate"> | boolean
    isPredefined?: BoolWithAggregatesFilter<"TestTemplate"> | boolean
    tags?: StringNullableListFilter<"TestTemplate">
    config?: JsonWithAggregatesFilter<"TestTemplate">
    sharedWith?: IntNullableListFilter<"TestTemplate">
    useCount?: IntWithAggregatesFilter<"TestTemplate"> | number
    favoriteCount?: IntWithAggregatesFilter<"TestTemplate"> | number
    version?: StringWithAggregatesFilter<"TestTemplate"> | string
    metadata?: JsonNullableWithAggregatesFilter<"TestTemplate">
    createdAt?: DateTimeWithAggregatesFilter<"TestTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestTemplate"> | Date | string
  }

  export type WebhookWhereInput = {
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    id?: IntFilter<"Webhook"> | number
    name?: StringFilter<"Webhook"> | string
    description?: StringNullableFilter<"Webhook"> | string | null
    userId?: IntFilter<"Webhook"> | number
    teamId?: IntNullableFilter<"Webhook"> | number | null
    url?: StringFilter<"Webhook"> | string
    secret?: StringNullableFilter<"Webhook"> | string | null
    events?: StringNullableListFilter<"Webhook">
    method?: StringFilter<"Webhook"> | string
    headers?: JsonNullableFilter<"Webhook">
    payloadTemplate?: JsonNullableFilter<"Webhook">
    isActive?: BoolFilter<"Webhook"> | boolean
    retryEnabled?: BoolFilter<"Webhook"> | boolean
    maxRetries?: IntFilter<"Webhook"> | number
    retryDelay?: IntFilter<"Webhook"> | number
    totalCalls?: IntFilter<"Webhook"> | number
    successCount?: IntFilter<"Webhook"> | number
    failureCount?: IntFilter<"Webhook"> | number
    lastTriggered?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    lastSuccess?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    lastFailure?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    lastError?: StringNullableFilter<"Webhook"> | string | null
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
  }

  export type WebhookOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    teamId?: SortOrderInput | SortOrder
    url?: SortOrder
    secret?: SortOrderInput | SortOrder
    events?: SortOrder
    method?: SortOrder
    headers?: SortOrderInput | SortOrder
    payloadTemplate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    retryEnabled?: SortOrder
    maxRetries?: SortOrder
    retryDelay?: SortOrder
    totalCalls?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    lastTriggered?: SortOrderInput | SortOrder
    lastSuccess?: SortOrderInput | SortOrder
    lastFailure?: SortOrderInput | SortOrder
    lastError?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    name?: StringFilter<"Webhook"> | string
    description?: StringNullableFilter<"Webhook"> | string | null
    userId?: IntFilter<"Webhook"> | number
    teamId?: IntNullableFilter<"Webhook"> | number | null
    url?: StringFilter<"Webhook"> | string
    secret?: StringNullableFilter<"Webhook"> | string | null
    events?: StringNullableListFilter<"Webhook">
    method?: StringFilter<"Webhook"> | string
    headers?: JsonNullableFilter<"Webhook">
    payloadTemplate?: JsonNullableFilter<"Webhook">
    isActive?: BoolFilter<"Webhook"> | boolean
    retryEnabled?: BoolFilter<"Webhook"> | boolean
    maxRetries?: IntFilter<"Webhook"> | number
    retryDelay?: IntFilter<"Webhook"> | number
    totalCalls?: IntFilter<"Webhook"> | number
    successCount?: IntFilter<"Webhook"> | number
    failureCount?: IntFilter<"Webhook"> | number
    lastTriggered?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    lastSuccess?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    lastFailure?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    lastError?: StringNullableFilter<"Webhook"> | string | null
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
  }, "id">

  export type WebhookOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    teamId?: SortOrderInput | SortOrder
    url?: SortOrder
    secret?: SortOrderInput | SortOrder
    events?: SortOrder
    method?: SortOrder
    headers?: SortOrderInput | SortOrder
    payloadTemplate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    retryEnabled?: SortOrder
    maxRetries?: SortOrder
    retryDelay?: SortOrder
    totalCalls?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    lastTriggered?: SortOrderInput | SortOrder
    lastSuccess?: SortOrderInput | SortOrder
    lastFailure?: SortOrderInput | SortOrder
    lastError?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WebhookCountOrderByAggregateInput
    _avg?: WebhookAvgOrderByAggregateInput
    _max?: WebhookMaxOrderByAggregateInput
    _min?: WebhookMinOrderByAggregateInput
    _sum?: WebhookSumOrderByAggregateInput
  }

  export type WebhookScalarWhereWithAggregatesInput = {
    AND?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    OR?: WebhookScalarWhereWithAggregatesInput[]
    NOT?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Webhook"> | number
    name?: StringWithAggregatesFilter<"Webhook"> | string
    description?: StringNullableWithAggregatesFilter<"Webhook"> | string | null
    userId?: IntWithAggregatesFilter<"Webhook"> | number
    teamId?: IntNullableWithAggregatesFilter<"Webhook"> | number | null
    url?: StringWithAggregatesFilter<"Webhook"> | string
    secret?: StringNullableWithAggregatesFilter<"Webhook"> | string | null
    events?: StringNullableListFilter<"Webhook">
    method?: StringWithAggregatesFilter<"Webhook"> | string
    headers?: JsonNullableWithAggregatesFilter<"Webhook">
    payloadTemplate?: JsonNullableWithAggregatesFilter<"Webhook">
    isActive?: BoolWithAggregatesFilter<"Webhook"> | boolean
    retryEnabled?: BoolWithAggregatesFilter<"Webhook"> | boolean
    maxRetries?: IntWithAggregatesFilter<"Webhook"> | number
    retryDelay?: IntWithAggregatesFilter<"Webhook"> | number
    totalCalls?: IntWithAggregatesFilter<"Webhook"> | number
    successCount?: IntWithAggregatesFilter<"Webhook"> | number
    failureCount?: IntWithAggregatesFilter<"Webhook"> | number
    lastTriggered?: DateTimeNullableWithAggregatesFilter<"Webhook"> | Date | string | null
    lastSuccess?: DateTimeNullableWithAggregatesFilter<"Webhook"> | Date | string | null
    lastFailure?: DateTimeNullableWithAggregatesFilter<"Webhook"> | Date | string | null
    lastError?: StringNullableWithAggregatesFilter<"Webhook"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
  }

  export type WebhookLogWhereInput = {
    AND?: WebhookLogWhereInput | WebhookLogWhereInput[]
    OR?: WebhookLogWhereInput[]
    NOT?: WebhookLogWhereInput | WebhookLogWhereInput[]
    id?: IntFilter<"WebhookLog"> | number
    webhookId?: IntFilter<"WebhookLog"> | number
    event?: StringFilter<"WebhookLog"> | string
    payload?: JsonFilter<"WebhookLog">
    url?: StringFilter<"WebhookLog"> | string
    method?: StringFilter<"WebhookLog"> | string
    headers?: JsonNullableFilter<"WebhookLog">
    statusCode?: IntNullableFilter<"WebhookLog"> | number | null
    responseBody?: StringNullableFilter<"WebhookLog"> | string | null
    responseTime?: IntNullableFilter<"WebhookLog"> | number | null
    attempt?: IntFilter<"WebhookLog"> | number
    success?: BoolFilter<"WebhookLog"> | boolean
    error?: StringNullableFilter<"WebhookLog"> | string | null
    createdAt?: DateTimeFilter<"WebhookLog"> | Date | string
  }

  export type WebhookLogOrderByWithRelationInput = {
    id?: SortOrder
    webhookId?: SortOrder
    event?: SortOrder
    payload?: SortOrder
    url?: SortOrder
    method?: SortOrder
    headers?: SortOrderInput | SortOrder
    statusCode?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    attempt?: SortOrder
    success?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type WebhookLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WebhookLogWhereInput | WebhookLogWhereInput[]
    OR?: WebhookLogWhereInput[]
    NOT?: WebhookLogWhereInput | WebhookLogWhereInput[]
    webhookId?: IntFilter<"WebhookLog"> | number
    event?: StringFilter<"WebhookLog"> | string
    payload?: JsonFilter<"WebhookLog">
    url?: StringFilter<"WebhookLog"> | string
    method?: StringFilter<"WebhookLog"> | string
    headers?: JsonNullableFilter<"WebhookLog">
    statusCode?: IntNullableFilter<"WebhookLog"> | number | null
    responseBody?: StringNullableFilter<"WebhookLog"> | string | null
    responseTime?: IntNullableFilter<"WebhookLog"> | number | null
    attempt?: IntFilter<"WebhookLog"> | number
    success?: BoolFilter<"WebhookLog"> | boolean
    error?: StringNullableFilter<"WebhookLog"> | string | null
    createdAt?: DateTimeFilter<"WebhookLog"> | Date | string
  }, "id">

  export type WebhookLogOrderByWithAggregationInput = {
    id?: SortOrder
    webhookId?: SortOrder
    event?: SortOrder
    payload?: SortOrder
    url?: SortOrder
    method?: SortOrder
    headers?: SortOrderInput | SortOrder
    statusCode?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    attempt?: SortOrder
    success?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WebhookLogCountOrderByAggregateInput
    _avg?: WebhookLogAvgOrderByAggregateInput
    _max?: WebhookLogMaxOrderByAggregateInput
    _min?: WebhookLogMinOrderByAggregateInput
    _sum?: WebhookLogSumOrderByAggregateInput
  }

  export type WebhookLogScalarWhereWithAggregatesInput = {
    AND?: WebhookLogScalarWhereWithAggregatesInput | WebhookLogScalarWhereWithAggregatesInput[]
    OR?: WebhookLogScalarWhereWithAggregatesInput[]
    NOT?: WebhookLogScalarWhereWithAggregatesInput | WebhookLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WebhookLog"> | number
    webhookId?: IntWithAggregatesFilter<"WebhookLog"> | number
    event?: StringWithAggregatesFilter<"WebhookLog"> | string
    payload?: JsonWithAggregatesFilter<"WebhookLog">
    url?: StringWithAggregatesFilter<"WebhookLog"> | string
    method?: StringWithAggregatesFilter<"WebhookLog"> | string
    headers?: JsonNullableWithAggregatesFilter<"WebhookLog">
    statusCode?: IntNullableWithAggregatesFilter<"WebhookLog"> | number | null
    responseBody?: StringNullableWithAggregatesFilter<"WebhookLog"> | string | null
    responseTime?: IntNullableWithAggregatesFilter<"WebhookLog"> | number | null
    attempt?: IntWithAggregatesFilter<"WebhookLog"> | number
    success?: BoolWithAggregatesFilter<"WebhookLog"> | boolean
    error?: StringNullableWithAggregatesFilter<"WebhookLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WebhookLog"> | Date | string
  }

  export type ApiRateLimitWhereInput = {
    AND?: ApiRateLimitWhereInput | ApiRateLimitWhereInput[]
    OR?: ApiRateLimitWhereInput[]
    NOT?: ApiRateLimitWhereInput | ApiRateLimitWhereInput[]
    id?: IntFilter<"ApiRateLimit"> | number
    userId?: IntFilter<"ApiRateLimit"> | number
    provider?: StringFilter<"ApiRateLimit"> | string
    limitType?: StringFilter<"ApiRateLimit"> | string
    limitPeriod?: StringFilter<"ApiRateLimit"> | string
    maxLimit?: IntFilter<"ApiRateLimit"> | number
    currentUsage?: IntFilter<"ApiRateLimit"> | number
    resetAt?: DateTimeFilter<"ApiRateLimit"> | Date | string
    warningThreshold?: IntFilter<"ApiRateLimit"> | number
    lastWarningAt?: DateTimeNullableFilter<"ApiRateLimit"> | Date | string | null
    metadata?: JsonNullableFilter<"ApiRateLimit">
    createdAt?: DateTimeFilter<"ApiRateLimit"> | Date | string
    updatedAt?: DateTimeFilter<"ApiRateLimit"> | Date | string
  }

  export type ApiRateLimitOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    limitType?: SortOrder
    limitPeriod?: SortOrder
    maxLimit?: SortOrder
    currentUsage?: SortOrder
    resetAt?: SortOrder
    warningThreshold?: SortOrder
    lastWarningAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiRateLimitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_provider_limitType_limitPeriod?: ApiRateLimitUserIdProviderLimitTypeLimitPeriodCompoundUniqueInput
    AND?: ApiRateLimitWhereInput | ApiRateLimitWhereInput[]
    OR?: ApiRateLimitWhereInput[]
    NOT?: ApiRateLimitWhereInput | ApiRateLimitWhereInput[]
    userId?: IntFilter<"ApiRateLimit"> | number
    provider?: StringFilter<"ApiRateLimit"> | string
    limitType?: StringFilter<"ApiRateLimit"> | string
    limitPeriod?: StringFilter<"ApiRateLimit"> | string
    maxLimit?: IntFilter<"ApiRateLimit"> | number
    currentUsage?: IntFilter<"ApiRateLimit"> | number
    resetAt?: DateTimeFilter<"ApiRateLimit"> | Date | string
    warningThreshold?: IntFilter<"ApiRateLimit"> | number
    lastWarningAt?: DateTimeNullableFilter<"ApiRateLimit"> | Date | string | null
    metadata?: JsonNullableFilter<"ApiRateLimit">
    createdAt?: DateTimeFilter<"ApiRateLimit"> | Date | string
    updatedAt?: DateTimeFilter<"ApiRateLimit"> | Date | string
  }, "id" | "userId_provider_limitType_limitPeriod">

  export type ApiRateLimitOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    limitType?: SortOrder
    limitPeriod?: SortOrder
    maxLimit?: SortOrder
    currentUsage?: SortOrder
    resetAt?: SortOrder
    warningThreshold?: SortOrder
    lastWarningAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApiRateLimitCountOrderByAggregateInput
    _avg?: ApiRateLimitAvgOrderByAggregateInput
    _max?: ApiRateLimitMaxOrderByAggregateInput
    _min?: ApiRateLimitMinOrderByAggregateInput
    _sum?: ApiRateLimitSumOrderByAggregateInput
  }

  export type ApiRateLimitScalarWhereWithAggregatesInput = {
    AND?: ApiRateLimitScalarWhereWithAggregatesInput | ApiRateLimitScalarWhereWithAggregatesInput[]
    OR?: ApiRateLimitScalarWhereWithAggregatesInput[]
    NOT?: ApiRateLimitScalarWhereWithAggregatesInput | ApiRateLimitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ApiRateLimit"> | number
    userId?: IntWithAggregatesFilter<"ApiRateLimit"> | number
    provider?: StringWithAggregatesFilter<"ApiRateLimit"> | string
    limitType?: StringWithAggregatesFilter<"ApiRateLimit"> | string
    limitPeriod?: StringWithAggregatesFilter<"ApiRateLimit"> | string
    maxLimit?: IntWithAggregatesFilter<"ApiRateLimit"> | number
    currentUsage?: IntWithAggregatesFilter<"ApiRateLimit"> | number
    resetAt?: DateTimeWithAggregatesFilter<"ApiRateLimit"> | Date | string
    warningThreshold?: IntWithAggregatesFilter<"ApiRateLimit"> | number
    lastWarningAt?: DateTimeNullableWithAggregatesFilter<"ApiRateLimit"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"ApiRateLimit">
    createdAt?: DateTimeWithAggregatesFilter<"ApiRateLimit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApiRateLimit"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: IntFilter<"Session"> | number
    userId?: IntFilter<"Session"> | number
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    userAgent?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    lastUsedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: IntFilter<"Session"> | number
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    userAgent?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    lastUsedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Session"> | number
    userId?: IntWithAggregatesFilter<"Session"> | number
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    lastUsedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type AuditRecordWhereInput = {
    AND?: AuditRecordWhereInput | AuditRecordWhereInput[]
    OR?: AuditRecordWhereInput[]
    NOT?: AuditRecordWhereInput | AuditRecordWhereInput[]
    id?: IntFilter<"AuditRecord"> | number
    userId?: IntFilter<"AuditRecord"> | number
    action?: StringFilter<"AuditRecord"> | string
    category?: EnumAuditCategoryFilter<"AuditRecord"> | $Enums.AuditCategory
    details?: JsonNullableFilter<"AuditRecord">
    metadata?: JsonNullableFilter<"AuditRecord">
    status?: EnumAuditStatusFilter<"AuditRecord"> | $Enums.AuditStatus
    lamport?: IntFilter<"AuditRecord"> | number
    hashPointer?: StringNullableFilter<"AuditRecord"> | string | null
    createdAt?: DateTimeFilter<"AuditRecord"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditRecordOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    category?: SortOrder
    details?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    status?: SortOrder
    lamport?: SortOrder
    hashPointer?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditRecordWhereInput | AuditRecordWhereInput[]
    OR?: AuditRecordWhereInput[]
    NOT?: AuditRecordWhereInput | AuditRecordWhereInput[]
    userId?: IntFilter<"AuditRecord"> | number
    action?: StringFilter<"AuditRecord"> | string
    category?: EnumAuditCategoryFilter<"AuditRecord"> | $Enums.AuditCategory
    details?: JsonNullableFilter<"AuditRecord">
    metadata?: JsonNullableFilter<"AuditRecord">
    status?: EnumAuditStatusFilter<"AuditRecord"> | $Enums.AuditStatus
    lamport?: IntFilter<"AuditRecord"> | number
    hashPointer?: StringNullableFilter<"AuditRecord"> | string | null
    createdAt?: DateTimeFilter<"AuditRecord"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditRecordOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    category?: SortOrder
    details?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    status?: SortOrder
    lamport?: SortOrder
    hashPointer?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditRecordCountOrderByAggregateInput
    _avg?: AuditRecordAvgOrderByAggregateInput
    _max?: AuditRecordMaxOrderByAggregateInput
    _min?: AuditRecordMinOrderByAggregateInput
    _sum?: AuditRecordSumOrderByAggregateInput
  }

  export type AuditRecordScalarWhereWithAggregatesInput = {
    AND?: AuditRecordScalarWhereWithAggregatesInput | AuditRecordScalarWhereWithAggregatesInput[]
    OR?: AuditRecordScalarWhereWithAggregatesInput[]
    NOT?: AuditRecordScalarWhereWithAggregatesInput | AuditRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditRecord"> | number
    userId?: IntWithAggregatesFilter<"AuditRecord"> | number
    action?: StringWithAggregatesFilter<"AuditRecord"> | string
    category?: EnumAuditCategoryWithAggregatesFilter<"AuditRecord"> | $Enums.AuditCategory
    details?: JsonNullableWithAggregatesFilter<"AuditRecord">
    metadata?: JsonNullableWithAggregatesFilter<"AuditRecord">
    status?: EnumAuditStatusWithAggregatesFilter<"AuditRecord"> | $Enums.AuditStatus
    lamport?: IntWithAggregatesFilter<"AuditRecord"> | number
    hashPointer?: StringNullableWithAggregatesFilter<"AuditRecord"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditRecord"> | Date | string
  }

  export type LamportStateWhereInput = {
    AND?: LamportStateWhereInput | LamportStateWhereInput[]
    OR?: LamportStateWhereInput[]
    NOT?: LamportStateWhereInput | LamportStateWhereInput[]
    id?: IntFilter<"LamportState"> | number
    key?: StringFilter<"LamportState"> | string
    value?: StringFilter<"LamportState"> | string
    lamport?: IntFilter<"LamportState"> | number
    metadata?: JsonNullableFilter<"LamportState">
    modified?: DateTimeFilter<"LamportState"> | Date | string
  }

  export type LamportStateOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    lamport?: SortOrder
    metadata?: SortOrderInput | SortOrder
    modified?: SortOrder
  }

  export type LamportStateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    key?: string
    AND?: LamportStateWhereInput | LamportStateWhereInput[]
    OR?: LamportStateWhereInput[]
    NOT?: LamportStateWhereInput | LamportStateWhereInput[]
    value?: StringFilter<"LamportState"> | string
    lamport?: IntFilter<"LamportState"> | number
    metadata?: JsonNullableFilter<"LamportState">
    modified?: DateTimeFilter<"LamportState"> | Date | string
  }, "id" | "key">

  export type LamportStateOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    lamport?: SortOrder
    metadata?: SortOrderInput | SortOrder
    modified?: SortOrder
    _count?: LamportStateCountOrderByAggregateInput
    _avg?: LamportStateAvgOrderByAggregateInput
    _max?: LamportStateMaxOrderByAggregateInput
    _min?: LamportStateMinOrderByAggregateInput
    _sum?: LamportStateSumOrderByAggregateInput
  }

  export type LamportStateScalarWhereWithAggregatesInput = {
    AND?: LamportStateScalarWhereWithAggregatesInput | LamportStateScalarWhereWithAggregatesInput[]
    OR?: LamportStateScalarWhereWithAggregatesInput[]
    NOT?: LamportStateScalarWhereWithAggregatesInput | LamportStateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LamportState"> | number
    key?: StringWithAggregatesFilter<"LamportState"> | string
    value?: StringWithAggregatesFilter<"LamportState"> | string
    lamport?: IntWithAggregatesFilter<"LamportState"> | number
    metadata?: JsonNullableWithAggregatesFilter<"LamportState">
    modified?: DateTimeWithAggregatesFilter<"LamportState"> | Date | string
  }

  export type BudgetWhereInput = {
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    id?: IntFilter<"Budget"> | number
    userId?: IntFilter<"Budget"> | number
    limit?: FloatFilter<"Budget"> | number
    period?: StringFilter<"Budget"> | string
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BudgetOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    limit?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BudgetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    userId?: IntFilter<"Budget"> | number
    limit?: FloatFilter<"Budget"> | number
    period?: StringFilter<"Budget"> | string
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type BudgetOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    limit?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BudgetCountOrderByAggregateInput
    _avg?: BudgetAvgOrderByAggregateInput
    _max?: BudgetMaxOrderByAggregateInput
    _min?: BudgetMinOrderByAggregateInput
    _sum?: BudgetSumOrderByAggregateInput
  }

  export type BudgetScalarWhereWithAggregatesInput = {
    AND?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    OR?: BudgetScalarWhereWithAggregatesInput[]
    NOT?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Budget"> | number
    userId?: IntWithAggregatesFilter<"Budget"> | number
    limit?: FloatWithAggregatesFilter<"Budget"> | number
    period?: StringWithAggregatesFilter<"Budget"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
  }

  export type RegressionBaselineWhereInput = {
    AND?: RegressionBaselineWhereInput | RegressionBaselineWhereInput[]
    OR?: RegressionBaselineWhereInput[]
    NOT?: RegressionBaselineWhereInput | RegressionBaselineWhereInput[]
    id?: IntFilter<"RegressionBaseline"> | number
    userId?: IntFilter<"RegressionBaseline"> | number
    modelName?: StringFilter<"RegressionBaseline"> | string
    modelVersion?: StringNullableFilter<"RegressionBaseline"> | string | null
    testType?: StringFilter<"RegressionBaseline"> | string
    avgResponseTime?: FloatFilter<"RegressionBaseline"> | number
    avgCost?: FloatFilter<"RegressionBaseline"> | number
    avgQualityScore?: FloatFilter<"RegressionBaseline"> | number
    avgAccuracy?: FloatFilter<"RegressionBaseline"> | number
    successRate?: FloatFilter<"RegressionBaseline"> | number
    alertThreshold?: FloatFilter<"RegressionBaseline"> | number
    sampleSize?: IntFilter<"RegressionBaseline"> | number
    isActive?: BoolFilter<"RegressionBaseline"> | boolean
    createdAt?: DateTimeFilter<"RegressionBaseline"> | Date | string
    updatedAt?: DateTimeFilter<"RegressionBaseline"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RegressionBaselineOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrderInput | SortOrder
    testType?: SortOrder
    avgResponseTime?: SortOrder
    avgCost?: SortOrder
    avgQualityScore?: SortOrder
    avgAccuracy?: SortOrder
    successRate?: SortOrder
    alertThreshold?: SortOrder
    sampleSize?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RegressionBaselineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_modelName_modelVersion_testType?: RegressionBaselineUserIdModelNameModelVersionTestTypeCompoundUniqueInput
    AND?: RegressionBaselineWhereInput | RegressionBaselineWhereInput[]
    OR?: RegressionBaselineWhereInput[]
    NOT?: RegressionBaselineWhereInput | RegressionBaselineWhereInput[]
    userId?: IntFilter<"RegressionBaseline"> | number
    modelName?: StringFilter<"RegressionBaseline"> | string
    modelVersion?: StringNullableFilter<"RegressionBaseline"> | string | null
    testType?: StringFilter<"RegressionBaseline"> | string
    avgResponseTime?: FloatFilter<"RegressionBaseline"> | number
    avgCost?: FloatFilter<"RegressionBaseline"> | number
    avgQualityScore?: FloatFilter<"RegressionBaseline"> | number
    avgAccuracy?: FloatFilter<"RegressionBaseline"> | number
    successRate?: FloatFilter<"RegressionBaseline"> | number
    alertThreshold?: FloatFilter<"RegressionBaseline"> | number
    sampleSize?: IntFilter<"RegressionBaseline"> | number
    isActive?: BoolFilter<"RegressionBaseline"> | boolean
    createdAt?: DateTimeFilter<"RegressionBaseline"> | Date | string
    updatedAt?: DateTimeFilter<"RegressionBaseline"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_modelName_modelVersion_testType">

  export type RegressionBaselineOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrderInput | SortOrder
    testType?: SortOrder
    avgResponseTime?: SortOrder
    avgCost?: SortOrder
    avgQualityScore?: SortOrder
    avgAccuracy?: SortOrder
    successRate?: SortOrder
    alertThreshold?: SortOrder
    sampleSize?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RegressionBaselineCountOrderByAggregateInput
    _avg?: RegressionBaselineAvgOrderByAggregateInput
    _max?: RegressionBaselineMaxOrderByAggregateInput
    _min?: RegressionBaselineMinOrderByAggregateInput
    _sum?: RegressionBaselineSumOrderByAggregateInput
  }

  export type RegressionBaselineScalarWhereWithAggregatesInput = {
    AND?: RegressionBaselineScalarWhereWithAggregatesInput | RegressionBaselineScalarWhereWithAggregatesInput[]
    OR?: RegressionBaselineScalarWhereWithAggregatesInput[]
    NOT?: RegressionBaselineScalarWhereWithAggregatesInput | RegressionBaselineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RegressionBaseline"> | number
    userId?: IntWithAggregatesFilter<"RegressionBaseline"> | number
    modelName?: StringWithAggregatesFilter<"RegressionBaseline"> | string
    modelVersion?: StringNullableWithAggregatesFilter<"RegressionBaseline"> | string | null
    testType?: StringWithAggregatesFilter<"RegressionBaseline"> | string
    avgResponseTime?: FloatWithAggregatesFilter<"RegressionBaseline"> | number
    avgCost?: FloatWithAggregatesFilter<"RegressionBaseline"> | number
    avgQualityScore?: FloatWithAggregatesFilter<"RegressionBaseline"> | number
    avgAccuracy?: FloatWithAggregatesFilter<"RegressionBaseline"> | number
    successRate?: FloatWithAggregatesFilter<"RegressionBaseline"> | number
    alertThreshold?: FloatWithAggregatesFilter<"RegressionBaseline"> | number
    sampleSize?: IntWithAggregatesFilter<"RegressionBaseline"> | number
    isActive?: BoolWithAggregatesFilter<"RegressionBaseline"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RegressionBaseline"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RegressionBaseline"> | Date | string
  }

  export type FeedbackWhereInput = {
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    id?: IntFilter<"Feedback"> | number
    userId?: IntFilter<"Feedback"> | number
    type?: EnumFeedbackTypeFilter<"Feedback"> | $Enums.FeedbackType
    category?: EnumFeedbackCategoryFilter<"Feedback"> | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityFilter<"Feedback"> | $Enums.FeedbackPriority
    subject?: StringFilter<"Feedback"> | string
    message?: StringFilter<"Feedback"> | string
    url?: StringNullableFilter<"Feedback"> | string | null
    userAgent?: StringNullableFilter<"Feedback"> | string | null
    metadata?: JsonNullableFilter<"Feedback">
    attachmentUrls?: StringNullableListFilter<"Feedback">
    status?: EnumFeedbackStatusFilter<"Feedback"> | $Enums.FeedbackStatus
    assignedTo?: IntNullableFilter<"Feedback"> | number | null
    response?: StringNullableFilter<"Feedback"> | string | null
    respondedAt?: DateTimeNullableFilter<"Feedback"> | Date | string | null
    respondedBy?: IntNullableFilter<"Feedback"> | number | null
    sentiment?: StringNullableFilter<"Feedback"> | string | null
    sentimentScore?: FloatNullableFilter<"Feedback"> | number | null
    upvotes?: IntFilter<"Feedback"> | number
    isPublic?: BoolFilter<"Feedback"> | boolean
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeFilter<"Feedback"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Feedback"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FeedbackOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    url?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    attachmentUrls?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    respondedBy?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    sentimentScore?: SortOrderInput | SortOrder
    upvotes?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    userId?: IntFilter<"Feedback"> | number
    type?: EnumFeedbackTypeFilter<"Feedback"> | $Enums.FeedbackType
    category?: EnumFeedbackCategoryFilter<"Feedback"> | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityFilter<"Feedback"> | $Enums.FeedbackPriority
    subject?: StringFilter<"Feedback"> | string
    message?: StringFilter<"Feedback"> | string
    url?: StringNullableFilter<"Feedback"> | string | null
    userAgent?: StringNullableFilter<"Feedback"> | string | null
    metadata?: JsonNullableFilter<"Feedback">
    attachmentUrls?: StringNullableListFilter<"Feedback">
    status?: EnumFeedbackStatusFilter<"Feedback"> | $Enums.FeedbackStatus
    assignedTo?: IntNullableFilter<"Feedback"> | number | null
    response?: StringNullableFilter<"Feedback"> | string | null
    respondedAt?: DateTimeNullableFilter<"Feedback"> | Date | string | null
    respondedBy?: IntNullableFilter<"Feedback"> | number | null
    sentiment?: StringNullableFilter<"Feedback"> | string | null
    sentimentScore?: FloatNullableFilter<"Feedback"> | number | null
    upvotes?: IntFilter<"Feedback"> | number
    isPublic?: BoolFilter<"Feedback"> | boolean
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeFilter<"Feedback"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Feedback"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    url?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    attachmentUrls?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    respondedBy?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    sentimentScore?: SortOrderInput | SortOrder
    upvotes?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    _count?: FeedbackCountOrderByAggregateInput
    _avg?: FeedbackAvgOrderByAggregateInput
    _max?: FeedbackMaxOrderByAggregateInput
    _min?: FeedbackMinOrderByAggregateInput
    _sum?: FeedbackSumOrderByAggregateInput
  }

  export type FeedbackScalarWhereWithAggregatesInput = {
    AND?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    OR?: FeedbackScalarWhereWithAggregatesInput[]
    NOT?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Feedback"> | number
    userId?: IntWithAggregatesFilter<"Feedback"> | number
    type?: EnumFeedbackTypeWithAggregatesFilter<"Feedback"> | $Enums.FeedbackType
    category?: EnumFeedbackCategoryWithAggregatesFilter<"Feedback"> | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityWithAggregatesFilter<"Feedback"> | $Enums.FeedbackPriority
    subject?: StringWithAggregatesFilter<"Feedback"> | string
    message?: StringWithAggregatesFilter<"Feedback"> | string
    url?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Feedback">
    attachmentUrls?: StringNullableListFilter<"Feedback">
    status?: EnumFeedbackStatusWithAggregatesFilter<"Feedback"> | $Enums.FeedbackStatus
    assignedTo?: IntNullableWithAggregatesFilter<"Feedback"> | number | null
    response?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    respondedAt?: DateTimeNullableWithAggregatesFilter<"Feedback"> | Date | string | null
    respondedBy?: IntNullableWithAggregatesFilter<"Feedback"> | number | null
    sentiment?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    sentimentScore?: FloatNullableWithAggregatesFilter<"Feedback"> | number | null
    upvotes?: IntWithAggregatesFilter<"Feedback"> | number
    isPublic?: BoolWithAggregatesFilter<"Feedback"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Feedback"> | Date | string | null
  }

  export type IpWhitelistWhereInput = {
    AND?: IpWhitelistWhereInput | IpWhitelistWhereInput[]
    OR?: IpWhitelistWhereInput[]
    NOT?: IpWhitelistWhereInput | IpWhitelistWhereInput[]
    id?: IntFilter<"IpWhitelist"> | number
    userId?: IntNullableFilter<"IpWhitelist"> | number | null
    orgId?: IntNullableFilter<"IpWhitelist"> | number | null
    ipAddress?: StringFilter<"IpWhitelist"> | string
    description?: StringNullableFilter<"IpWhitelist"> | string | null
    isActive?: BoolFilter<"IpWhitelist"> | boolean
    createdBy?: IntFilter<"IpWhitelist"> | number
    createdAt?: DateTimeFilter<"IpWhitelist"> | Date | string
    updatedAt?: DateTimeFilter<"IpWhitelist"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"IpWhitelist"> | Date | string | null
  }

  export type IpWhitelistOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    orgId?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
  }

  export type IpWhitelistWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: IpWhitelistWhereInput | IpWhitelistWhereInput[]
    OR?: IpWhitelistWhereInput[]
    NOT?: IpWhitelistWhereInput | IpWhitelistWhereInput[]
    userId?: IntNullableFilter<"IpWhitelist"> | number | null
    orgId?: IntNullableFilter<"IpWhitelist"> | number | null
    ipAddress?: StringFilter<"IpWhitelist"> | string
    description?: StringNullableFilter<"IpWhitelist"> | string | null
    isActive?: BoolFilter<"IpWhitelist"> | boolean
    createdBy?: IntFilter<"IpWhitelist"> | number
    createdAt?: DateTimeFilter<"IpWhitelist"> | Date | string
    updatedAt?: DateTimeFilter<"IpWhitelist"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"IpWhitelist"> | Date | string | null
  }, "id">

  export type IpWhitelistOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    orgId?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    _count?: IpWhitelistCountOrderByAggregateInput
    _avg?: IpWhitelistAvgOrderByAggregateInput
    _max?: IpWhitelistMaxOrderByAggregateInput
    _min?: IpWhitelistMinOrderByAggregateInput
    _sum?: IpWhitelistSumOrderByAggregateInput
  }

  export type IpWhitelistScalarWhereWithAggregatesInput = {
    AND?: IpWhitelistScalarWhereWithAggregatesInput | IpWhitelistScalarWhereWithAggregatesInput[]
    OR?: IpWhitelistScalarWhereWithAggregatesInput[]
    NOT?: IpWhitelistScalarWhereWithAggregatesInput | IpWhitelistScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"IpWhitelist"> | number
    userId?: IntNullableWithAggregatesFilter<"IpWhitelist"> | number | null
    orgId?: IntNullableWithAggregatesFilter<"IpWhitelist"> | number | null
    ipAddress?: StringWithAggregatesFilter<"IpWhitelist"> | string
    description?: StringNullableWithAggregatesFilter<"IpWhitelist"> | string | null
    isActive?: BoolWithAggregatesFilter<"IpWhitelist"> | boolean
    createdBy?: IntWithAggregatesFilter<"IpWhitelist"> | number
    createdAt?: DateTimeWithAggregatesFilter<"IpWhitelist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IpWhitelist"> | Date | string
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"IpWhitelist"> | Date | string | null
  }

  export type SecurityEventWhereInput = {
    AND?: SecurityEventWhereInput | SecurityEventWhereInput[]
    OR?: SecurityEventWhereInput[]
    NOT?: SecurityEventWhereInput | SecurityEventWhereInput[]
    id?: IntFilter<"SecurityEvent"> | number
    userId?: IntNullableFilter<"SecurityEvent"> | number | null
    eventType?: EnumSecurityEventTypeFilter<"SecurityEvent"> | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFilter<"SecurityEvent"> | $Enums.SecuritySeverity
    ipAddress?: StringNullableFilter<"SecurityEvent"> | string | null
    userAgent?: StringNullableFilter<"SecurityEvent"> | string | null
    description?: StringFilter<"SecurityEvent"> | string
    metadata?: JsonNullableFilter<"SecurityEvent">
    resolved?: BoolFilter<"SecurityEvent"> | boolean
    resolvedBy?: IntNullableFilter<"SecurityEvent"> | number | null
    resolvedAt?: DateTimeNullableFilter<"SecurityEvent"> | Date | string | null
    createdAt?: DateTimeFilter<"SecurityEvent"> | Date | string
  }

  export type SecurityEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    description?: SortOrder
    metadata?: SortOrderInput | SortOrder
    resolved?: SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type SecurityEventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SecurityEventWhereInput | SecurityEventWhereInput[]
    OR?: SecurityEventWhereInput[]
    NOT?: SecurityEventWhereInput | SecurityEventWhereInput[]
    userId?: IntNullableFilter<"SecurityEvent"> | number | null
    eventType?: EnumSecurityEventTypeFilter<"SecurityEvent"> | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFilter<"SecurityEvent"> | $Enums.SecuritySeverity
    ipAddress?: StringNullableFilter<"SecurityEvent"> | string | null
    userAgent?: StringNullableFilter<"SecurityEvent"> | string | null
    description?: StringFilter<"SecurityEvent"> | string
    metadata?: JsonNullableFilter<"SecurityEvent">
    resolved?: BoolFilter<"SecurityEvent"> | boolean
    resolvedBy?: IntNullableFilter<"SecurityEvent"> | number | null
    resolvedAt?: DateTimeNullableFilter<"SecurityEvent"> | Date | string | null
    createdAt?: DateTimeFilter<"SecurityEvent"> | Date | string
  }, "id">

  export type SecurityEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    description?: SortOrder
    metadata?: SortOrderInput | SortOrder
    resolved?: SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SecurityEventCountOrderByAggregateInput
    _avg?: SecurityEventAvgOrderByAggregateInput
    _max?: SecurityEventMaxOrderByAggregateInput
    _min?: SecurityEventMinOrderByAggregateInput
    _sum?: SecurityEventSumOrderByAggregateInput
  }

  export type SecurityEventScalarWhereWithAggregatesInput = {
    AND?: SecurityEventScalarWhereWithAggregatesInput | SecurityEventScalarWhereWithAggregatesInput[]
    OR?: SecurityEventScalarWhereWithAggregatesInput[]
    NOT?: SecurityEventScalarWhereWithAggregatesInput | SecurityEventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SecurityEvent"> | number
    userId?: IntNullableWithAggregatesFilter<"SecurityEvent"> | number | null
    eventType?: EnumSecurityEventTypeWithAggregatesFilter<"SecurityEvent"> | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityWithAggregatesFilter<"SecurityEvent"> | $Enums.SecuritySeverity
    ipAddress?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    description?: StringWithAggregatesFilter<"SecurityEvent"> | string
    metadata?: JsonNullableWithAggregatesFilter<"SecurityEvent">
    resolved?: BoolWithAggregatesFilter<"SecurityEvent"> | boolean
    resolvedBy?: IntNullableWithAggregatesFilter<"SecurityEvent"> | number | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"SecurityEvent"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SecurityEvent"> | Date | string
  }

  export type TwoFactorBackupWhereInput = {
    AND?: TwoFactorBackupWhereInput | TwoFactorBackupWhereInput[]
    OR?: TwoFactorBackupWhereInput[]
    NOT?: TwoFactorBackupWhereInput | TwoFactorBackupWhereInput[]
    id?: IntFilter<"TwoFactorBackup"> | number
    userId?: IntFilter<"TwoFactorBackup"> | number
    code?: StringFilter<"TwoFactorBackup"> | string
    used?: BoolFilter<"TwoFactorBackup"> | boolean
    usedAt?: DateTimeNullableFilter<"TwoFactorBackup"> | Date | string | null
    createdAt?: DateTimeFilter<"TwoFactorBackup"> | Date | string
  }

  export type TwoFactorBackupOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    used?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type TwoFactorBackupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: TwoFactorBackupWhereInput | TwoFactorBackupWhereInput[]
    OR?: TwoFactorBackupWhereInput[]
    NOT?: TwoFactorBackupWhereInput | TwoFactorBackupWhereInput[]
    userId?: IntFilter<"TwoFactorBackup"> | number
    used?: BoolFilter<"TwoFactorBackup"> | boolean
    usedAt?: DateTimeNullableFilter<"TwoFactorBackup"> | Date | string | null
    createdAt?: DateTimeFilter<"TwoFactorBackup"> | Date | string
  }, "id" | "code">

  export type TwoFactorBackupOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    used?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TwoFactorBackupCountOrderByAggregateInput
    _avg?: TwoFactorBackupAvgOrderByAggregateInput
    _max?: TwoFactorBackupMaxOrderByAggregateInput
    _min?: TwoFactorBackupMinOrderByAggregateInput
    _sum?: TwoFactorBackupSumOrderByAggregateInput
  }

  export type TwoFactorBackupScalarWhereWithAggregatesInput = {
    AND?: TwoFactorBackupScalarWhereWithAggregatesInput | TwoFactorBackupScalarWhereWithAggregatesInput[]
    OR?: TwoFactorBackupScalarWhereWithAggregatesInput[]
    NOT?: TwoFactorBackupScalarWhereWithAggregatesInput | TwoFactorBackupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TwoFactorBackup"> | number
    userId?: IntWithAggregatesFilter<"TwoFactorBackup"> | number
    code?: StringWithAggregatesFilter<"TwoFactorBackup"> | string
    used?: BoolWithAggregatesFilter<"TwoFactorBackup"> | boolean
    usedAt?: DateTimeNullableWithAggregatesFilter<"TwoFactorBackup"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TwoFactorBackup"> | Date | string
  }

  export type SSOConfigurationWhereInput = {
    AND?: SSOConfigurationWhereInput | SSOConfigurationWhereInput[]
    OR?: SSOConfigurationWhereInput[]
    NOT?: SSOConfigurationWhereInput | SSOConfigurationWhereInput[]
    id?: IntFilter<"SSOConfiguration"> | number
    orgId?: IntFilter<"SSOConfiguration"> | number
    provider?: EnumSSOProviderFilter<"SSOConfiguration"> | $Enums.SSOProvider
    enabled?: BoolFilter<"SSOConfiguration"> | boolean
    samlEntryPoint?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlIssuer?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlCert?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlCallbackUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlLogoutUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthClientId?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthClientSecret?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthAuthUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthTokenUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthUserInfoUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthScopes?: StringNullableListFilter<"SSOConfiguration">
    domainRestriction?: StringNullableListFilter<"SSOConfiguration">
    jitProvisioning?: BoolFilter<"SSOConfiguration"> | boolean
    defaultRole?: EnumRoleFilter<"SSOConfiguration"> | $Enums.Role
    defaultTier?: EnumUserTierFilter<"SSOConfiguration"> | $Enums.UserTier
    metadata?: JsonNullableFilter<"SSOConfiguration">
    createdBy?: IntFilter<"SSOConfiguration"> | number
    createdAt?: DateTimeFilter<"SSOConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"SSOConfiguration"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"SSOConfiguration"> | Date | string | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type SSOConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    provider?: SortOrder
    enabled?: SortOrder
    samlEntryPoint?: SortOrderInput | SortOrder
    samlIssuer?: SortOrderInput | SortOrder
    samlCert?: SortOrderInput | SortOrder
    samlCallbackUrl?: SortOrderInput | SortOrder
    samlLogoutUrl?: SortOrderInput | SortOrder
    oauthClientId?: SortOrderInput | SortOrder
    oauthClientSecret?: SortOrderInput | SortOrder
    oauthAuthUrl?: SortOrderInput | SortOrder
    oauthTokenUrl?: SortOrderInput | SortOrder
    oauthUserInfoUrl?: SortOrderInput | SortOrder
    oauthScopes?: SortOrder
    domainRestriction?: SortOrder
    jitProvisioning?: SortOrder
    defaultRole?: SortOrder
    defaultTier?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type SSOConfigurationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orgId_provider?: SSOConfigurationOrgIdProviderCompoundUniqueInput
    AND?: SSOConfigurationWhereInput | SSOConfigurationWhereInput[]
    OR?: SSOConfigurationWhereInput[]
    NOT?: SSOConfigurationWhereInput | SSOConfigurationWhereInput[]
    orgId?: IntFilter<"SSOConfiguration"> | number
    provider?: EnumSSOProviderFilter<"SSOConfiguration"> | $Enums.SSOProvider
    enabled?: BoolFilter<"SSOConfiguration"> | boolean
    samlEntryPoint?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlIssuer?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlCert?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlCallbackUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlLogoutUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthClientId?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthClientSecret?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthAuthUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthTokenUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthUserInfoUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthScopes?: StringNullableListFilter<"SSOConfiguration">
    domainRestriction?: StringNullableListFilter<"SSOConfiguration">
    jitProvisioning?: BoolFilter<"SSOConfiguration"> | boolean
    defaultRole?: EnumRoleFilter<"SSOConfiguration"> | $Enums.Role
    defaultTier?: EnumUserTierFilter<"SSOConfiguration"> | $Enums.UserTier
    metadata?: JsonNullableFilter<"SSOConfiguration">
    createdBy?: IntFilter<"SSOConfiguration"> | number
    createdAt?: DateTimeFilter<"SSOConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"SSOConfiguration"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"SSOConfiguration"> | Date | string | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "orgId_provider">

  export type SSOConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    provider?: SortOrder
    enabled?: SortOrder
    samlEntryPoint?: SortOrderInput | SortOrder
    samlIssuer?: SortOrderInput | SortOrder
    samlCert?: SortOrderInput | SortOrder
    samlCallbackUrl?: SortOrderInput | SortOrder
    samlLogoutUrl?: SortOrderInput | SortOrder
    oauthClientId?: SortOrderInput | SortOrder
    oauthClientSecret?: SortOrderInput | SortOrder
    oauthAuthUrl?: SortOrderInput | SortOrder
    oauthTokenUrl?: SortOrderInput | SortOrder
    oauthUserInfoUrl?: SortOrderInput | SortOrder
    oauthScopes?: SortOrder
    domainRestriction?: SortOrder
    jitProvisioning?: SortOrder
    defaultRole?: SortOrder
    defaultTier?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    _count?: SSOConfigurationCountOrderByAggregateInput
    _avg?: SSOConfigurationAvgOrderByAggregateInput
    _max?: SSOConfigurationMaxOrderByAggregateInput
    _min?: SSOConfigurationMinOrderByAggregateInput
    _sum?: SSOConfigurationSumOrderByAggregateInput
  }

  export type SSOConfigurationScalarWhereWithAggregatesInput = {
    AND?: SSOConfigurationScalarWhereWithAggregatesInput | SSOConfigurationScalarWhereWithAggregatesInput[]
    OR?: SSOConfigurationScalarWhereWithAggregatesInput[]
    NOT?: SSOConfigurationScalarWhereWithAggregatesInput | SSOConfigurationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SSOConfiguration"> | number
    orgId?: IntWithAggregatesFilter<"SSOConfiguration"> | number
    provider?: EnumSSOProviderWithAggregatesFilter<"SSOConfiguration"> | $Enums.SSOProvider
    enabled?: BoolWithAggregatesFilter<"SSOConfiguration"> | boolean
    samlEntryPoint?: StringNullableWithAggregatesFilter<"SSOConfiguration"> | string | null
    samlIssuer?: StringNullableWithAggregatesFilter<"SSOConfiguration"> | string | null
    samlCert?: StringNullableWithAggregatesFilter<"SSOConfiguration"> | string | null
    samlCallbackUrl?: StringNullableWithAggregatesFilter<"SSOConfiguration"> | string | null
    samlLogoutUrl?: StringNullableWithAggregatesFilter<"SSOConfiguration"> | string | null
    oauthClientId?: StringNullableWithAggregatesFilter<"SSOConfiguration"> | string | null
    oauthClientSecret?: StringNullableWithAggregatesFilter<"SSOConfiguration"> | string | null
    oauthAuthUrl?: StringNullableWithAggregatesFilter<"SSOConfiguration"> | string | null
    oauthTokenUrl?: StringNullableWithAggregatesFilter<"SSOConfiguration"> | string | null
    oauthUserInfoUrl?: StringNullableWithAggregatesFilter<"SSOConfiguration"> | string | null
    oauthScopes?: StringNullableListFilter<"SSOConfiguration">
    domainRestriction?: StringNullableListFilter<"SSOConfiguration">
    jitProvisioning?: BoolWithAggregatesFilter<"SSOConfiguration"> | boolean
    defaultRole?: EnumRoleWithAggregatesFilter<"SSOConfiguration"> | $Enums.Role
    defaultTier?: EnumUserTierWithAggregatesFilter<"SSOConfiguration"> | $Enums.UserTier
    metadata?: JsonNullableWithAggregatesFilter<"SSOConfiguration">
    createdBy?: IntWithAggregatesFilter<"SSOConfiguration"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SSOConfiguration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SSOConfiguration"> | Date | string
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"SSOConfiguration"> | Date | string | null
  }

  export type SSOSessionWhereInput = {
    AND?: SSOSessionWhereInput | SSOSessionWhereInput[]
    OR?: SSOSessionWhereInput[]
    NOT?: SSOSessionWhereInput | SSOSessionWhereInput[]
    id?: IntFilter<"SSOSession"> | number
    userId?: IntFilter<"SSOSession"> | number
    provider?: EnumSSOProviderFilter<"SSOSession"> | $Enums.SSOProvider
    sessionId?: StringFilter<"SSOSession"> | string
    nameId?: StringNullableFilter<"SSOSession"> | string | null
    sessionIndex?: StringNullableFilter<"SSOSession"> | string | null
    attributes?: JsonNullableFilter<"SSOSession">
    ipAddress?: StringNullableFilter<"SSOSession"> | string | null
    userAgent?: StringNullableFilter<"SSOSession"> | string | null
    expiresAt?: DateTimeFilter<"SSOSession"> | Date | string
    createdAt?: DateTimeFilter<"SSOSession"> | Date | string
    lastActivityAt?: DateTimeFilter<"SSOSession"> | Date | string
  }

  export type SSOSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    sessionId?: SortOrder
    nameId?: SortOrderInput | SortOrder
    sessionIndex?: SortOrderInput | SortOrder
    attributes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastActivityAt?: SortOrder
  }

  export type SSOSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sessionId?: string
    AND?: SSOSessionWhereInput | SSOSessionWhereInput[]
    OR?: SSOSessionWhereInput[]
    NOT?: SSOSessionWhereInput | SSOSessionWhereInput[]
    userId?: IntFilter<"SSOSession"> | number
    provider?: EnumSSOProviderFilter<"SSOSession"> | $Enums.SSOProvider
    nameId?: StringNullableFilter<"SSOSession"> | string | null
    sessionIndex?: StringNullableFilter<"SSOSession"> | string | null
    attributes?: JsonNullableFilter<"SSOSession">
    ipAddress?: StringNullableFilter<"SSOSession"> | string | null
    userAgent?: StringNullableFilter<"SSOSession"> | string | null
    expiresAt?: DateTimeFilter<"SSOSession"> | Date | string
    createdAt?: DateTimeFilter<"SSOSession"> | Date | string
    lastActivityAt?: DateTimeFilter<"SSOSession"> | Date | string
  }, "id" | "sessionId">

  export type SSOSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    sessionId?: SortOrder
    nameId?: SortOrderInput | SortOrder
    sessionIndex?: SortOrderInput | SortOrder
    attributes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastActivityAt?: SortOrder
    _count?: SSOSessionCountOrderByAggregateInput
    _avg?: SSOSessionAvgOrderByAggregateInput
    _max?: SSOSessionMaxOrderByAggregateInput
    _min?: SSOSessionMinOrderByAggregateInput
    _sum?: SSOSessionSumOrderByAggregateInput
  }

  export type SSOSessionScalarWhereWithAggregatesInput = {
    AND?: SSOSessionScalarWhereWithAggregatesInput | SSOSessionScalarWhereWithAggregatesInput[]
    OR?: SSOSessionScalarWhereWithAggregatesInput[]
    NOT?: SSOSessionScalarWhereWithAggregatesInput | SSOSessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SSOSession"> | number
    userId?: IntWithAggregatesFilter<"SSOSession"> | number
    provider?: EnumSSOProviderWithAggregatesFilter<"SSOSession"> | $Enums.SSOProvider
    sessionId?: StringWithAggregatesFilter<"SSOSession"> | string
    nameId?: StringNullableWithAggregatesFilter<"SSOSession"> | string | null
    sessionIndex?: StringNullableWithAggregatesFilter<"SSOSession"> | string | null
    attributes?: JsonNullableWithAggregatesFilter<"SSOSession">
    ipAddress?: StringNullableWithAggregatesFilter<"SSOSession"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"SSOSession"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"SSOSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SSOSession"> | Date | string
    lastActivityAt?: DateTimeWithAggregatesFilter<"SSOSession"> | Date | string
  }

  export type SSOAuditLogWhereInput = {
    AND?: SSOAuditLogWhereInput | SSOAuditLogWhereInput[]
    OR?: SSOAuditLogWhereInput[]
    NOT?: SSOAuditLogWhereInput | SSOAuditLogWhereInput[]
    id?: IntFilter<"SSOAuditLog"> | number
    orgId?: IntNullableFilter<"SSOAuditLog"> | number | null
    userId?: IntNullableFilter<"SSOAuditLog"> | number | null
    provider?: EnumSSOProviderFilter<"SSOAuditLog"> | $Enums.SSOProvider
    eventType?: EnumSSOEventTypeFilter<"SSOAuditLog"> | $Enums.SSOEventType
    success?: BoolFilter<"SSOAuditLog"> | boolean
    ipAddress?: StringNullableFilter<"SSOAuditLog"> | string | null
    userAgent?: StringNullableFilter<"SSOAuditLog"> | string | null
    errorMessage?: StringNullableFilter<"SSOAuditLog"> | string | null
    metadata?: JsonNullableFilter<"SSOAuditLog">
    createdAt?: DateTimeFilter<"SSOAuditLog"> | Date | string
  }

  export type SSOAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    provider?: SortOrder
    eventType?: SortOrder
    success?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type SSOAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SSOAuditLogWhereInput | SSOAuditLogWhereInput[]
    OR?: SSOAuditLogWhereInput[]
    NOT?: SSOAuditLogWhereInput | SSOAuditLogWhereInput[]
    orgId?: IntNullableFilter<"SSOAuditLog"> | number | null
    userId?: IntNullableFilter<"SSOAuditLog"> | number | null
    provider?: EnumSSOProviderFilter<"SSOAuditLog"> | $Enums.SSOProvider
    eventType?: EnumSSOEventTypeFilter<"SSOAuditLog"> | $Enums.SSOEventType
    success?: BoolFilter<"SSOAuditLog"> | boolean
    ipAddress?: StringNullableFilter<"SSOAuditLog"> | string | null
    userAgent?: StringNullableFilter<"SSOAuditLog"> | string | null
    errorMessage?: StringNullableFilter<"SSOAuditLog"> | string | null
    metadata?: JsonNullableFilter<"SSOAuditLog">
    createdAt?: DateTimeFilter<"SSOAuditLog"> | Date | string
  }, "id">

  export type SSOAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    provider?: SortOrder
    eventType?: SortOrder
    success?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SSOAuditLogCountOrderByAggregateInput
    _avg?: SSOAuditLogAvgOrderByAggregateInput
    _max?: SSOAuditLogMaxOrderByAggregateInput
    _min?: SSOAuditLogMinOrderByAggregateInput
    _sum?: SSOAuditLogSumOrderByAggregateInput
  }

  export type SSOAuditLogScalarWhereWithAggregatesInput = {
    AND?: SSOAuditLogScalarWhereWithAggregatesInput | SSOAuditLogScalarWhereWithAggregatesInput[]
    OR?: SSOAuditLogScalarWhereWithAggregatesInput[]
    NOT?: SSOAuditLogScalarWhereWithAggregatesInput | SSOAuditLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SSOAuditLog"> | number
    orgId?: IntNullableWithAggregatesFilter<"SSOAuditLog"> | number | null
    userId?: IntNullableWithAggregatesFilter<"SSOAuditLog"> | number | null
    provider?: EnumSSOProviderWithAggregatesFilter<"SSOAuditLog"> | $Enums.SSOProvider
    eventType?: EnumSSOEventTypeWithAggregatesFilter<"SSOAuditLog"> | $Enums.SSOEventType
    success?: BoolWithAggregatesFilter<"SSOAuditLog"> | boolean
    ipAddress?: StringNullableWithAggregatesFilter<"SSOAuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"SSOAuditLog"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"SSOAuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"SSOAuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"SSOAuditLog"> | Date | string
  }

  export type NotificationPreferenceWhereInput = {
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    id?: IntFilter<"NotificationPreference"> | number
    userId?: IntFilter<"NotificationPreference"> | number
    emailEnabled?: BoolFilter<"NotificationPreference"> | boolean
    testComplete?: BoolFilter<"NotificationPreference"> | boolean
    batchComplete?: BoolFilter<"NotificationPreference"> | boolean
    scheduledTestComplete?: BoolFilter<"NotificationPreference"> | boolean
    alertsEnabled?: BoolFilter<"NotificationPreference"> | boolean
    lowScoreThreshold?: FloatFilter<"NotificationPreference"> | number
    highScoreThreshold?: FloatFilter<"NotificationPreference"> | number
    scoreDropAlert?: BoolFilter<"NotificationPreference"> | boolean
    witnessFailureAlert?: BoolFilter<"NotificationPreference"> | boolean
    dailyReport?: BoolFilter<"NotificationPreference"> | boolean
    weeklyReport?: BoolFilter<"NotificationPreference"> | boolean
    monthlyReport?: BoolFilter<"NotificationPreference"> | boolean
    reportTime?: StringFilter<"NotificationPreference"> | string
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    testComplete?: SortOrder
    batchComplete?: SortOrder
    scheduledTestComplete?: SortOrder
    alertsEnabled?: SortOrder
    lowScoreThreshold?: SortOrder
    highScoreThreshold?: SortOrder
    scoreDropAlert?: SortOrder
    witnessFailureAlert?: SortOrder
    dailyReport?: SortOrder
    weeklyReport?: SortOrder
    monthlyReport?: SortOrder
    reportTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    emailEnabled?: BoolFilter<"NotificationPreference"> | boolean
    testComplete?: BoolFilter<"NotificationPreference"> | boolean
    batchComplete?: BoolFilter<"NotificationPreference"> | boolean
    scheduledTestComplete?: BoolFilter<"NotificationPreference"> | boolean
    alertsEnabled?: BoolFilter<"NotificationPreference"> | boolean
    lowScoreThreshold?: FloatFilter<"NotificationPreference"> | number
    highScoreThreshold?: FloatFilter<"NotificationPreference"> | number
    scoreDropAlert?: BoolFilter<"NotificationPreference"> | boolean
    witnessFailureAlert?: BoolFilter<"NotificationPreference"> | boolean
    dailyReport?: BoolFilter<"NotificationPreference"> | boolean
    weeklyReport?: BoolFilter<"NotificationPreference"> | boolean
    monthlyReport?: BoolFilter<"NotificationPreference"> | boolean
    reportTime?: StringFilter<"NotificationPreference"> | string
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NotificationPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    testComplete?: SortOrder
    batchComplete?: SortOrder
    scheduledTestComplete?: SortOrder
    alertsEnabled?: SortOrder
    lowScoreThreshold?: SortOrder
    highScoreThreshold?: SortOrder
    scoreDropAlert?: SortOrder
    witnessFailureAlert?: SortOrder
    dailyReport?: SortOrder
    weeklyReport?: SortOrder
    monthlyReport?: SortOrder
    reportTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPreferenceCountOrderByAggregateInput
    _avg?: NotificationPreferenceAvgOrderByAggregateInput
    _max?: NotificationPreferenceMaxOrderByAggregateInput
    _min?: NotificationPreferenceMinOrderByAggregateInput
    _sum?: NotificationPreferenceSumOrderByAggregateInput
  }

  export type NotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    OR?: NotificationPreferenceScalarWhereWithAggregatesInput[]
    NOT?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NotificationPreference"> | number
    userId?: IntWithAggregatesFilter<"NotificationPreference"> | number
    emailEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    testComplete?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    batchComplete?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    scheduledTestComplete?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    alertsEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    lowScoreThreshold?: FloatWithAggregatesFilter<"NotificationPreference"> | number
    highScoreThreshold?: FloatWithAggregatesFilter<"NotificationPreference"> | number
    scoreDropAlert?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    witnessFailureAlert?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    dailyReport?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    weeklyReport?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    monthlyReport?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    reportTime?: StringWithAggregatesFilter<"NotificationPreference"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
  }

  export type TestResultWhereInput = {
    AND?: TestResultWhereInput | TestResultWhereInput[]
    OR?: TestResultWhereInput[]
    NOT?: TestResultWhereInput | TestResultWhereInput[]
    id?: IntFilter<"TestResult"> | number
    userId?: IntFilter<"TestResult"> | number
    modelName?: StringFilter<"TestResult"> | string
    modelProvider?: StringFilter<"TestResult"> | string
    prompt?: StringFilter<"TestResult"> | string
    response?: StringNullableFilter<"TestResult"> | string | null
    criesScore?: FloatNullableFilter<"TestResult"> | number | null
    responseTime?: IntNullableFilter<"TestResult"> | number | null
    tokenCount?: IntNullableFilter<"TestResult"> | number | null
    cost?: FloatNullableFilter<"TestResult"> | number | null
    status?: StringFilter<"TestResult"> | string
    errorMessage?: StringNullableFilter<"TestResult"> | string | null
    metadata?: JsonNullableFilter<"TestResult">
    createdAt?: DateTimeFilter<"TestResult"> | Date | string
  }

  export type TestResultOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    modelName?: SortOrder
    modelProvider?: SortOrder
    prompt?: SortOrder
    response?: SortOrderInput | SortOrder
    criesScore?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    tokenCount?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type TestResultWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TestResultWhereInput | TestResultWhereInput[]
    OR?: TestResultWhereInput[]
    NOT?: TestResultWhereInput | TestResultWhereInput[]
    userId?: IntFilter<"TestResult"> | number
    modelName?: StringFilter<"TestResult"> | string
    modelProvider?: StringFilter<"TestResult"> | string
    prompt?: StringFilter<"TestResult"> | string
    response?: StringNullableFilter<"TestResult"> | string | null
    criesScore?: FloatNullableFilter<"TestResult"> | number | null
    responseTime?: IntNullableFilter<"TestResult"> | number | null
    tokenCount?: IntNullableFilter<"TestResult"> | number | null
    cost?: FloatNullableFilter<"TestResult"> | number | null
    status?: StringFilter<"TestResult"> | string
    errorMessage?: StringNullableFilter<"TestResult"> | string | null
    metadata?: JsonNullableFilter<"TestResult">
    createdAt?: DateTimeFilter<"TestResult"> | Date | string
  }, "id">

  export type TestResultOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    modelName?: SortOrder
    modelProvider?: SortOrder
    prompt?: SortOrder
    response?: SortOrderInput | SortOrder
    criesScore?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    tokenCount?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TestResultCountOrderByAggregateInput
    _avg?: TestResultAvgOrderByAggregateInput
    _max?: TestResultMaxOrderByAggregateInput
    _min?: TestResultMinOrderByAggregateInput
    _sum?: TestResultSumOrderByAggregateInput
  }

  export type TestResultScalarWhereWithAggregatesInput = {
    AND?: TestResultScalarWhereWithAggregatesInput | TestResultScalarWhereWithAggregatesInput[]
    OR?: TestResultScalarWhereWithAggregatesInput[]
    NOT?: TestResultScalarWhereWithAggregatesInput | TestResultScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TestResult"> | number
    userId?: IntWithAggregatesFilter<"TestResult"> | number
    modelName?: StringWithAggregatesFilter<"TestResult"> | string
    modelProvider?: StringWithAggregatesFilter<"TestResult"> | string
    prompt?: StringWithAggregatesFilter<"TestResult"> | string
    response?: StringNullableWithAggregatesFilter<"TestResult"> | string | null
    criesScore?: FloatNullableWithAggregatesFilter<"TestResult"> | number | null
    responseTime?: IntNullableWithAggregatesFilter<"TestResult"> | number | null
    tokenCount?: IntNullableWithAggregatesFilter<"TestResult"> | number | null
    cost?: FloatNullableWithAggregatesFilter<"TestResult"> | number | null
    status?: StringWithAggregatesFilter<"TestResult"> | string
    errorMessage?: StringNullableWithAggregatesFilter<"TestResult"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"TestResult">
    createdAt?: DateTimeWithAggregatesFilter<"TestResult"> | Date | string
  }

  export type LamportCounterWhereInput = {
    AND?: LamportCounterWhereInput | LamportCounterWhereInput[]
    OR?: LamportCounterWhereInput[]
    NOT?: LamportCounterWhereInput | LamportCounterWhereInput[]
    id?: IntFilter<"LamportCounter"> | number
    currentValue?: IntFilter<"LamportCounter"> | number
    lastUpdated?: DateTimeFilter<"LamportCounter"> | Date | string
    lastReceiptId?: IntNullableFilter<"LamportCounter"> | number | null
    metadata?: JsonNullableFilter<"LamportCounter">
  }

  export type LamportCounterOrderByWithRelationInput = {
    id?: SortOrder
    currentValue?: SortOrder
    lastUpdated?: SortOrder
    lastReceiptId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
  }

  export type LamportCounterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LamportCounterWhereInput | LamportCounterWhereInput[]
    OR?: LamportCounterWhereInput[]
    NOT?: LamportCounterWhereInput | LamportCounterWhereInput[]
    currentValue?: IntFilter<"LamportCounter"> | number
    lastUpdated?: DateTimeFilter<"LamportCounter"> | Date | string
    lastReceiptId?: IntNullableFilter<"LamportCounter"> | number | null
    metadata?: JsonNullableFilter<"LamportCounter">
  }, "id">

  export type LamportCounterOrderByWithAggregationInput = {
    id?: SortOrder
    currentValue?: SortOrder
    lastUpdated?: SortOrder
    lastReceiptId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: LamportCounterCountOrderByAggregateInput
    _avg?: LamportCounterAvgOrderByAggregateInput
    _max?: LamportCounterMaxOrderByAggregateInput
    _min?: LamportCounterMinOrderByAggregateInput
    _sum?: LamportCounterSumOrderByAggregateInput
  }

  export type LamportCounterScalarWhereWithAggregatesInput = {
    AND?: LamportCounterScalarWhereWithAggregatesInput | LamportCounterScalarWhereWithAggregatesInput[]
    OR?: LamportCounterScalarWhereWithAggregatesInput[]
    NOT?: LamportCounterScalarWhereWithAggregatesInput | LamportCounterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LamportCounter"> | number
    currentValue?: IntWithAggregatesFilter<"LamportCounter"> | number
    lastUpdated?: DateTimeWithAggregatesFilter<"LamportCounter"> | Date | string
    lastReceiptId?: IntNullableWithAggregatesFilter<"LamportCounter"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"LamportCounter">
  }

  export type BENReceiptWhereInput = {
    AND?: BENReceiptWhereInput | BENReceiptWhereInput[]
    OR?: BENReceiptWhereInput[]
    NOT?: BENReceiptWhereInput | BENReceiptWhereInput[]
    id?: IntFilter<"BENReceipt"> | number
    receiptType?: EnumReceiptTypeFilter<"BENReceipt"> | $Enums.ReceiptType
    lamportClock?: IntFilter<"BENReceipt"> | number
    realTimestamp?: DateTimeFilter<"BENReceipt"> | Date | string
    userId?: IntNullableFilter<"BENReceipt"> | number | null
    persona?: EnumBENPersonaFilter<"BENReceipt"> | $Enums.BENPersona
    track?: EnumTrackTypeNullableFilter<"BENReceipt"> | $Enums.TrackType | null
    payload?: JsonFilter<"BENReceipt">
    digest?: StringFilter<"BENReceipt"> | string
    previousDigest?: StringNullableFilter<"BENReceipt"> | string | null
    baselineDigest?: StringNullableFilter<"BENReceipt"> | string | null
    witnessModel?: StringNullableFilter<"BENReceipt"> | string | null
    witnessSignature?: StringNullableFilter<"BENReceipt"> | string | null
    metadata?: JsonNullableFilter<"BENReceipt">
    createdAt?: DateTimeFilter<"BENReceipt"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    handoffsFrom?: TriTrackHandoffListRelationFilter
    handoffsTo?: TriTrackHandoffListRelationFilter
  }

  export type BENReceiptOrderByWithRelationInput = {
    id?: SortOrder
    receiptType?: SortOrder
    lamportClock?: SortOrder
    realTimestamp?: SortOrder
    userId?: SortOrderInput | SortOrder
    persona?: SortOrder
    track?: SortOrderInput | SortOrder
    payload?: SortOrder
    digest?: SortOrder
    previousDigest?: SortOrderInput | SortOrder
    baselineDigest?: SortOrderInput | SortOrder
    witnessModel?: SortOrderInput | SortOrder
    witnessSignature?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    handoffsFrom?: TriTrackHandoffOrderByRelationAggregateInput
    handoffsTo?: TriTrackHandoffOrderByRelationAggregateInput
  }

  export type BENReceiptWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BENReceiptWhereInput | BENReceiptWhereInput[]
    OR?: BENReceiptWhereInput[]
    NOT?: BENReceiptWhereInput | BENReceiptWhereInput[]
    receiptType?: EnumReceiptTypeFilter<"BENReceipt"> | $Enums.ReceiptType
    lamportClock?: IntFilter<"BENReceipt"> | number
    realTimestamp?: DateTimeFilter<"BENReceipt"> | Date | string
    userId?: IntNullableFilter<"BENReceipt"> | number | null
    persona?: EnumBENPersonaFilter<"BENReceipt"> | $Enums.BENPersona
    track?: EnumTrackTypeNullableFilter<"BENReceipt"> | $Enums.TrackType | null
    payload?: JsonFilter<"BENReceipt">
    digest?: StringFilter<"BENReceipt"> | string
    previousDigest?: StringNullableFilter<"BENReceipt"> | string | null
    baselineDigest?: StringNullableFilter<"BENReceipt"> | string | null
    witnessModel?: StringNullableFilter<"BENReceipt"> | string | null
    witnessSignature?: StringNullableFilter<"BENReceipt"> | string | null
    metadata?: JsonNullableFilter<"BENReceipt">
    createdAt?: DateTimeFilter<"BENReceipt"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    handoffsFrom?: TriTrackHandoffListRelationFilter
    handoffsTo?: TriTrackHandoffListRelationFilter
  }, "id">

  export type BENReceiptOrderByWithAggregationInput = {
    id?: SortOrder
    receiptType?: SortOrder
    lamportClock?: SortOrder
    realTimestamp?: SortOrder
    userId?: SortOrderInput | SortOrder
    persona?: SortOrder
    track?: SortOrderInput | SortOrder
    payload?: SortOrder
    digest?: SortOrder
    previousDigest?: SortOrderInput | SortOrder
    baselineDigest?: SortOrderInput | SortOrder
    witnessModel?: SortOrderInput | SortOrder
    witnessSignature?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BENReceiptCountOrderByAggregateInput
    _avg?: BENReceiptAvgOrderByAggregateInput
    _max?: BENReceiptMaxOrderByAggregateInput
    _min?: BENReceiptMinOrderByAggregateInput
    _sum?: BENReceiptSumOrderByAggregateInput
  }

  export type BENReceiptScalarWhereWithAggregatesInput = {
    AND?: BENReceiptScalarWhereWithAggregatesInput | BENReceiptScalarWhereWithAggregatesInput[]
    OR?: BENReceiptScalarWhereWithAggregatesInput[]
    NOT?: BENReceiptScalarWhereWithAggregatesInput | BENReceiptScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BENReceipt"> | number
    receiptType?: EnumReceiptTypeWithAggregatesFilter<"BENReceipt"> | $Enums.ReceiptType
    lamportClock?: IntWithAggregatesFilter<"BENReceipt"> | number
    realTimestamp?: DateTimeWithAggregatesFilter<"BENReceipt"> | Date | string
    userId?: IntNullableWithAggregatesFilter<"BENReceipt"> | number | null
    persona?: EnumBENPersonaWithAggregatesFilter<"BENReceipt"> | $Enums.BENPersona
    track?: EnumTrackTypeNullableWithAggregatesFilter<"BENReceipt"> | $Enums.TrackType | null
    payload?: JsonWithAggregatesFilter<"BENReceipt">
    digest?: StringWithAggregatesFilter<"BENReceipt"> | string
    previousDigest?: StringNullableWithAggregatesFilter<"BENReceipt"> | string | null
    baselineDigest?: StringNullableWithAggregatesFilter<"BENReceipt"> | string | null
    witnessModel?: StringNullableWithAggregatesFilter<"BENReceipt"> | string | null
    witnessSignature?: StringNullableWithAggregatesFilter<"BENReceipt"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"BENReceipt">
    createdAt?: DateTimeWithAggregatesFilter<"BENReceipt"> | Date | string
  }

  export type BENSessionWhereInput = {
    AND?: BENSessionWhereInput | BENSessionWhereInput[]
    OR?: BENSessionWhereInput[]
    NOT?: BENSessionWhereInput | BENSessionWhereInput[]
    id?: IntFilter<"BENSession"> | number
    userId?: IntFilter<"BENSession"> | number
    persona?: EnumBENPersonaFilter<"BENSession"> | $Enums.BENPersona
    priority?: IntFilter<"BENSession"> | number
    locked?: BoolFilter<"BENSession"> | boolean
    startedAt?: DateTimeFilter<"BENSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"BENSession"> | Date | string | null
    duration?: IntNullableFilter<"BENSession"> | number | null
    startLamport?: IntFilter<"BENSession"> | number
    endLamport?: IntNullableFilter<"BENSession"> | number | null
    switchReason?: StringNullableFilter<"BENSession"> | string | null
    metadata?: JsonNullableFilter<"BENSession">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BENSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    persona?: SortOrder
    priority?: SortOrder
    locked?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    startLamport?: SortOrder
    endLamport?: SortOrderInput | SortOrder
    switchReason?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BENSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BENSessionWhereInput | BENSessionWhereInput[]
    OR?: BENSessionWhereInput[]
    NOT?: BENSessionWhereInput | BENSessionWhereInput[]
    userId?: IntFilter<"BENSession"> | number
    persona?: EnumBENPersonaFilter<"BENSession"> | $Enums.BENPersona
    priority?: IntFilter<"BENSession"> | number
    locked?: BoolFilter<"BENSession"> | boolean
    startedAt?: DateTimeFilter<"BENSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"BENSession"> | Date | string | null
    duration?: IntNullableFilter<"BENSession"> | number | null
    startLamport?: IntFilter<"BENSession"> | number
    endLamport?: IntNullableFilter<"BENSession"> | number | null
    switchReason?: StringNullableFilter<"BENSession"> | string | null
    metadata?: JsonNullableFilter<"BENSession">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type BENSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    persona?: SortOrder
    priority?: SortOrder
    locked?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    startLamport?: SortOrder
    endLamport?: SortOrderInput | SortOrder
    switchReason?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: BENSessionCountOrderByAggregateInput
    _avg?: BENSessionAvgOrderByAggregateInput
    _max?: BENSessionMaxOrderByAggregateInput
    _min?: BENSessionMinOrderByAggregateInput
    _sum?: BENSessionSumOrderByAggregateInput
  }

  export type BENSessionScalarWhereWithAggregatesInput = {
    AND?: BENSessionScalarWhereWithAggregatesInput | BENSessionScalarWhereWithAggregatesInput[]
    OR?: BENSessionScalarWhereWithAggregatesInput[]
    NOT?: BENSessionScalarWhereWithAggregatesInput | BENSessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BENSession"> | number
    userId?: IntWithAggregatesFilter<"BENSession"> | number
    persona?: EnumBENPersonaWithAggregatesFilter<"BENSession"> | $Enums.BENPersona
    priority?: IntWithAggregatesFilter<"BENSession"> | number
    locked?: BoolWithAggregatesFilter<"BENSession"> | boolean
    startedAt?: DateTimeWithAggregatesFilter<"BENSession"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"BENSession"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"BENSession"> | number | null
    startLamport?: IntWithAggregatesFilter<"BENSession"> | number
    endLamport?: IntNullableWithAggregatesFilter<"BENSession"> | number | null
    switchReason?: StringNullableWithAggregatesFilter<"BENSession"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"BENSession">
  }

  export type TriTrackHandoffWhereInput = {
    AND?: TriTrackHandoffWhereInput | TriTrackHandoffWhereInput[]
    OR?: TriTrackHandoffWhereInput[]
    NOT?: TriTrackHandoffWhereInput | TriTrackHandoffWhereInput[]
    id?: IntFilter<"TriTrackHandoff"> | number
    fromTrack?: EnumTrackTypeFilter<"TriTrackHandoff"> | $Enums.TrackType
    toTrack?: EnumTrackTypeFilter<"TriTrackHandoff"> | $Enums.TrackType
    status?: EnumHandoffStatusFilter<"TriTrackHandoff"> | $Enums.HandoffStatus
    fromReceiptId?: IntFilter<"TriTrackHandoff"> | number
    toReceiptId?: IntNullableFilter<"TriTrackHandoff"> | number | null
    initiatedAt?: DateTimeFilter<"TriTrackHandoff"> | Date | string
    completedAt?: DateTimeNullableFilter<"TriTrackHandoff"> | Date | string | null
    latencyMs?: IntNullableFilter<"TriTrackHandoff"> | number | null
    exceededLimit?: BoolFilter<"TriTrackHandoff"> | boolean
    payload?: JsonFilter<"TriTrackHandoff">
    result?: JsonNullableFilter<"TriTrackHandoff">
    errorMessage?: StringNullableFilter<"TriTrackHandoff"> | string | null
    metadata?: JsonNullableFilter<"TriTrackHandoff">
    fromReceipt?: XOR<BENReceiptScalarRelationFilter, BENReceiptWhereInput>
    toReceipt?: XOR<BENReceiptNullableScalarRelationFilter, BENReceiptWhereInput> | null
  }

  export type TriTrackHandoffOrderByWithRelationInput = {
    id?: SortOrder
    fromTrack?: SortOrder
    toTrack?: SortOrder
    status?: SortOrder
    fromReceiptId?: SortOrder
    toReceiptId?: SortOrderInput | SortOrder
    initiatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    latencyMs?: SortOrderInput | SortOrder
    exceededLimit?: SortOrder
    payload?: SortOrder
    result?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    fromReceipt?: BENReceiptOrderByWithRelationInput
    toReceipt?: BENReceiptOrderByWithRelationInput
  }

  export type TriTrackHandoffWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TriTrackHandoffWhereInput | TriTrackHandoffWhereInput[]
    OR?: TriTrackHandoffWhereInput[]
    NOT?: TriTrackHandoffWhereInput | TriTrackHandoffWhereInput[]
    fromTrack?: EnumTrackTypeFilter<"TriTrackHandoff"> | $Enums.TrackType
    toTrack?: EnumTrackTypeFilter<"TriTrackHandoff"> | $Enums.TrackType
    status?: EnumHandoffStatusFilter<"TriTrackHandoff"> | $Enums.HandoffStatus
    fromReceiptId?: IntFilter<"TriTrackHandoff"> | number
    toReceiptId?: IntNullableFilter<"TriTrackHandoff"> | number | null
    initiatedAt?: DateTimeFilter<"TriTrackHandoff"> | Date | string
    completedAt?: DateTimeNullableFilter<"TriTrackHandoff"> | Date | string | null
    latencyMs?: IntNullableFilter<"TriTrackHandoff"> | number | null
    exceededLimit?: BoolFilter<"TriTrackHandoff"> | boolean
    payload?: JsonFilter<"TriTrackHandoff">
    result?: JsonNullableFilter<"TriTrackHandoff">
    errorMessage?: StringNullableFilter<"TriTrackHandoff"> | string | null
    metadata?: JsonNullableFilter<"TriTrackHandoff">
    fromReceipt?: XOR<BENReceiptScalarRelationFilter, BENReceiptWhereInput>
    toReceipt?: XOR<BENReceiptNullableScalarRelationFilter, BENReceiptWhereInput> | null
  }, "id">

  export type TriTrackHandoffOrderByWithAggregationInput = {
    id?: SortOrder
    fromTrack?: SortOrder
    toTrack?: SortOrder
    status?: SortOrder
    fromReceiptId?: SortOrder
    toReceiptId?: SortOrderInput | SortOrder
    initiatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    latencyMs?: SortOrderInput | SortOrder
    exceededLimit?: SortOrder
    payload?: SortOrder
    result?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: TriTrackHandoffCountOrderByAggregateInput
    _avg?: TriTrackHandoffAvgOrderByAggregateInput
    _max?: TriTrackHandoffMaxOrderByAggregateInput
    _min?: TriTrackHandoffMinOrderByAggregateInput
    _sum?: TriTrackHandoffSumOrderByAggregateInput
  }

  export type TriTrackHandoffScalarWhereWithAggregatesInput = {
    AND?: TriTrackHandoffScalarWhereWithAggregatesInput | TriTrackHandoffScalarWhereWithAggregatesInput[]
    OR?: TriTrackHandoffScalarWhereWithAggregatesInput[]
    NOT?: TriTrackHandoffScalarWhereWithAggregatesInput | TriTrackHandoffScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TriTrackHandoff"> | number
    fromTrack?: EnumTrackTypeWithAggregatesFilter<"TriTrackHandoff"> | $Enums.TrackType
    toTrack?: EnumTrackTypeWithAggregatesFilter<"TriTrackHandoff"> | $Enums.TrackType
    status?: EnumHandoffStatusWithAggregatesFilter<"TriTrackHandoff"> | $Enums.HandoffStatus
    fromReceiptId?: IntWithAggregatesFilter<"TriTrackHandoff"> | number
    toReceiptId?: IntNullableWithAggregatesFilter<"TriTrackHandoff"> | number | null
    initiatedAt?: DateTimeWithAggregatesFilter<"TriTrackHandoff"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"TriTrackHandoff"> | Date | string | null
    latencyMs?: IntNullableWithAggregatesFilter<"TriTrackHandoff"> | number | null
    exceededLimit?: BoolWithAggregatesFilter<"TriTrackHandoff"> | boolean
    payload?: JsonWithAggregatesFilter<"TriTrackHandoff">
    result?: JsonNullableWithAggregatesFilter<"TriTrackHandoff">
    errorMessage?: StringNullableWithAggregatesFilter<"TriTrackHandoff"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"TriTrackHandoff">
  }

  export type WitnessSignatureWhereInput = {
    AND?: WitnessSignatureWhereInput | WitnessSignatureWhereInput[]
    OR?: WitnessSignatureWhereInput[]
    NOT?: WitnessSignatureWhereInput | WitnessSignatureWhereInput[]
    id?: IntFilter<"WitnessSignature"> | number
    modelName?: StringFilter<"WitnessSignature"> | string
    modelFingerprint?: StringFilter<"WitnessSignature"> | string
    receiptId?: IntNullableFilter<"WitnessSignature"> | number | null
    receiptDigest?: StringFilter<"WitnessSignature"> | string
    signature?: StringFilter<"WitnessSignature"> | string
    signedAt?: DateTimeFilter<"WitnessSignature"> | Date | string
    lamportClock?: IntFilter<"WitnessSignature"> | number
    verified?: BoolFilter<"WitnessSignature"> | boolean
    verifiedAt?: DateTimeNullableFilter<"WitnessSignature"> | Date | string | null
    verificationData?: JsonNullableFilter<"WitnessSignature">
    metadata?: JsonNullableFilter<"WitnessSignature">
  }

  export type WitnessSignatureOrderByWithRelationInput = {
    id?: SortOrder
    modelName?: SortOrder
    modelFingerprint?: SortOrder
    receiptId?: SortOrderInput | SortOrder
    receiptDigest?: SortOrder
    signature?: SortOrder
    signedAt?: SortOrder
    lamportClock?: SortOrder
    verified?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    verificationData?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
  }

  export type WitnessSignatureWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WitnessSignatureWhereInput | WitnessSignatureWhereInput[]
    OR?: WitnessSignatureWhereInput[]
    NOT?: WitnessSignatureWhereInput | WitnessSignatureWhereInput[]
    modelName?: StringFilter<"WitnessSignature"> | string
    modelFingerprint?: StringFilter<"WitnessSignature"> | string
    receiptId?: IntNullableFilter<"WitnessSignature"> | number | null
    receiptDigest?: StringFilter<"WitnessSignature"> | string
    signature?: StringFilter<"WitnessSignature"> | string
    signedAt?: DateTimeFilter<"WitnessSignature"> | Date | string
    lamportClock?: IntFilter<"WitnessSignature"> | number
    verified?: BoolFilter<"WitnessSignature"> | boolean
    verifiedAt?: DateTimeNullableFilter<"WitnessSignature"> | Date | string | null
    verificationData?: JsonNullableFilter<"WitnessSignature">
    metadata?: JsonNullableFilter<"WitnessSignature">
  }, "id">

  export type WitnessSignatureOrderByWithAggregationInput = {
    id?: SortOrder
    modelName?: SortOrder
    modelFingerprint?: SortOrder
    receiptId?: SortOrderInput | SortOrder
    receiptDigest?: SortOrder
    signature?: SortOrder
    signedAt?: SortOrder
    lamportClock?: SortOrder
    verified?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    verificationData?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: WitnessSignatureCountOrderByAggregateInput
    _avg?: WitnessSignatureAvgOrderByAggregateInput
    _max?: WitnessSignatureMaxOrderByAggregateInput
    _min?: WitnessSignatureMinOrderByAggregateInput
    _sum?: WitnessSignatureSumOrderByAggregateInput
  }

  export type WitnessSignatureScalarWhereWithAggregatesInput = {
    AND?: WitnessSignatureScalarWhereWithAggregatesInput | WitnessSignatureScalarWhereWithAggregatesInput[]
    OR?: WitnessSignatureScalarWhereWithAggregatesInput[]
    NOT?: WitnessSignatureScalarWhereWithAggregatesInput | WitnessSignatureScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WitnessSignature"> | number
    modelName?: StringWithAggregatesFilter<"WitnessSignature"> | string
    modelFingerprint?: StringWithAggregatesFilter<"WitnessSignature"> | string
    receiptId?: IntNullableWithAggregatesFilter<"WitnessSignature"> | number | null
    receiptDigest?: StringWithAggregatesFilter<"WitnessSignature"> | string
    signature?: StringWithAggregatesFilter<"WitnessSignature"> | string
    signedAt?: DateTimeWithAggregatesFilter<"WitnessSignature"> | Date | string
    lamportClock?: IntWithAggregatesFilter<"WitnessSignature"> | number
    verified?: BoolWithAggregatesFilter<"WitnessSignature"> | boolean
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"WitnessSignature"> | Date | string | null
    verificationData?: JsonNullableWithAggregatesFilter<"WitnessSignature">
    metadata?: JsonNullableWithAggregatesFilter<"WitnessSignature">
  }

  export type CRIESComputationWhereInput = {
    AND?: CRIESComputationWhereInput | CRIESComputationWhereInput[]
    OR?: CRIESComputationWhereInput[]
    NOT?: CRIESComputationWhereInput | CRIESComputationWhereInput[]
    id?: IntFilter<"CRIESComputation"> | number
    testResultId?: IntNullableFilter<"CRIESComputation"> | number | null
    userId?: IntNullableFilter<"CRIESComputation"> | number | null
    sigmaWindow?: FloatFilter<"CRIESComputation"> | number
    tauThreshold?: FloatFilter<"CRIESComputation"> | number
    piPolicy?: FloatFilter<"CRIESComputation"> | number
    citationQuality?: FloatFilter<"CRIESComputation"> | number
    criesScore?: FloatFilter<"CRIESComputation"> | number
    lamportClock?: IntFilter<"CRIESComputation"> | number
    computedAt?: DateTimeFilter<"CRIESComputation"> | Date | string
    receiptId?: IntNullableFilter<"CRIESComputation"> | number | null
    analysisData?: JsonNullableFilter<"CRIESComputation">
    metadata?: JsonNullableFilter<"CRIESComputation">
  }

  export type CRIESComputationOrderByWithRelationInput = {
    id?: SortOrder
    testResultId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    sigmaWindow?: SortOrder
    tauThreshold?: SortOrder
    piPolicy?: SortOrder
    citationQuality?: SortOrder
    criesScore?: SortOrder
    lamportClock?: SortOrder
    computedAt?: SortOrder
    receiptId?: SortOrderInput | SortOrder
    analysisData?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
  }

  export type CRIESComputationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CRIESComputationWhereInput | CRIESComputationWhereInput[]
    OR?: CRIESComputationWhereInput[]
    NOT?: CRIESComputationWhereInput | CRIESComputationWhereInput[]
    testResultId?: IntNullableFilter<"CRIESComputation"> | number | null
    userId?: IntNullableFilter<"CRIESComputation"> | number | null
    sigmaWindow?: FloatFilter<"CRIESComputation"> | number
    tauThreshold?: FloatFilter<"CRIESComputation"> | number
    piPolicy?: FloatFilter<"CRIESComputation"> | number
    citationQuality?: FloatFilter<"CRIESComputation"> | number
    criesScore?: FloatFilter<"CRIESComputation"> | number
    lamportClock?: IntFilter<"CRIESComputation"> | number
    computedAt?: DateTimeFilter<"CRIESComputation"> | Date | string
    receiptId?: IntNullableFilter<"CRIESComputation"> | number | null
    analysisData?: JsonNullableFilter<"CRIESComputation">
    metadata?: JsonNullableFilter<"CRIESComputation">
  }, "id">

  export type CRIESComputationOrderByWithAggregationInput = {
    id?: SortOrder
    testResultId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    sigmaWindow?: SortOrder
    tauThreshold?: SortOrder
    piPolicy?: SortOrder
    citationQuality?: SortOrder
    criesScore?: SortOrder
    lamportClock?: SortOrder
    computedAt?: SortOrder
    receiptId?: SortOrderInput | SortOrder
    analysisData?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: CRIESComputationCountOrderByAggregateInput
    _avg?: CRIESComputationAvgOrderByAggregateInput
    _max?: CRIESComputationMaxOrderByAggregateInput
    _min?: CRIESComputationMinOrderByAggregateInput
    _sum?: CRIESComputationSumOrderByAggregateInput
  }

  export type CRIESComputationScalarWhereWithAggregatesInput = {
    AND?: CRIESComputationScalarWhereWithAggregatesInput | CRIESComputationScalarWhereWithAggregatesInput[]
    OR?: CRIESComputationScalarWhereWithAggregatesInput[]
    NOT?: CRIESComputationScalarWhereWithAggregatesInput | CRIESComputationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CRIESComputation"> | number
    testResultId?: IntNullableWithAggregatesFilter<"CRIESComputation"> | number | null
    userId?: IntNullableWithAggregatesFilter<"CRIESComputation"> | number | null
    sigmaWindow?: FloatWithAggregatesFilter<"CRIESComputation"> | number
    tauThreshold?: FloatWithAggregatesFilter<"CRIESComputation"> | number
    piPolicy?: FloatWithAggregatesFilter<"CRIESComputation"> | number
    citationQuality?: FloatWithAggregatesFilter<"CRIESComputation"> | number
    criesScore?: FloatWithAggregatesFilter<"CRIESComputation"> | number
    lamportClock?: IntWithAggregatesFilter<"CRIESComputation"> | number
    computedAt?: DateTimeWithAggregatesFilter<"CRIESComputation"> | Date | string
    receiptId?: IntNullableWithAggregatesFilter<"CRIESComputation"> | number | null
    analysisData?: JsonNullableWithAggregatesFilter<"CRIESComputation">
    metadata?: JsonNullableWithAggregatesFilter<"CRIESComputation">
  }

  export type ZScanVerificationWhereInput = {
    AND?: ZScanVerificationWhereInput | ZScanVerificationWhereInput[]
    OR?: ZScanVerificationWhereInput[]
    NOT?: ZScanVerificationWhereInput | ZScanVerificationWhereInput[]
    id?: IntFilter<"ZScanVerification"> | number
    userId?: IntNullableFilter<"ZScanVerification"> | number | null
    totalRules?: IntFilter<"ZScanVerification"> | number
    passed?: IntFilter<"ZScanVerification"> | number
    warnings?: IntFilter<"ZScanVerification"> | number
    critical?: IntFilter<"ZScanVerification"> | number
    results?: JsonFilter<"ZScanVerification">
    config?: JsonFilter<"ZScanVerification">
    createdAt?: DateTimeFilter<"ZScanVerification"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ZScanVerificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    totalRules?: SortOrder
    passed?: SortOrder
    warnings?: SortOrder
    critical?: SortOrder
    results?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ZScanVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ZScanVerificationWhereInput | ZScanVerificationWhereInput[]
    OR?: ZScanVerificationWhereInput[]
    NOT?: ZScanVerificationWhereInput | ZScanVerificationWhereInput[]
    userId?: IntNullableFilter<"ZScanVerification"> | number | null
    totalRules?: IntFilter<"ZScanVerification"> | number
    passed?: IntFilter<"ZScanVerification"> | number
    warnings?: IntFilter<"ZScanVerification"> | number
    critical?: IntFilter<"ZScanVerification"> | number
    results?: JsonFilter<"ZScanVerification">
    config?: JsonFilter<"ZScanVerification">
    createdAt?: DateTimeFilter<"ZScanVerification"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ZScanVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    totalRules?: SortOrder
    passed?: SortOrder
    warnings?: SortOrder
    critical?: SortOrder
    results?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    _count?: ZScanVerificationCountOrderByAggregateInput
    _avg?: ZScanVerificationAvgOrderByAggregateInput
    _max?: ZScanVerificationMaxOrderByAggregateInput
    _min?: ZScanVerificationMinOrderByAggregateInput
    _sum?: ZScanVerificationSumOrderByAggregateInput
  }

  export type ZScanVerificationScalarWhereWithAggregatesInput = {
    AND?: ZScanVerificationScalarWhereWithAggregatesInput | ZScanVerificationScalarWhereWithAggregatesInput[]
    OR?: ZScanVerificationScalarWhereWithAggregatesInput[]
    NOT?: ZScanVerificationScalarWhereWithAggregatesInput | ZScanVerificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ZScanVerification"> | number
    userId?: IntNullableWithAggregatesFilter<"ZScanVerification"> | number | null
    totalRules?: IntWithAggregatesFilter<"ZScanVerification"> | number
    passed?: IntWithAggregatesFilter<"ZScanVerification"> | number
    warnings?: IntWithAggregatesFilter<"ZScanVerification"> | number
    critical?: IntWithAggregatesFilter<"ZScanVerification"> | number
    results?: JsonWithAggregatesFilter<"ZScanVerification">
    config?: JsonWithAggregatesFilter<"ZScanVerification">
    createdAt?: DateTimeWithAggregatesFilter<"ZScanVerification"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrganizationCreateInput = {
    name: string
    plan?: $Enums.PlanType
    status?: $Enums.OrgStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    teams?: TeamCreateNestedManyWithoutOrganizationInput
    ssoConfigs?: SSOConfigurationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: number
    name: string
    plan?: $Enums.PlanType
    status?: $Enums.OrgStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    teams?: TeamUncheckedCreateNestedManyWithoutOrganizationInput
    ssoConfigs?: SSOConfigurationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    status?: EnumOrgStatusFieldUpdateOperationsInput | $Enums.OrgStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    teams?: TeamUpdateManyWithoutOrganizationNestedInput
    ssoConfigs?: SSOConfigurationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    status?: EnumOrgStatusFieldUpdateOperationsInput | $Enums.OrgStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    teams?: TeamUncheckedUpdateManyWithoutOrganizationNestedInput
    ssoConfigs?: SSOConfigurationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: number
    name: string
    plan?: $Enums.PlanType
    status?: $Enums.OrgStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    status?: EnumOrgStatusFieldUpdateOperationsInput | $Enums.OrgStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    status?: EnumOrgStatusFieldUpdateOperationsInput | $Enums.OrgStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: number
    name: string
    orgId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    orgId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: number
    name: string
    orgId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    orgId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateInput = {
    role?: $Enums.TeamRole
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutTeamsInput
  }

  export type TeamMemberUncheckedCreateInput = {
    id?: number
    teamId: number
    userId: number
    role?: $Enums.TeamRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUpdateInput = {
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutTeamsNestedInput
  }

  export type TeamMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyInput = {
    id?: number
    teamId: number
    userId: number
    role?: $Enums.TeamRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUpdateManyMutationInput = {
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedTestCollectionCreateInput = {
    name: string
    description?: string | null
    teamId: number
    createdBy: number
    isPublic?: boolean
    tags?: SharedTestCollectionCreatetagsInput | string[]
    testIds?: SharedTestCollectionCreatetestIdsInput | number[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SharedTestCollectionUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    teamId: number
    createdBy: number
    isPublic?: boolean
    tags?: SharedTestCollectionCreatetagsInput | string[]
    testIds?: SharedTestCollectionCreatetestIdsInput | number[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SharedTestCollectionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: SharedTestCollectionUpdatetagsInput | string[]
    testIds?: SharedTestCollectionUpdatetestIdsInput | number[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedTestCollectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: SharedTestCollectionUpdatetagsInput | string[]
    testIds?: SharedTestCollectionUpdatetestIdsInput | number[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedTestCollectionCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    teamId: number
    createdBy: number
    isPublic?: boolean
    tags?: SharedTestCollectionCreatetagsInput | string[]
    testIds?: SharedTestCollectionCreatetestIdsInput | number[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SharedTestCollectionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: SharedTestCollectionUpdatetagsInput | string[]
    testIds?: SharedTestCollectionUpdatetestIdsInput | number[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedTestCollectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: IntFieldUpdateOperationsInput | number
    createdBy?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: SharedTestCollectionUpdatetagsInput | string[]
    testIds?: SharedTestCollectionUpdatetestIdsInput | number[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateLimitQuotaCreateInput = {
    userId: number
    provider: string
    endpoint: string
    limit: number
    used?: number
    resetAt: Date | string
    windowMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RateLimitQuotaUncheckedCreateInput = {
    id?: number
    userId: number
    provider: string
    endpoint: string
    limit: number
    used?: number
    resetAt: Date | string
    windowMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RateLimitQuotaUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    limit?: IntFieldUpdateOperationsInput | number
    used?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    windowMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateLimitQuotaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    limit?: IntFieldUpdateOperationsInput | number
    used?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    windowMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateLimitQuotaCreateManyInput = {
    id?: number
    userId: number
    provider: string
    endpoint: string
    limit: number
    used?: number
    resetAt: Date | string
    windowMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RateLimitQuotaUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    limit?: IntFieldUpdateOperationsInput | number
    used?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    windowMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateLimitQuotaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    limit?: IntFieldUpdateOperationsInput | number
    used?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    windowMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestTemplateCreateInput = {
    name: string
    description?: string | null
    category: string
    userId: number
    teamId?: number | null
    isPublic?: boolean
    isPredefined?: boolean
    tags?: TestTemplateCreatetagsInput | string[]
    config: JsonNullValueInput | InputJsonValue
    sharedWith?: TestTemplateCreatesharedWithInput | number[]
    useCount?: number
    favoriteCount?: number
    version?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestTemplateUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    category: string
    userId: number
    teamId?: number | null
    isPublic?: boolean
    isPredefined?: boolean
    tags?: TestTemplateCreatetagsInput | string[]
    config: JsonNullValueInput | InputJsonValue
    sharedWith?: TestTemplateCreatesharedWithInput | number[]
    useCount?: number
    favoriteCount?: number
    version?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestTemplateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isPredefined?: BoolFieldUpdateOperationsInput | boolean
    tags?: TestTemplateUpdatetagsInput | string[]
    config?: JsonNullValueInput | InputJsonValue
    sharedWith?: TestTemplateUpdatesharedWithInput | number[]
    useCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    version?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestTemplateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isPredefined?: BoolFieldUpdateOperationsInput | boolean
    tags?: TestTemplateUpdatetagsInput | string[]
    config?: JsonNullValueInput | InputJsonValue
    sharedWith?: TestTemplateUpdatesharedWithInput | number[]
    useCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    version?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestTemplateCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    category: string
    userId: number
    teamId?: number | null
    isPublic?: boolean
    isPredefined?: boolean
    tags?: TestTemplateCreatetagsInput | string[]
    config: JsonNullValueInput | InputJsonValue
    sharedWith?: TestTemplateCreatesharedWithInput | number[]
    useCount?: number
    favoriteCount?: number
    version?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestTemplateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isPredefined?: BoolFieldUpdateOperationsInput | boolean
    tags?: TestTemplateUpdatetagsInput | string[]
    config?: JsonNullValueInput | InputJsonValue
    sharedWith?: TestTemplateUpdatesharedWithInput | number[]
    useCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    version?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestTemplateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isPredefined?: BoolFieldUpdateOperationsInput | boolean
    tags?: TestTemplateUpdatetagsInput | string[]
    config?: JsonNullValueInput | InputJsonValue
    sharedWith?: TestTemplateUpdatesharedWithInput | number[]
    useCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    version?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookCreateInput = {
    name: string
    description?: string | null
    userId: number
    teamId?: number | null
    url: string
    secret?: string | null
    events?: WebhookCreateeventsInput | string[]
    method?: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    payloadTemplate?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    retryEnabled?: boolean
    maxRetries?: number
    retryDelay?: number
    totalCalls?: number
    successCount?: number
    failureCount?: number
    lastTriggered?: Date | string | null
    lastSuccess?: Date | string | null
    lastFailure?: Date | string | null
    lastError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    userId: number
    teamId?: number | null
    url: string
    secret?: string | null
    events?: WebhookCreateeventsInput | string[]
    method?: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    payloadTemplate?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    retryEnabled?: boolean
    maxRetries?: number
    retryDelay?: number
    totalCalls?: number
    successCount?: number
    failureCount?: number
    lastTriggered?: Date | string | null
    lastSuccess?: Date | string | null
    lastFailure?: Date | string | null
    lastError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    events?: WebhookUpdateeventsInput | string[]
    method?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    payloadTemplate?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    retryEnabled?: BoolFieldUpdateOperationsInput | boolean
    maxRetries?: IntFieldUpdateOperationsInput | number
    retryDelay?: IntFieldUpdateOperationsInput | number
    totalCalls?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    events?: WebhookUpdateeventsInput | string[]
    method?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    payloadTemplate?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    retryEnabled?: BoolFieldUpdateOperationsInput | boolean
    maxRetries?: IntFieldUpdateOperationsInput | number
    retryDelay?: IntFieldUpdateOperationsInput | number
    totalCalls?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    userId: number
    teamId?: number | null
    url: string
    secret?: string | null
    events?: WebhookCreateeventsInput | string[]
    method?: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    payloadTemplate?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    retryEnabled?: boolean
    maxRetries?: number
    retryDelay?: number
    totalCalls?: number
    successCount?: number
    failureCount?: number
    lastTriggered?: Date | string | null
    lastSuccess?: Date | string | null
    lastFailure?: Date | string | null
    lastError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    events?: WebhookUpdateeventsInput | string[]
    method?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    payloadTemplate?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    retryEnabled?: BoolFieldUpdateOperationsInput | boolean
    maxRetries?: IntFieldUpdateOperationsInput | number
    retryDelay?: IntFieldUpdateOperationsInput | number
    totalCalls?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    events?: WebhookUpdateeventsInput | string[]
    method?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    payloadTemplate?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    retryEnabled?: BoolFieldUpdateOperationsInput | boolean
    maxRetries?: IntFieldUpdateOperationsInput | number
    retryDelay?: IntFieldUpdateOperationsInput | number
    totalCalls?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookLogCreateInput = {
    webhookId: number
    event: string
    payload: JsonNullValueInput | InputJsonValue
    url: string
    method: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    statusCode?: number | null
    responseBody?: string | null
    responseTime?: number | null
    attempt?: number
    success: boolean
    error?: string | null
    createdAt?: Date | string
  }

  export type WebhookLogUncheckedCreateInput = {
    id?: number
    webhookId: number
    event: string
    payload: JsonNullValueInput | InputJsonValue
    url: string
    method: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    statusCode?: number | null
    responseBody?: string | null
    responseTime?: number | null
    attempt?: number
    success: boolean
    error?: string | null
    createdAt?: Date | string
  }

  export type WebhookLogUpdateInput = {
    webhookId?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    url?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    attempt?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    webhookId?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    url?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    attempt?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookLogCreateManyInput = {
    id?: number
    webhookId: number
    event: string
    payload: JsonNullValueInput | InputJsonValue
    url: string
    method: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    statusCode?: number | null
    responseBody?: string | null
    responseTime?: number | null
    attempt?: number
    success: boolean
    error?: string | null
    createdAt?: Date | string
  }

  export type WebhookLogUpdateManyMutationInput = {
    webhookId?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    url?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    attempt?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    webhookId?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    url?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    attempt?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiRateLimitCreateInput = {
    userId: number
    provider: string
    limitType: string
    limitPeriod: string
    maxLimit: number
    currentUsage?: number
    resetAt: Date | string
    warningThreshold?: number
    lastWarningAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiRateLimitUncheckedCreateInput = {
    id?: number
    userId: number
    provider: string
    limitType: string
    limitPeriod: string
    maxLimit: number
    currentUsage?: number
    resetAt: Date | string
    warningThreshold?: number
    lastWarningAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiRateLimitUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    limitType?: StringFieldUpdateOperationsInput | string
    limitPeriod?: StringFieldUpdateOperationsInput | string
    maxLimit?: IntFieldUpdateOperationsInput | number
    currentUsage?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warningThreshold?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiRateLimitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    limitType?: StringFieldUpdateOperationsInput | string
    limitPeriod?: StringFieldUpdateOperationsInput | string
    maxLimit?: IntFieldUpdateOperationsInput | number
    currentUsage?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warningThreshold?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiRateLimitCreateManyInput = {
    id?: number
    userId: number
    provider: string
    limitType: string
    limitPeriod: string
    maxLimit: number
    currentUsage?: number
    resetAt: Date | string
    warningThreshold?: number
    lastWarningAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiRateLimitUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    limitType?: StringFieldUpdateOperationsInput | string
    limitPeriod?: StringFieldUpdateOperationsInput | string
    maxLimit?: IntFieldUpdateOperationsInput | number
    currentUsage?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warningThreshold?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiRateLimitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    limitType?: StringFieldUpdateOperationsInput | string
    limitPeriod?: StringFieldUpdateOperationsInput | string
    maxLimit?: IntFieldUpdateOperationsInput | number
    currentUsage?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warningThreshold?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: number
    userId: number
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type SessionUpdateInput = {
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: number
    userId: number
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditRecordCreateInput = {
    action: string
    category: $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AuditStatus
    lamport: number
    hashPointer?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditsInput
  }

  export type AuditRecordUncheckedCreateInput = {
    id?: number
    userId: number
    action: string
    category: $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AuditStatus
    lamport: number
    hashPointer?: string | null
    createdAt?: Date | string
  }

  export type AuditRecordUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    category?: EnumAuditCategoryFieldUpdateOperationsInput | $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    lamport?: IntFieldUpdateOperationsInput | number
    hashPointer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditsNestedInput
  }

  export type AuditRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    category?: EnumAuditCategoryFieldUpdateOperationsInput | $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    lamport?: IntFieldUpdateOperationsInput | number
    hashPointer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditRecordCreateManyInput = {
    id?: number
    userId: number
    action: string
    category: $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AuditStatus
    lamport: number
    hashPointer?: string | null
    createdAt?: Date | string
  }

  export type AuditRecordUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    category?: EnumAuditCategoryFieldUpdateOperationsInput | $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    lamport?: IntFieldUpdateOperationsInput | number
    hashPointer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    category?: EnumAuditCategoryFieldUpdateOperationsInput | $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    lamport?: IntFieldUpdateOperationsInput | number
    hashPointer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LamportStateCreateInput = {
    key: string
    value: string
    lamport: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    modified?: Date | string
  }

  export type LamportStateUncheckedCreateInput = {
    id?: number
    key: string
    value: string
    lamport: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    modified?: Date | string
  }

  export type LamportStateUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    lamport?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LamportStateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    lamport?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LamportStateCreateManyInput = {
    id?: number
    key: string
    value: string
    lamport: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    modified?: Date | string
  }

  export type LamportStateUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    lamport?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LamportStateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    lamport?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCreateInput = {
    limit: number
    period?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBudgetsInput
  }

  export type BudgetUncheckedCreateInput = {
    id?: number
    userId: number
    limit: number
    period?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetUpdateInput = {
    limit?: FloatFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBudgetsNestedInput
  }

  export type BudgetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    limit?: FloatFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCreateManyInput = {
    id?: number
    userId: number
    limit: number
    period?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetUpdateManyMutationInput = {
    limit?: FloatFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    limit?: FloatFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegressionBaselineCreateInput = {
    modelName: string
    modelVersion?: string | null
    testType: string
    avgResponseTime: number
    avgCost: number
    avgQualityScore: number
    avgAccuracy: number
    successRate: number
    alertThreshold?: number
    sampleSize: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRegressionBaselinesInput
  }

  export type RegressionBaselineUncheckedCreateInput = {
    id?: number
    userId: number
    modelName: string
    modelVersion?: string | null
    testType: string
    avgResponseTime: number
    avgCost: number
    avgQualityScore: number
    avgAccuracy: number
    successRate: number
    alertThreshold?: number
    sampleSize: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegressionBaselineUpdateInput = {
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: StringFieldUpdateOperationsInput | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    avgQualityScore?: FloatFieldUpdateOperationsInput | number
    avgAccuracy?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRegressionBaselinesNestedInput
  }

  export type RegressionBaselineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: StringFieldUpdateOperationsInput | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    avgQualityScore?: FloatFieldUpdateOperationsInput | number
    avgAccuracy?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegressionBaselineCreateManyInput = {
    id?: number
    userId: number
    modelName: string
    modelVersion?: string | null
    testType: string
    avgResponseTime: number
    avgCost: number
    avgQualityScore: number
    avgAccuracy: number
    successRate: number
    alertThreshold?: number
    sampleSize: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegressionBaselineUpdateManyMutationInput = {
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: StringFieldUpdateOperationsInput | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    avgQualityScore?: FloatFieldUpdateOperationsInput | number
    avgAccuracy?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegressionBaselineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: StringFieldUpdateOperationsInput | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    avgQualityScore?: FloatFieldUpdateOperationsInput | number
    avgAccuracy?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateInput = {
    type: $Enums.FeedbackType
    category: $Enums.FeedbackCategory
    priority?: $Enums.FeedbackPriority
    subject: string
    message: string
    url?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachmentUrls?: FeedbackCreateattachmentUrlsInput | string[]
    status?: $Enums.FeedbackStatus
    assignedTo?: number | null
    response?: string | null
    respondedAt?: Date | string | null
    respondedBy?: number | null
    sentiment?: string | null
    sentimentScore?: number | null
    upvotes?: number
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    user: UserCreateNestedOneWithoutFeedbacksInput
  }

  export type FeedbackUncheckedCreateInput = {
    id?: number
    userId: number
    type: $Enums.FeedbackType
    category: $Enums.FeedbackCategory
    priority?: $Enums.FeedbackPriority
    subject: string
    message: string
    url?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachmentUrls?: FeedbackCreateattachmentUrlsInput | string[]
    status?: $Enums.FeedbackStatus
    assignedTo?: number | null
    response?: string | null
    respondedAt?: Date | string | null
    respondedBy?: number | null
    sentiment?: string | null
    sentimentScore?: number | null
    upvotes?: number
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type FeedbackUpdateInput = {
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachmentUrls?: FeedbackUpdateattachmentUrlsInput | string[]
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type FeedbackUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachmentUrls?: FeedbackUpdateattachmentUrlsInput | string[]
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeedbackCreateManyInput = {
    id?: number
    userId: number
    type: $Enums.FeedbackType
    category: $Enums.FeedbackCategory
    priority?: $Enums.FeedbackPriority
    subject: string
    message: string
    url?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachmentUrls?: FeedbackCreateattachmentUrlsInput | string[]
    status?: $Enums.FeedbackStatus
    assignedTo?: number | null
    response?: string | null
    respondedAt?: Date | string | null
    respondedBy?: number | null
    sentiment?: string | null
    sentimentScore?: number | null
    upvotes?: number
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type FeedbackUpdateManyMutationInput = {
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachmentUrls?: FeedbackUpdateattachmentUrlsInput | string[]
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeedbackUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachmentUrls?: FeedbackUpdateattachmentUrlsInput | string[]
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IpWhitelistCreateInput = {
    userId?: number | null
    orgId?: number | null
    ipAddress: string
    description?: string | null
    isActive?: boolean
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type IpWhitelistUncheckedCreateInput = {
    id?: number
    userId?: number | null
    orgId?: number | null
    ipAddress: string
    description?: string | null
    isActive?: boolean
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type IpWhitelistUpdateInput = {
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IpWhitelistUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IpWhitelistCreateManyInput = {
    id?: number
    userId?: number | null
    orgId?: number | null
    ipAddress: string
    description?: string | null
    isActive?: boolean
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type IpWhitelistUpdateManyMutationInput = {
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IpWhitelistUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityEventCreateInput = {
    userId?: number | null
    eventType: $Enums.SecurityEventType
    severity?: $Enums.SecuritySeverity
    ipAddress?: string | null
    userAgent?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedBy?: number | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SecurityEventUncheckedCreateInput = {
    id?: number
    userId?: number | null
    eventType: $Enums.SecurityEventType
    severity?: $Enums.SecuritySeverity
    ipAddress?: string | null
    userAgent?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedBy?: number | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SecurityEventUpdateInput = {
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumSecurityEventTypeFieldUpdateOperationsInput | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFieldUpdateOperationsInput | $Enums.SecuritySeverity
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumSecurityEventTypeFieldUpdateOperationsInput | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFieldUpdateOperationsInput | $Enums.SecuritySeverity
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventCreateManyInput = {
    id?: number
    userId?: number | null
    eventType: $Enums.SecurityEventType
    severity?: $Enums.SecuritySeverity
    ipAddress?: string | null
    userAgent?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: boolean
    resolvedBy?: number | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SecurityEventUpdateManyMutationInput = {
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumSecurityEventTypeFieldUpdateOperationsInput | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFieldUpdateOperationsInput | $Enums.SecuritySeverity
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: EnumSecurityEventTypeFieldUpdateOperationsInput | $Enums.SecurityEventType
    severity?: EnumSecuritySeverityFieldUpdateOperationsInput | $Enums.SecuritySeverity
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorBackupCreateInput = {
    userId: number
    code: string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TwoFactorBackupUncheckedCreateInput = {
    id?: number
    userId: number
    code: string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TwoFactorBackupUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorBackupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorBackupCreateManyInput = {
    id?: number
    userId: number
    code: string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TwoFactorBackupUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorBackupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SSOConfigurationCreateInput = {
    provider: $Enums.SSOProvider
    enabled?: boolean
    samlEntryPoint?: string | null
    samlIssuer?: string | null
    samlCert?: string | null
    samlCallbackUrl?: string | null
    samlLogoutUrl?: string | null
    oauthClientId?: string | null
    oauthClientSecret?: string | null
    oauthAuthUrl?: string | null
    oauthTokenUrl?: string | null
    oauthUserInfoUrl?: string | null
    oauthScopes?: SSOConfigurationCreateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationCreatedomainRestrictionInput | string[]
    jitProvisioning?: boolean
    defaultRole?: $Enums.Role
    defaultTier?: $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
    organization: OrganizationCreateNestedOneWithoutSsoConfigsInput
  }

  export type SSOConfigurationUncheckedCreateInput = {
    id?: number
    orgId: number
    provider: $Enums.SSOProvider
    enabled?: boolean
    samlEntryPoint?: string | null
    samlIssuer?: string | null
    samlCert?: string | null
    samlCallbackUrl?: string | null
    samlLogoutUrl?: string | null
    oauthClientId?: string | null
    oauthClientSecret?: string | null
    oauthAuthUrl?: string | null
    oauthTokenUrl?: string | null
    oauthUserInfoUrl?: string | null
    oauthScopes?: SSOConfigurationCreateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationCreatedomainRestrictionInput | string[]
    jitProvisioning?: boolean
    defaultRole?: $Enums.Role
    defaultTier?: $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type SSOConfigurationUpdateInput = {
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    enabled?: BoolFieldUpdateOperationsInput | boolean
    samlEntryPoint?: NullableStringFieldUpdateOperationsInput | string | null
    samlIssuer?: NullableStringFieldUpdateOperationsInput | string | null
    samlCert?: NullableStringFieldUpdateOperationsInput | string | null
    samlCallbackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    samlLogoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthAuthUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthUserInfoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthScopes?: SSOConfigurationUpdateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationUpdatedomainRestrictionInput | string[]
    jitProvisioning?: BoolFieldUpdateOperationsInput | boolean
    defaultRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    defaultTier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: OrganizationUpdateOneRequiredWithoutSsoConfigsNestedInput
  }

  export type SSOConfigurationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orgId?: IntFieldUpdateOperationsInput | number
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    enabled?: BoolFieldUpdateOperationsInput | boolean
    samlEntryPoint?: NullableStringFieldUpdateOperationsInput | string | null
    samlIssuer?: NullableStringFieldUpdateOperationsInput | string | null
    samlCert?: NullableStringFieldUpdateOperationsInput | string | null
    samlCallbackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    samlLogoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthAuthUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthUserInfoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthScopes?: SSOConfigurationUpdateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationUpdatedomainRestrictionInput | string[]
    jitProvisioning?: BoolFieldUpdateOperationsInput | boolean
    defaultRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    defaultTier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SSOConfigurationCreateManyInput = {
    id?: number
    orgId: number
    provider: $Enums.SSOProvider
    enabled?: boolean
    samlEntryPoint?: string | null
    samlIssuer?: string | null
    samlCert?: string | null
    samlCallbackUrl?: string | null
    samlLogoutUrl?: string | null
    oauthClientId?: string | null
    oauthClientSecret?: string | null
    oauthAuthUrl?: string | null
    oauthTokenUrl?: string | null
    oauthUserInfoUrl?: string | null
    oauthScopes?: SSOConfigurationCreateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationCreatedomainRestrictionInput | string[]
    jitProvisioning?: boolean
    defaultRole?: $Enums.Role
    defaultTier?: $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type SSOConfigurationUpdateManyMutationInput = {
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    enabled?: BoolFieldUpdateOperationsInput | boolean
    samlEntryPoint?: NullableStringFieldUpdateOperationsInput | string | null
    samlIssuer?: NullableStringFieldUpdateOperationsInput | string | null
    samlCert?: NullableStringFieldUpdateOperationsInput | string | null
    samlCallbackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    samlLogoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthAuthUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthUserInfoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthScopes?: SSOConfigurationUpdateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationUpdatedomainRestrictionInput | string[]
    jitProvisioning?: BoolFieldUpdateOperationsInput | boolean
    defaultRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    defaultTier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SSOConfigurationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orgId?: IntFieldUpdateOperationsInput | number
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    enabled?: BoolFieldUpdateOperationsInput | boolean
    samlEntryPoint?: NullableStringFieldUpdateOperationsInput | string | null
    samlIssuer?: NullableStringFieldUpdateOperationsInput | string | null
    samlCert?: NullableStringFieldUpdateOperationsInput | string | null
    samlCallbackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    samlLogoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthAuthUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthUserInfoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthScopes?: SSOConfigurationUpdateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationUpdatedomainRestrictionInput | string[]
    jitProvisioning?: BoolFieldUpdateOperationsInput | boolean
    defaultRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    defaultTier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SSOSessionCreateInput = {
    userId: number
    provider: $Enums.SSOProvider
    sessionId: string
    nameId?: string | null
    sessionIndex?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    lastActivityAt?: Date | string
  }

  export type SSOSessionUncheckedCreateInput = {
    id?: number
    userId: number
    provider: $Enums.SSOProvider
    sessionId: string
    nameId?: string | null
    sessionIndex?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    lastActivityAt?: Date | string
  }

  export type SSOSessionUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    sessionId?: StringFieldUpdateOperationsInput | string
    nameId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SSOSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    sessionId?: StringFieldUpdateOperationsInput | string
    nameId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SSOSessionCreateManyInput = {
    id?: number
    userId: number
    provider: $Enums.SSOProvider
    sessionId: string
    nameId?: string | null
    sessionIndex?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    lastActivityAt?: Date | string
  }

  export type SSOSessionUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    sessionId?: StringFieldUpdateOperationsInput | string
    nameId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SSOSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    sessionId?: StringFieldUpdateOperationsInput | string
    nameId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SSOAuditLogCreateInput = {
    orgId?: number | null
    userId?: number | null
    provider: $Enums.SSOProvider
    eventType: $Enums.SSOEventType
    success: boolean
    ipAddress?: string | null
    userAgent?: string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SSOAuditLogUncheckedCreateInput = {
    id?: number
    orgId?: number | null
    userId?: number | null
    provider: $Enums.SSOProvider
    eventType: $Enums.SSOEventType
    success: boolean
    ipAddress?: string | null
    userAgent?: string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SSOAuditLogUpdateInput = {
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    eventType?: EnumSSOEventTypeFieldUpdateOperationsInput | $Enums.SSOEventType
    success?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SSOAuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    eventType?: EnumSSOEventTypeFieldUpdateOperationsInput | $Enums.SSOEventType
    success?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SSOAuditLogCreateManyInput = {
    id?: number
    orgId?: number | null
    userId?: number | null
    provider: $Enums.SSOProvider
    eventType: $Enums.SSOEventType
    success: boolean
    ipAddress?: string | null
    userAgent?: string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SSOAuditLogUpdateManyMutationInput = {
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    eventType?: EnumSSOEventTypeFieldUpdateOperationsInput | $Enums.SSOEventType
    success?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SSOAuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    eventType?: EnumSSOEventTypeFieldUpdateOperationsInput | $Enums.SSOEventType
    success?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateInput = {
    emailEnabled?: boolean
    testComplete?: boolean
    batchComplete?: boolean
    scheduledTestComplete?: boolean
    alertsEnabled?: boolean
    lowScoreThreshold?: number
    highScoreThreshold?: number
    scoreDropAlert?: boolean
    witnessFailureAlert?: boolean
    dailyReport?: boolean
    weeklyReport?: boolean
    monthlyReport?: boolean
    reportTime?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationPreferenceUncheckedCreateInput = {
    id?: number
    userId: number
    emailEnabled?: boolean
    testComplete?: boolean
    batchComplete?: boolean
    scheduledTestComplete?: boolean
    alertsEnabled?: boolean
    lowScoreThreshold?: number
    highScoreThreshold?: number
    scoreDropAlert?: boolean
    witnessFailureAlert?: boolean
    dailyReport?: boolean
    weeklyReport?: boolean
    monthlyReport?: boolean
    reportTime?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateInput = {
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    testComplete?: BoolFieldUpdateOperationsInput | boolean
    batchComplete?: BoolFieldUpdateOperationsInput | boolean
    scheduledTestComplete?: BoolFieldUpdateOperationsInput | boolean
    alertsEnabled?: BoolFieldUpdateOperationsInput | boolean
    lowScoreThreshold?: FloatFieldUpdateOperationsInput | number
    highScoreThreshold?: FloatFieldUpdateOperationsInput | number
    scoreDropAlert?: BoolFieldUpdateOperationsInput | boolean
    witnessFailureAlert?: BoolFieldUpdateOperationsInput | boolean
    dailyReport?: BoolFieldUpdateOperationsInput | boolean
    weeklyReport?: BoolFieldUpdateOperationsInput | boolean
    monthlyReport?: BoolFieldUpdateOperationsInput | boolean
    reportTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationPreferenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    testComplete?: BoolFieldUpdateOperationsInput | boolean
    batchComplete?: BoolFieldUpdateOperationsInput | boolean
    scheduledTestComplete?: BoolFieldUpdateOperationsInput | boolean
    alertsEnabled?: BoolFieldUpdateOperationsInput | boolean
    lowScoreThreshold?: FloatFieldUpdateOperationsInput | number
    highScoreThreshold?: FloatFieldUpdateOperationsInput | number
    scoreDropAlert?: BoolFieldUpdateOperationsInput | boolean
    witnessFailureAlert?: BoolFieldUpdateOperationsInput | boolean
    dailyReport?: BoolFieldUpdateOperationsInput | boolean
    weeklyReport?: BoolFieldUpdateOperationsInput | boolean
    monthlyReport?: BoolFieldUpdateOperationsInput | boolean
    reportTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateManyInput = {
    id?: number
    userId: number
    emailEnabled?: boolean
    testComplete?: boolean
    batchComplete?: boolean
    scheduledTestComplete?: boolean
    alertsEnabled?: boolean
    lowScoreThreshold?: number
    highScoreThreshold?: number
    scoreDropAlert?: boolean
    witnessFailureAlert?: boolean
    dailyReport?: boolean
    weeklyReport?: boolean
    monthlyReport?: boolean
    reportTime?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateManyMutationInput = {
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    testComplete?: BoolFieldUpdateOperationsInput | boolean
    batchComplete?: BoolFieldUpdateOperationsInput | boolean
    scheduledTestComplete?: BoolFieldUpdateOperationsInput | boolean
    alertsEnabled?: BoolFieldUpdateOperationsInput | boolean
    lowScoreThreshold?: FloatFieldUpdateOperationsInput | number
    highScoreThreshold?: FloatFieldUpdateOperationsInput | number
    scoreDropAlert?: BoolFieldUpdateOperationsInput | boolean
    witnessFailureAlert?: BoolFieldUpdateOperationsInput | boolean
    dailyReport?: BoolFieldUpdateOperationsInput | boolean
    weeklyReport?: BoolFieldUpdateOperationsInput | boolean
    monthlyReport?: BoolFieldUpdateOperationsInput | boolean
    reportTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    testComplete?: BoolFieldUpdateOperationsInput | boolean
    batchComplete?: BoolFieldUpdateOperationsInput | boolean
    scheduledTestComplete?: BoolFieldUpdateOperationsInput | boolean
    alertsEnabled?: BoolFieldUpdateOperationsInput | boolean
    lowScoreThreshold?: FloatFieldUpdateOperationsInput | number
    highScoreThreshold?: FloatFieldUpdateOperationsInput | number
    scoreDropAlert?: BoolFieldUpdateOperationsInput | boolean
    witnessFailureAlert?: BoolFieldUpdateOperationsInput | boolean
    dailyReport?: BoolFieldUpdateOperationsInput | boolean
    weeklyReport?: BoolFieldUpdateOperationsInput | boolean
    monthlyReport?: BoolFieldUpdateOperationsInput | boolean
    reportTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestResultCreateInput = {
    userId: number
    modelName: string
    modelProvider: string
    prompt: string
    response?: string | null
    criesScore?: number | null
    responseTime?: number | null
    tokenCount?: number | null
    cost?: number | null
    status: string
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TestResultUncheckedCreateInput = {
    id?: number
    userId: number
    modelName: string
    modelProvider: string
    prompt: string
    response?: string | null
    criesScore?: number | null
    responseTime?: number | null
    tokenCount?: number | null
    cost?: number | null
    status: string
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TestResultUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelProvider?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    criesScore?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    tokenCount?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestResultUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelProvider?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    criesScore?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    tokenCount?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestResultCreateManyInput = {
    id?: number
    userId: number
    modelName: string
    modelProvider: string
    prompt: string
    response?: string | null
    criesScore?: number | null
    responseTime?: number | null
    tokenCount?: number | null
    cost?: number | null
    status: string
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TestResultUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelProvider?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    criesScore?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    tokenCount?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestResultUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelProvider?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    criesScore?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    tokenCount?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LamportCounterCreateInput = {
    id?: number
    currentValue?: number
    lastUpdated?: Date | string
    lastReceiptId?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LamportCounterUncheckedCreateInput = {
    id?: number
    currentValue?: number
    lastUpdated?: Date | string
    lastReceiptId?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LamportCounterUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    currentValue?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LamportCounterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    currentValue?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LamportCounterCreateManyInput = {
    id?: number
    currentValue?: number
    lastUpdated?: Date | string
    lastReceiptId?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LamportCounterUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    currentValue?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LamportCounterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    currentValue?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BENReceiptCreateInput = {
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp?: Date | string
    persona?: $Enums.BENPersona
    track?: $Enums.TrackType | null
    payload: JsonNullValueInput | InputJsonValue
    digest: string
    previousDigest?: string | null
    baselineDigest?: string | null
    witnessModel?: string | null
    witnessSignature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutBenReceiptsInput
    handoffsFrom?: TriTrackHandoffCreateNestedManyWithoutFromReceiptInput
    handoffsTo?: TriTrackHandoffCreateNestedManyWithoutToReceiptInput
  }

  export type BENReceiptUncheckedCreateInput = {
    id?: number
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp?: Date | string
    userId?: number | null
    persona?: $Enums.BENPersona
    track?: $Enums.TrackType | null
    payload: JsonNullValueInput | InputJsonValue
    digest: string
    previousDigest?: string | null
    baselineDigest?: string | null
    witnessModel?: string | null
    witnessSignature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    handoffsFrom?: TriTrackHandoffUncheckedCreateNestedManyWithoutFromReceiptInput
    handoffsTo?: TriTrackHandoffUncheckedCreateNestedManyWithoutToReceiptInput
  }

  export type BENReceiptUpdateInput = {
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutBenReceiptsNestedInput
    handoffsFrom?: TriTrackHandoffUpdateManyWithoutFromReceiptNestedInput
    handoffsTo?: TriTrackHandoffUpdateManyWithoutToReceiptNestedInput
  }

  export type BENReceiptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handoffsFrom?: TriTrackHandoffUncheckedUpdateManyWithoutFromReceiptNestedInput
    handoffsTo?: TriTrackHandoffUncheckedUpdateManyWithoutToReceiptNestedInput
  }

  export type BENReceiptCreateManyInput = {
    id?: number
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp?: Date | string
    userId?: number | null
    persona?: $Enums.BENPersona
    track?: $Enums.TrackType | null
    payload: JsonNullValueInput | InputJsonValue
    digest: string
    previousDigest?: string | null
    baselineDigest?: string | null
    witnessModel?: string | null
    witnessSignature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BENReceiptUpdateManyMutationInput = {
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BENReceiptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BENSessionCreateInput = {
    persona: $Enums.BENPersona
    priority: number
    locked?: boolean
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    startLamport: number
    endLamport?: number | null
    switchReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutBenSessionsInput
  }

  export type BENSessionUncheckedCreateInput = {
    id?: number
    userId: number
    persona: $Enums.BENPersona
    priority: number
    locked?: boolean
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    startLamport: number
    endLamport?: number | null
    switchReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BENSessionUpdateInput = {
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    priority?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startLamport?: IntFieldUpdateOperationsInput | number
    endLamport?: NullableIntFieldUpdateOperationsInput | number | null
    switchReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutBenSessionsNestedInput
  }

  export type BENSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    priority?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startLamport?: IntFieldUpdateOperationsInput | number
    endLamport?: NullableIntFieldUpdateOperationsInput | number | null
    switchReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BENSessionCreateManyInput = {
    id?: number
    userId: number
    persona: $Enums.BENPersona
    priority: number
    locked?: boolean
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    startLamport: number
    endLamport?: number | null
    switchReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BENSessionUpdateManyMutationInput = {
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    priority?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startLamport?: IntFieldUpdateOperationsInput | number
    endLamport?: NullableIntFieldUpdateOperationsInput | number | null
    switchReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BENSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    priority?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startLamport?: IntFieldUpdateOperationsInput | number
    endLamport?: NullableIntFieldUpdateOperationsInput | number | null
    switchReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffCreateInput = {
    fromTrack: $Enums.TrackType
    toTrack: $Enums.TrackType
    status?: $Enums.HandoffStatus
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    latencyMs?: number | null
    exceededLimit?: boolean
    payload: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    fromReceipt: BENReceiptCreateNestedOneWithoutHandoffsFromInput
    toReceipt?: BENReceiptCreateNestedOneWithoutHandoffsToInput
  }

  export type TriTrackHandoffUncheckedCreateInput = {
    id?: number
    fromTrack: $Enums.TrackType
    toTrack: $Enums.TrackType
    status?: $Enums.HandoffStatus
    fromReceiptId: number
    toReceiptId?: number | null
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    latencyMs?: number | null
    exceededLimit?: boolean
    payload: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffUpdateInput = {
    fromTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    toTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    status?: EnumHandoffStatusFieldUpdateOperationsInput | $Enums.HandoffStatus
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    exceededLimit?: BoolFieldUpdateOperationsInput | boolean
    payload?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    fromReceipt?: BENReceiptUpdateOneRequiredWithoutHandoffsFromNestedInput
    toReceipt?: BENReceiptUpdateOneWithoutHandoffsToNestedInput
  }

  export type TriTrackHandoffUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    toTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    status?: EnumHandoffStatusFieldUpdateOperationsInput | $Enums.HandoffStatus
    fromReceiptId?: IntFieldUpdateOperationsInput | number
    toReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    exceededLimit?: BoolFieldUpdateOperationsInput | boolean
    payload?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffCreateManyInput = {
    id?: number
    fromTrack: $Enums.TrackType
    toTrack: $Enums.TrackType
    status?: $Enums.HandoffStatus
    fromReceiptId: number
    toReceiptId?: number | null
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    latencyMs?: number | null
    exceededLimit?: boolean
    payload: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffUpdateManyMutationInput = {
    fromTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    toTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    status?: EnumHandoffStatusFieldUpdateOperationsInput | $Enums.HandoffStatus
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    exceededLimit?: BoolFieldUpdateOperationsInput | boolean
    payload?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    toTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    status?: EnumHandoffStatusFieldUpdateOperationsInput | $Enums.HandoffStatus
    fromReceiptId?: IntFieldUpdateOperationsInput | number
    toReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    exceededLimit?: BoolFieldUpdateOperationsInput | boolean
    payload?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WitnessSignatureCreateInput = {
    modelName: string
    modelFingerprint: string
    receiptId?: number | null
    receiptDigest: string
    signature: string
    signedAt?: Date | string
    lamportClock: number
    verified?: boolean
    verifiedAt?: Date | string | null
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WitnessSignatureUncheckedCreateInput = {
    id?: number
    modelName: string
    modelFingerprint: string
    receiptId?: number | null
    receiptDigest: string
    signature: string
    signedAt?: Date | string
    lamportClock: number
    verified?: boolean
    verifiedAt?: Date | string | null
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WitnessSignatureUpdateInput = {
    modelName?: StringFieldUpdateOperationsInput | string
    modelFingerprint?: StringFieldUpdateOperationsInput | string
    receiptId?: NullableIntFieldUpdateOperationsInput | number | null
    receiptDigest?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lamportClock?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WitnessSignatureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelFingerprint?: StringFieldUpdateOperationsInput | string
    receiptId?: NullableIntFieldUpdateOperationsInput | number | null
    receiptDigest?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lamportClock?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WitnessSignatureCreateManyInput = {
    id?: number
    modelName: string
    modelFingerprint: string
    receiptId?: number | null
    receiptDigest: string
    signature: string
    signedAt?: Date | string
    lamportClock: number
    verified?: boolean
    verifiedAt?: Date | string | null
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WitnessSignatureUpdateManyMutationInput = {
    modelName?: StringFieldUpdateOperationsInput | string
    modelFingerprint?: StringFieldUpdateOperationsInput | string
    receiptId?: NullableIntFieldUpdateOperationsInput | number | null
    receiptDigest?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lamportClock?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WitnessSignatureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelFingerprint?: StringFieldUpdateOperationsInput | string
    receiptId?: NullableIntFieldUpdateOperationsInput | number | null
    receiptDigest?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lamportClock?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CRIESComputationCreateInput = {
    testResultId?: number | null
    userId?: number | null
    sigmaWindow: number
    tauThreshold: number
    piPolicy: number
    citationQuality: number
    criesScore: number
    lamportClock: number
    computedAt?: Date | string
    receiptId?: number | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CRIESComputationUncheckedCreateInput = {
    id?: number
    testResultId?: number | null
    userId?: number | null
    sigmaWindow: number
    tauThreshold: number
    piPolicy: number
    citationQuality: number
    criesScore: number
    lamportClock: number
    computedAt?: Date | string
    receiptId?: number | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CRIESComputationUpdateInput = {
    testResultId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    sigmaWindow?: FloatFieldUpdateOperationsInput | number
    tauThreshold?: FloatFieldUpdateOperationsInput | number
    piPolicy?: FloatFieldUpdateOperationsInput | number
    citationQuality?: FloatFieldUpdateOperationsInput | number
    criesScore?: FloatFieldUpdateOperationsInput | number
    lamportClock?: IntFieldUpdateOperationsInput | number
    computedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptId?: NullableIntFieldUpdateOperationsInput | number | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CRIESComputationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    testResultId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    sigmaWindow?: FloatFieldUpdateOperationsInput | number
    tauThreshold?: FloatFieldUpdateOperationsInput | number
    piPolicy?: FloatFieldUpdateOperationsInput | number
    citationQuality?: FloatFieldUpdateOperationsInput | number
    criesScore?: FloatFieldUpdateOperationsInput | number
    lamportClock?: IntFieldUpdateOperationsInput | number
    computedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptId?: NullableIntFieldUpdateOperationsInput | number | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CRIESComputationCreateManyInput = {
    id?: number
    testResultId?: number | null
    userId?: number | null
    sigmaWindow: number
    tauThreshold: number
    piPolicy: number
    citationQuality: number
    criesScore: number
    lamportClock: number
    computedAt?: Date | string
    receiptId?: number | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CRIESComputationUpdateManyMutationInput = {
    testResultId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    sigmaWindow?: FloatFieldUpdateOperationsInput | number
    tauThreshold?: FloatFieldUpdateOperationsInput | number
    piPolicy?: FloatFieldUpdateOperationsInput | number
    citationQuality?: FloatFieldUpdateOperationsInput | number
    criesScore?: FloatFieldUpdateOperationsInput | number
    lamportClock?: IntFieldUpdateOperationsInput | number
    computedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptId?: NullableIntFieldUpdateOperationsInput | number | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CRIESComputationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    testResultId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    sigmaWindow?: FloatFieldUpdateOperationsInput | number
    tauThreshold?: FloatFieldUpdateOperationsInput | number
    piPolicy?: FloatFieldUpdateOperationsInput | number
    citationQuality?: FloatFieldUpdateOperationsInput | number
    criesScore?: FloatFieldUpdateOperationsInput | number
    lamportClock?: IntFieldUpdateOperationsInput | number
    computedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptId?: NullableIntFieldUpdateOperationsInput | number | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ZScanVerificationCreateInput = {
    totalRules: number
    passed: number
    warnings: number
    critical: number
    results: JsonNullValueInput | InputJsonValue
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutZscansInput
  }

  export type ZScanVerificationUncheckedCreateInput = {
    id?: number
    userId?: number | null
    totalRules: number
    passed: number
    warnings: number
    critical: number
    results: JsonNullValueInput | InputJsonValue
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ZScanVerificationUpdateInput = {
    totalRules?: IntFieldUpdateOperationsInput | number
    passed?: IntFieldUpdateOperationsInput | number
    warnings?: IntFieldUpdateOperationsInput | number
    critical?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutZscansNestedInput
  }

  export type ZScanVerificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    totalRules?: IntFieldUpdateOperationsInput | number
    passed?: IntFieldUpdateOperationsInput | number
    warnings?: IntFieldUpdateOperationsInput | number
    critical?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZScanVerificationCreateManyInput = {
    id?: number
    userId?: number | null
    totalRules: number
    passed: number
    warnings: number
    critical: number
    results: JsonNullValueInput | InputJsonValue
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ZScanVerificationUpdateManyMutationInput = {
    totalRules?: IntFieldUpdateOperationsInput | number
    passed?: IntFieldUpdateOperationsInput | number
    warnings?: IntFieldUpdateOperationsInput | number
    critical?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZScanVerificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    totalRules?: IntFieldUpdateOperationsInput | number
    passed?: IntFieldUpdateOperationsInput | number
    warnings?: IntFieldUpdateOperationsInput | number
    critical?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EnumUserTierFilter<$PrismaModel = never> = {
    equals?: $Enums.UserTier | EnumUserTierFieldRefInput<$PrismaModel>
    in?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTierFilter<$PrismaModel> | $Enums.UserTier
  }

  export type EnumPermissionNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel> | null
    has?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumBENPersonaFilter<$PrismaModel = never> = {
    equals?: $Enums.BENPersona | EnumBENPersonaFieldRefInput<$PrismaModel>
    in?: $Enums.BENPersona[] | ListEnumBENPersonaFieldRefInput<$PrismaModel>
    notIn?: $Enums.BENPersona[] | ListEnumBENPersonaFieldRefInput<$PrismaModel>
    not?: NestedEnumBENPersonaFilter<$PrismaModel> | $Enums.BENPersona
  }

  export type OrganizationNullableScalarRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AuditRecordListRelationFilter = {
    every?: AuditRecordWhereInput
    some?: AuditRecordWhereInput
    none?: AuditRecordWhereInput
  }

  export type TeamMemberListRelationFilter = {
    every?: TeamMemberWhereInput
    some?: TeamMemberWhereInput
    none?: TeamMemberWhereInput
  }

  export type NotificationPreferenceNullableScalarRelationFilter = {
    is?: NotificationPreferenceWhereInput | null
    isNot?: NotificationPreferenceWhereInput | null
  }

  export type BudgetListRelationFilter = {
    every?: BudgetWhereInput
    some?: BudgetWhereInput
    none?: BudgetWhereInput
  }

  export type RegressionBaselineListRelationFilter = {
    every?: RegressionBaselineWhereInput
    some?: RegressionBaselineWhereInput
    none?: RegressionBaselineWhereInput
  }

  export type FeedbackListRelationFilter = {
    every?: FeedbackWhereInput
    some?: FeedbackWhereInput
    none?: FeedbackWhereInput
  }

  export type BENReceiptListRelationFilter = {
    every?: BENReceiptWhereInput
    some?: BENReceiptWhereInput
    none?: BENReceiptWhereInput
  }

  export type BENSessionListRelationFilter = {
    every?: BENSessionWhereInput
    some?: BENSessionWhereInput
    none?: BENSessionWhereInput
  }

  export type ZScanVerificationListRelationFilter = {
    every?: ZScanVerificationWhereInput
    some?: ZScanVerificationWhereInput
    none?: ZScanVerificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BudgetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegressionBaselineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BENReceiptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BENSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZScanVerificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    tier?: SortOrder
    permissions?: SortOrder
    orgId?: SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    backupCodes?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    passwordChangedAt?: SortOrder
    ssoProvider?: SortOrder
    ssoId?: SortOrder
    ssoMetadata?: SortOrder
    currentPersona?: SortOrder
    personaLocked?: SortOrder
    lamportCounter?: SortOrder
    lastReceiptId?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    failedLoginAttempts?: SortOrder
    lamportCounter?: SortOrder
    lastReceiptId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    tier?: SortOrder
    orgId?: SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    passwordChangedAt?: SortOrder
    ssoProvider?: SortOrder
    ssoId?: SortOrder
    currentPersona?: SortOrder
    personaLocked?: SortOrder
    lamportCounter?: SortOrder
    lastReceiptId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    tier?: SortOrder
    orgId?: SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    passwordChangedAt?: SortOrder
    ssoProvider?: SortOrder
    ssoId?: SortOrder
    currentPersona?: SortOrder
    personaLocked?: SortOrder
    lamportCounter?: SortOrder
    lastReceiptId?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    failedLoginAttempts?: SortOrder
    lamportCounter?: SortOrder
    lastReceiptId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumUserTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserTier | EnumUserTierFieldRefInput<$PrismaModel>
    in?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTierWithAggregatesFilter<$PrismaModel> | $Enums.UserTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTierFilter<$PrismaModel>
    _max?: NestedEnumUserTierFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumBENPersonaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BENPersona | EnumBENPersonaFieldRefInput<$PrismaModel>
    in?: $Enums.BENPersona[] | ListEnumBENPersonaFieldRefInput<$PrismaModel>
    notIn?: $Enums.BENPersona[] | ListEnumBENPersonaFieldRefInput<$PrismaModel>
    not?: NestedEnumBENPersonaWithAggregatesFilter<$PrismaModel> | $Enums.BENPersona
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBENPersonaFilter<$PrismaModel>
    _max?: NestedEnumBENPersonaFilter<$PrismaModel>
  }

  export type EnumPlanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeFilter<$PrismaModel> | $Enums.PlanType
  }

  export type EnumOrgStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgStatus | EnumOrgStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrgStatus[] | ListEnumOrgStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgStatus[] | ListEnumOrgStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgStatusFilter<$PrismaModel> | $Enums.OrgStatus
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type SSOConfigurationListRelationFilter = {
    every?: SSOConfigurationWhereInput
    some?: SSOConfigurationWhereInput
    none?: SSOConfigurationWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SSOConfigurationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumPlanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTypeFilter<$PrismaModel>
    _max?: NestedEnumPlanTypeFilter<$PrismaModel>
  }

  export type EnumOrgStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgStatus | EnumOrgStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrgStatus[] | ListEnumOrgStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgStatus[] | ListEnumOrgStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrgStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrgStatusFilter<$PrismaModel>
    _max?: NestedEnumOrgStatusFilter<$PrismaModel>
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamAvgOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamSumOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
  }

  export type EnumTeamRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleFilter<$PrismaModel> | $Enums.TeamRole
  }

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TeamMemberTeamIdUserIdCompoundUniqueInput = {
    teamId: number
    userId: number
  }

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type EnumTeamRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel> | $Enums.TeamRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamRoleFilter<$PrismaModel>
    _max?: NestedEnumTeamRoleFilter<$PrismaModel>
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type SharedTestCollectionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    teamId?: SortOrder
    createdBy?: SortOrder
    isPublic?: SortOrder
    tags?: SortOrder
    testIds?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SharedTestCollectionAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    createdBy?: SortOrder
    testIds?: SortOrder
  }

  export type SharedTestCollectionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    teamId?: SortOrder
    createdBy?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SharedTestCollectionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    teamId?: SortOrder
    createdBy?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SharedTestCollectionSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    createdBy?: SortOrder
    testIds?: SortOrder
  }

  export type RateLimitQuotaUserIdProviderEndpointCompoundUniqueInput = {
    userId: number
    provider: string
    endpoint: string
  }

  export type RateLimitQuotaCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    endpoint?: SortOrder
    limit?: SortOrder
    used?: SortOrder
    resetAt?: SortOrder
    windowMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RateLimitQuotaAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    limit?: SortOrder
    used?: SortOrder
    windowMinutes?: SortOrder
  }

  export type RateLimitQuotaMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    endpoint?: SortOrder
    limit?: SortOrder
    used?: SortOrder
    resetAt?: SortOrder
    windowMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RateLimitQuotaMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    endpoint?: SortOrder
    limit?: SortOrder
    used?: SortOrder
    resetAt?: SortOrder
    windowMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RateLimitQuotaSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    limit?: SortOrder
    used?: SortOrder
    windowMinutes?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TestTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    isPublic?: SortOrder
    isPredefined?: SortOrder
    tags?: SortOrder
    config?: SortOrder
    sharedWith?: SortOrder
    useCount?: SortOrder
    favoriteCount?: SortOrder
    version?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestTemplateAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    sharedWith?: SortOrder
    useCount?: SortOrder
    favoriteCount?: SortOrder
  }

  export type TestTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    isPublic?: SortOrder
    isPredefined?: SortOrder
    useCount?: SortOrder
    favoriteCount?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    isPublic?: SortOrder
    isPredefined?: SortOrder
    useCount?: SortOrder
    favoriteCount?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestTemplateSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    sharedWith?: SortOrder
    useCount?: SortOrder
    favoriteCount?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type WebhookCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    events?: SortOrder
    method?: SortOrder
    headers?: SortOrder
    payloadTemplate?: SortOrder
    isActive?: SortOrder
    retryEnabled?: SortOrder
    maxRetries?: SortOrder
    retryDelay?: SortOrder
    totalCalls?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    lastTriggered?: SortOrder
    lastSuccess?: SortOrder
    lastFailure?: SortOrder
    lastError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    maxRetries?: SortOrder
    retryDelay?: SortOrder
    totalCalls?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
  }

  export type WebhookMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    method?: SortOrder
    isActive?: SortOrder
    retryEnabled?: SortOrder
    maxRetries?: SortOrder
    retryDelay?: SortOrder
    totalCalls?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    lastTriggered?: SortOrder
    lastSuccess?: SortOrder
    lastFailure?: SortOrder
    lastError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    method?: SortOrder
    isActive?: SortOrder
    retryEnabled?: SortOrder
    maxRetries?: SortOrder
    retryDelay?: SortOrder
    totalCalls?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    lastTriggered?: SortOrder
    lastSuccess?: SortOrder
    lastFailure?: SortOrder
    lastError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    maxRetries?: SortOrder
    retryDelay?: SortOrder
    totalCalls?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
  }

  export type WebhookLogCountOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    event?: SortOrder
    payload?: SortOrder
    url?: SortOrder
    method?: SortOrder
    headers?: SortOrder
    statusCode?: SortOrder
    responseBody?: SortOrder
    responseTime?: SortOrder
    attempt?: SortOrder
    success?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookLogAvgOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    attempt?: SortOrder
  }

  export type WebhookLogMaxOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    event?: SortOrder
    url?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseBody?: SortOrder
    responseTime?: SortOrder
    attempt?: SortOrder
    success?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookLogMinOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    event?: SortOrder
    url?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseBody?: SortOrder
    responseTime?: SortOrder
    attempt?: SortOrder
    success?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookLogSumOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    attempt?: SortOrder
  }

  export type ApiRateLimitUserIdProviderLimitTypeLimitPeriodCompoundUniqueInput = {
    userId: number
    provider: string
    limitType: string
    limitPeriod: string
  }

  export type ApiRateLimitCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    limitType?: SortOrder
    limitPeriod?: SortOrder
    maxLimit?: SortOrder
    currentUsage?: SortOrder
    resetAt?: SortOrder
    warningThreshold?: SortOrder
    lastWarningAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiRateLimitAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    maxLimit?: SortOrder
    currentUsage?: SortOrder
    warningThreshold?: SortOrder
  }

  export type ApiRateLimitMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    limitType?: SortOrder
    limitPeriod?: SortOrder
    maxLimit?: SortOrder
    currentUsage?: SortOrder
    resetAt?: SortOrder
    warningThreshold?: SortOrder
    lastWarningAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiRateLimitMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    limitType?: SortOrder
    limitPeriod?: SortOrder
    maxLimit?: SortOrder
    currentUsage?: SortOrder
    resetAt?: SortOrder
    warningThreshold?: SortOrder
    lastWarningAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiRateLimitSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    maxLimit?: SortOrder
    currentUsage?: SortOrder
    warningThreshold?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumAuditCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditCategory | EnumAuditCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AuditCategory[] | ListEnumAuditCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditCategory[] | ListEnumAuditCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditCategoryFilter<$PrismaModel> | $Enums.AuditCategory
  }

  export type EnumAuditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusFilter<$PrismaModel> | $Enums.AuditStatus
  }

  export type AuditRecordCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    category?: SortOrder
    details?: SortOrder
    metadata?: SortOrder
    status?: SortOrder
    lamport?: SortOrder
    hashPointer?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lamport?: SortOrder
  }

  export type AuditRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    category?: SortOrder
    status?: SortOrder
    lamport?: SortOrder
    hashPointer?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditRecordMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    category?: SortOrder
    status?: SortOrder
    lamport?: SortOrder
    hashPointer?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditRecordSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lamport?: SortOrder
  }

  export type EnumAuditCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditCategory | EnumAuditCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AuditCategory[] | ListEnumAuditCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditCategory[] | ListEnumAuditCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AuditCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditCategoryFilter<$PrismaModel>
    _max?: NestedEnumAuditCategoryFilter<$PrismaModel>
  }

  export type EnumAuditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditStatusFilter<$PrismaModel>
    _max?: NestedEnumAuditStatusFilter<$PrismaModel>
  }

  export type LamportStateCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    lamport?: SortOrder
    metadata?: SortOrder
    modified?: SortOrder
  }

  export type LamportStateAvgOrderByAggregateInput = {
    id?: SortOrder
    lamport?: SortOrder
  }

  export type LamportStateMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    lamport?: SortOrder
    modified?: SortOrder
  }

  export type LamportStateMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    lamport?: SortOrder
    modified?: SortOrder
  }

  export type LamportStateSumOrderByAggregateInput = {
    id?: SortOrder
    lamport?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BudgetCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    limit?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    limit?: SortOrder
  }

  export type BudgetMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    limit?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    limit?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    limit?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type RegressionBaselineUserIdModelNameModelVersionTestTypeCompoundUniqueInput = {
    userId: number
    modelName: string
    modelVersion: string
    testType: string
  }

  export type RegressionBaselineCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrder
    testType?: SortOrder
    avgResponseTime?: SortOrder
    avgCost?: SortOrder
    avgQualityScore?: SortOrder
    avgAccuracy?: SortOrder
    successRate?: SortOrder
    alertThreshold?: SortOrder
    sampleSize?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RegressionBaselineAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    avgResponseTime?: SortOrder
    avgCost?: SortOrder
    avgQualityScore?: SortOrder
    avgAccuracy?: SortOrder
    successRate?: SortOrder
    alertThreshold?: SortOrder
    sampleSize?: SortOrder
  }

  export type RegressionBaselineMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrder
    testType?: SortOrder
    avgResponseTime?: SortOrder
    avgCost?: SortOrder
    avgQualityScore?: SortOrder
    avgAccuracy?: SortOrder
    successRate?: SortOrder
    alertThreshold?: SortOrder
    sampleSize?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RegressionBaselineMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrder
    testType?: SortOrder
    avgResponseTime?: SortOrder
    avgCost?: SortOrder
    avgQualityScore?: SortOrder
    avgAccuracy?: SortOrder
    successRate?: SortOrder
    alertThreshold?: SortOrder
    sampleSize?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RegressionBaselineSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    avgResponseTime?: SortOrder
    avgCost?: SortOrder
    avgQualityScore?: SortOrder
    avgAccuracy?: SortOrder
    successRate?: SortOrder
    alertThreshold?: SortOrder
    sampleSize?: SortOrder
  }

  export type EnumFeedbackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeFilter<$PrismaModel> | $Enums.FeedbackType
  }

  export type EnumFeedbackCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackCategory | EnumFeedbackCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackCategoryFilter<$PrismaModel> | $Enums.FeedbackCategory
  }

  export type EnumFeedbackPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackPriority | EnumFeedbackPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackPriorityFilter<$PrismaModel> | $Enums.FeedbackPriority
  }

  export type EnumFeedbackStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackStatus | EnumFeedbackStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackStatusFilter<$PrismaModel> | $Enums.FeedbackStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type FeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    url?: SortOrder
    userAgent?: SortOrder
    metadata?: SortOrder
    attachmentUrls?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    response?: SortOrder
    respondedAt?: SortOrder
    respondedBy?: SortOrder
    sentiment?: SortOrder
    sentimentScore?: SortOrder
    upvotes?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type FeedbackAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assignedTo?: SortOrder
    respondedBy?: SortOrder
    sentimentScore?: SortOrder
    upvotes?: SortOrder
  }

  export type FeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    url?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    response?: SortOrder
    respondedAt?: SortOrder
    respondedBy?: SortOrder
    sentiment?: SortOrder
    sentimentScore?: SortOrder
    upvotes?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type FeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    url?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    response?: SortOrder
    respondedAt?: SortOrder
    respondedBy?: SortOrder
    sentiment?: SortOrder
    sentimentScore?: SortOrder
    upvotes?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type FeedbackSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assignedTo?: SortOrder
    respondedBy?: SortOrder
    sentimentScore?: SortOrder
    upvotes?: SortOrder
  }

  export type EnumFeedbackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedbackTypeFilter<$PrismaModel>
  }

  export type EnumFeedbackCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackCategory | EnumFeedbackCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackCategoryFilter<$PrismaModel>
    _max?: NestedEnumFeedbackCategoryFilter<$PrismaModel>
  }

  export type EnumFeedbackPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackPriority | EnumFeedbackPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackPriorityWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackPriorityFilter<$PrismaModel>
    _max?: NestedEnumFeedbackPriorityFilter<$PrismaModel>
  }

  export type EnumFeedbackStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackStatus | EnumFeedbackStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackStatusWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackStatusFilter<$PrismaModel>
    _max?: NestedEnumFeedbackStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IpWhitelistCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    ipAddress?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type IpWhitelistAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    createdBy?: SortOrder
  }

  export type IpWhitelistMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    ipAddress?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type IpWhitelistMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    ipAddress?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type IpWhitelistSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumSecurityEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SecurityEventType | EnumSecurityEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSecurityEventTypeFilter<$PrismaModel> | $Enums.SecurityEventType
  }

  export type EnumSecuritySeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.SecuritySeverity | EnumSecuritySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSecuritySeverityFilter<$PrismaModel> | $Enums.SecuritySeverity
  }

  export type SecurityEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    resolved?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityEventAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resolvedBy?: SortOrder
  }

  export type SecurityEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    description?: SortOrder
    resolved?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    description?: SortOrder
    resolved?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityEventSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resolvedBy?: SortOrder
  }

  export type EnumSecurityEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SecurityEventType | EnumSecurityEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSecurityEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.SecurityEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSecurityEventTypeFilter<$PrismaModel>
    _max?: NestedEnumSecurityEventTypeFilter<$PrismaModel>
  }

  export type EnumSecuritySeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SecuritySeverity | EnumSecuritySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSecuritySeverityWithAggregatesFilter<$PrismaModel> | $Enums.SecuritySeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSecuritySeverityFilter<$PrismaModel>
    _max?: NestedEnumSecuritySeverityFilter<$PrismaModel>
  }

  export type TwoFactorBackupCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    used?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TwoFactorBackupAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TwoFactorBackupMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    used?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TwoFactorBackupMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    used?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TwoFactorBackupSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumSSOProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.SSOProvider | EnumSSOProviderFieldRefInput<$PrismaModel>
    in?: $Enums.SSOProvider[] | ListEnumSSOProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.SSOProvider[] | ListEnumSSOProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumSSOProviderFilter<$PrismaModel> | $Enums.SSOProvider
  }

  export type SSOConfigurationOrgIdProviderCompoundUniqueInput = {
    orgId: number
    provider: $Enums.SSOProvider
  }

  export type SSOConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    provider?: SortOrder
    enabled?: SortOrder
    samlEntryPoint?: SortOrder
    samlIssuer?: SortOrder
    samlCert?: SortOrder
    samlCallbackUrl?: SortOrder
    samlLogoutUrl?: SortOrder
    oauthClientId?: SortOrder
    oauthClientSecret?: SortOrder
    oauthAuthUrl?: SortOrder
    oauthTokenUrl?: SortOrder
    oauthUserInfoUrl?: SortOrder
    oauthScopes?: SortOrder
    domainRestriction?: SortOrder
    jitProvisioning?: SortOrder
    defaultRole?: SortOrder
    defaultTier?: SortOrder
    metadata?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type SSOConfigurationAvgOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    createdBy?: SortOrder
  }

  export type SSOConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    provider?: SortOrder
    enabled?: SortOrder
    samlEntryPoint?: SortOrder
    samlIssuer?: SortOrder
    samlCert?: SortOrder
    samlCallbackUrl?: SortOrder
    samlLogoutUrl?: SortOrder
    oauthClientId?: SortOrder
    oauthClientSecret?: SortOrder
    oauthAuthUrl?: SortOrder
    oauthTokenUrl?: SortOrder
    oauthUserInfoUrl?: SortOrder
    jitProvisioning?: SortOrder
    defaultRole?: SortOrder
    defaultTier?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type SSOConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    provider?: SortOrder
    enabled?: SortOrder
    samlEntryPoint?: SortOrder
    samlIssuer?: SortOrder
    samlCert?: SortOrder
    samlCallbackUrl?: SortOrder
    samlLogoutUrl?: SortOrder
    oauthClientId?: SortOrder
    oauthClientSecret?: SortOrder
    oauthAuthUrl?: SortOrder
    oauthTokenUrl?: SortOrder
    oauthUserInfoUrl?: SortOrder
    jitProvisioning?: SortOrder
    defaultRole?: SortOrder
    defaultTier?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type SSOConfigurationSumOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumSSOProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SSOProvider | EnumSSOProviderFieldRefInput<$PrismaModel>
    in?: $Enums.SSOProvider[] | ListEnumSSOProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.SSOProvider[] | ListEnumSSOProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumSSOProviderWithAggregatesFilter<$PrismaModel> | $Enums.SSOProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSSOProviderFilter<$PrismaModel>
    _max?: NestedEnumSSOProviderFilter<$PrismaModel>
  }

  export type SSOSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    sessionId?: SortOrder
    nameId?: SortOrder
    sessionIndex?: SortOrder
    attributes?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastActivityAt?: SortOrder
  }

  export type SSOSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SSOSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    sessionId?: SortOrder
    nameId?: SortOrder
    sessionIndex?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastActivityAt?: SortOrder
  }

  export type SSOSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    sessionId?: SortOrder
    nameId?: SortOrder
    sessionIndex?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastActivityAt?: SortOrder
  }

  export type SSOSessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumSSOEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SSOEventType | EnumSSOEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SSOEventType[] | ListEnumSSOEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SSOEventType[] | ListEnumSSOEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSSOEventTypeFilter<$PrismaModel> | $Enums.SSOEventType
  }

  export type SSOAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    eventType?: SortOrder
    success?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    errorMessage?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type SSOAuditLogAvgOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
  }

  export type SSOAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    eventType?: SortOrder
    success?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type SSOAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    eventType?: SortOrder
    success?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type SSOAuditLogSumOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    userId?: SortOrder
  }

  export type EnumSSOEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SSOEventType | EnumSSOEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SSOEventType[] | ListEnumSSOEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SSOEventType[] | ListEnumSSOEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSSOEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.SSOEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSSOEventTypeFilter<$PrismaModel>
    _max?: NestedEnumSSOEventTypeFilter<$PrismaModel>
  }

  export type NotificationPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    testComplete?: SortOrder
    batchComplete?: SortOrder
    scheduledTestComplete?: SortOrder
    alertsEnabled?: SortOrder
    lowScoreThreshold?: SortOrder
    highScoreThreshold?: SortOrder
    scoreDropAlert?: SortOrder
    witnessFailureAlert?: SortOrder
    dailyReport?: SortOrder
    weeklyReport?: SortOrder
    monthlyReport?: SortOrder
    reportTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lowScoreThreshold?: SortOrder
    highScoreThreshold?: SortOrder
  }

  export type NotificationPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    testComplete?: SortOrder
    batchComplete?: SortOrder
    scheduledTestComplete?: SortOrder
    alertsEnabled?: SortOrder
    lowScoreThreshold?: SortOrder
    highScoreThreshold?: SortOrder
    scoreDropAlert?: SortOrder
    witnessFailureAlert?: SortOrder
    dailyReport?: SortOrder
    weeklyReport?: SortOrder
    monthlyReport?: SortOrder
    reportTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    testComplete?: SortOrder
    batchComplete?: SortOrder
    scheduledTestComplete?: SortOrder
    alertsEnabled?: SortOrder
    lowScoreThreshold?: SortOrder
    highScoreThreshold?: SortOrder
    scoreDropAlert?: SortOrder
    witnessFailureAlert?: SortOrder
    dailyReport?: SortOrder
    weeklyReport?: SortOrder
    monthlyReport?: SortOrder
    reportTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lowScoreThreshold?: SortOrder
    highScoreThreshold?: SortOrder
  }

  export type TestResultCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    modelName?: SortOrder
    modelProvider?: SortOrder
    prompt?: SortOrder
    response?: SortOrder
    criesScore?: SortOrder
    responseTime?: SortOrder
    tokenCount?: SortOrder
    cost?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type TestResultAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    criesScore?: SortOrder
    responseTime?: SortOrder
    tokenCount?: SortOrder
    cost?: SortOrder
  }

  export type TestResultMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    modelName?: SortOrder
    modelProvider?: SortOrder
    prompt?: SortOrder
    response?: SortOrder
    criesScore?: SortOrder
    responseTime?: SortOrder
    tokenCount?: SortOrder
    cost?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type TestResultMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    modelName?: SortOrder
    modelProvider?: SortOrder
    prompt?: SortOrder
    response?: SortOrder
    criesScore?: SortOrder
    responseTime?: SortOrder
    tokenCount?: SortOrder
    cost?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type TestResultSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    criesScore?: SortOrder
    responseTime?: SortOrder
    tokenCount?: SortOrder
    cost?: SortOrder
  }

  export type LamportCounterCountOrderByAggregateInput = {
    id?: SortOrder
    currentValue?: SortOrder
    lastUpdated?: SortOrder
    lastReceiptId?: SortOrder
    metadata?: SortOrder
  }

  export type LamportCounterAvgOrderByAggregateInput = {
    id?: SortOrder
    currentValue?: SortOrder
    lastReceiptId?: SortOrder
  }

  export type LamportCounterMaxOrderByAggregateInput = {
    id?: SortOrder
    currentValue?: SortOrder
    lastUpdated?: SortOrder
    lastReceiptId?: SortOrder
  }

  export type LamportCounterMinOrderByAggregateInput = {
    id?: SortOrder
    currentValue?: SortOrder
    lastUpdated?: SortOrder
    lastReceiptId?: SortOrder
  }

  export type LamportCounterSumOrderByAggregateInput = {
    id?: SortOrder
    currentValue?: SortOrder
    lastReceiptId?: SortOrder
  }

  export type EnumReceiptTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReceiptType | EnumReceiptTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReceiptType[] | ListEnumReceiptTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReceiptType[] | ListEnumReceiptTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReceiptTypeFilter<$PrismaModel> | $Enums.ReceiptType
  }

  export type EnumTrackTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackType | EnumTrackTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTrackTypeNullableFilter<$PrismaModel> | $Enums.TrackType | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type TriTrackHandoffListRelationFilter = {
    every?: TriTrackHandoffWhereInput
    some?: TriTrackHandoffWhereInput
    none?: TriTrackHandoffWhereInput
  }

  export type TriTrackHandoffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BENReceiptCountOrderByAggregateInput = {
    id?: SortOrder
    receiptType?: SortOrder
    lamportClock?: SortOrder
    realTimestamp?: SortOrder
    userId?: SortOrder
    persona?: SortOrder
    track?: SortOrder
    payload?: SortOrder
    digest?: SortOrder
    previousDigest?: SortOrder
    baselineDigest?: SortOrder
    witnessModel?: SortOrder
    witnessSignature?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type BENReceiptAvgOrderByAggregateInput = {
    id?: SortOrder
    lamportClock?: SortOrder
    userId?: SortOrder
  }

  export type BENReceiptMaxOrderByAggregateInput = {
    id?: SortOrder
    receiptType?: SortOrder
    lamportClock?: SortOrder
    realTimestamp?: SortOrder
    userId?: SortOrder
    persona?: SortOrder
    track?: SortOrder
    digest?: SortOrder
    previousDigest?: SortOrder
    baselineDigest?: SortOrder
    witnessModel?: SortOrder
    witnessSignature?: SortOrder
    createdAt?: SortOrder
  }

  export type BENReceiptMinOrderByAggregateInput = {
    id?: SortOrder
    receiptType?: SortOrder
    lamportClock?: SortOrder
    realTimestamp?: SortOrder
    userId?: SortOrder
    persona?: SortOrder
    track?: SortOrder
    digest?: SortOrder
    previousDigest?: SortOrder
    baselineDigest?: SortOrder
    witnessModel?: SortOrder
    witnessSignature?: SortOrder
    createdAt?: SortOrder
  }

  export type BENReceiptSumOrderByAggregateInput = {
    id?: SortOrder
    lamportClock?: SortOrder
    userId?: SortOrder
  }

  export type EnumReceiptTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReceiptType | EnumReceiptTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReceiptType[] | ListEnumReceiptTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReceiptType[] | ListEnumReceiptTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReceiptTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReceiptType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReceiptTypeFilter<$PrismaModel>
    _max?: NestedEnumReceiptTypeFilter<$PrismaModel>
  }

  export type EnumTrackTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackType | EnumTrackTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTrackTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TrackType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTrackTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumTrackTypeNullableFilter<$PrismaModel>
  }

  export type BENSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    persona?: SortOrder
    priority?: SortOrder
    locked?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    duration?: SortOrder
    startLamport?: SortOrder
    endLamport?: SortOrder
    switchReason?: SortOrder
    metadata?: SortOrder
  }

  export type BENSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
    duration?: SortOrder
    startLamport?: SortOrder
    endLamport?: SortOrder
  }

  export type BENSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    persona?: SortOrder
    priority?: SortOrder
    locked?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    duration?: SortOrder
    startLamport?: SortOrder
    endLamport?: SortOrder
    switchReason?: SortOrder
  }

  export type BENSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    persona?: SortOrder
    priority?: SortOrder
    locked?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    duration?: SortOrder
    startLamport?: SortOrder
    endLamport?: SortOrder
    switchReason?: SortOrder
  }

  export type BENSessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
    duration?: SortOrder
    startLamport?: SortOrder
    endLamport?: SortOrder
  }

  export type EnumTrackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackType | EnumTrackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrackTypeFilter<$PrismaModel> | $Enums.TrackType
  }

  export type EnumHandoffStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HandoffStatus | EnumHandoffStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HandoffStatus[] | ListEnumHandoffStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HandoffStatus[] | ListEnumHandoffStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHandoffStatusFilter<$PrismaModel> | $Enums.HandoffStatus
  }

  export type BENReceiptScalarRelationFilter = {
    is?: BENReceiptWhereInput
    isNot?: BENReceiptWhereInput
  }

  export type BENReceiptNullableScalarRelationFilter = {
    is?: BENReceiptWhereInput | null
    isNot?: BENReceiptWhereInput | null
  }

  export type TriTrackHandoffCountOrderByAggregateInput = {
    id?: SortOrder
    fromTrack?: SortOrder
    toTrack?: SortOrder
    status?: SortOrder
    fromReceiptId?: SortOrder
    toReceiptId?: SortOrder
    initiatedAt?: SortOrder
    completedAt?: SortOrder
    latencyMs?: SortOrder
    exceededLimit?: SortOrder
    payload?: SortOrder
    result?: SortOrder
    errorMessage?: SortOrder
    metadata?: SortOrder
  }

  export type TriTrackHandoffAvgOrderByAggregateInput = {
    id?: SortOrder
    fromReceiptId?: SortOrder
    toReceiptId?: SortOrder
    latencyMs?: SortOrder
  }

  export type TriTrackHandoffMaxOrderByAggregateInput = {
    id?: SortOrder
    fromTrack?: SortOrder
    toTrack?: SortOrder
    status?: SortOrder
    fromReceiptId?: SortOrder
    toReceiptId?: SortOrder
    initiatedAt?: SortOrder
    completedAt?: SortOrder
    latencyMs?: SortOrder
    exceededLimit?: SortOrder
    errorMessage?: SortOrder
  }

  export type TriTrackHandoffMinOrderByAggregateInput = {
    id?: SortOrder
    fromTrack?: SortOrder
    toTrack?: SortOrder
    status?: SortOrder
    fromReceiptId?: SortOrder
    toReceiptId?: SortOrder
    initiatedAt?: SortOrder
    completedAt?: SortOrder
    latencyMs?: SortOrder
    exceededLimit?: SortOrder
    errorMessage?: SortOrder
  }

  export type TriTrackHandoffSumOrderByAggregateInput = {
    id?: SortOrder
    fromReceiptId?: SortOrder
    toReceiptId?: SortOrder
    latencyMs?: SortOrder
  }

  export type EnumTrackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackType | EnumTrackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrackTypeWithAggregatesFilter<$PrismaModel> | $Enums.TrackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrackTypeFilter<$PrismaModel>
    _max?: NestedEnumTrackTypeFilter<$PrismaModel>
  }

  export type EnumHandoffStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HandoffStatus | EnumHandoffStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HandoffStatus[] | ListEnumHandoffStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HandoffStatus[] | ListEnumHandoffStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHandoffStatusWithAggregatesFilter<$PrismaModel> | $Enums.HandoffStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHandoffStatusFilter<$PrismaModel>
    _max?: NestedEnumHandoffStatusFilter<$PrismaModel>
  }

  export type WitnessSignatureCountOrderByAggregateInput = {
    id?: SortOrder
    modelName?: SortOrder
    modelFingerprint?: SortOrder
    receiptId?: SortOrder
    receiptDigest?: SortOrder
    signature?: SortOrder
    signedAt?: SortOrder
    lamportClock?: SortOrder
    verified?: SortOrder
    verifiedAt?: SortOrder
    verificationData?: SortOrder
    metadata?: SortOrder
  }

  export type WitnessSignatureAvgOrderByAggregateInput = {
    id?: SortOrder
    receiptId?: SortOrder
    lamportClock?: SortOrder
  }

  export type WitnessSignatureMaxOrderByAggregateInput = {
    id?: SortOrder
    modelName?: SortOrder
    modelFingerprint?: SortOrder
    receiptId?: SortOrder
    receiptDigest?: SortOrder
    signature?: SortOrder
    signedAt?: SortOrder
    lamportClock?: SortOrder
    verified?: SortOrder
    verifiedAt?: SortOrder
  }

  export type WitnessSignatureMinOrderByAggregateInput = {
    id?: SortOrder
    modelName?: SortOrder
    modelFingerprint?: SortOrder
    receiptId?: SortOrder
    receiptDigest?: SortOrder
    signature?: SortOrder
    signedAt?: SortOrder
    lamportClock?: SortOrder
    verified?: SortOrder
    verifiedAt?: SortOrder
  }

  export type WitnessSignatureSumOrderByAggregateInput = {
    id?: SortOrder
    receiptId?: SortOrder
    lamportClock?: SortOrder
  }

  export type CRIESComputationCountOrderByAggregateInput = {
    id?: SortOrder
    testResultId?: SortOrder
    userId?: SortOrder
    sigmaWindow?: SortOrder
    tauThreshold?: SortOrder
    piPolicy?: SortOrder
    citationQuality?: SortOrder
    criesScore?: SortOrder
    lamportClock?: SortOrder
    computedAt?: SortOrder
    receiptId?: SortOrder
    analysisData?: SortOrder
    metadata?: SortOrder
  }

  export type CRIESComputationAvgOrderByAggregateInput = {
    id?: SortOrder
    testResultId?: SortOrder
    userId?: SortOrder
    sigmaWindow?: SortOrder
    tauThreshold?: SortOrder
    piPolicy?: SortOrder
    citationQuality?: SortOrder
    criesScore?: SortOrder
    lamportClock?: SortOrder
    receiptId?: SortOrder
  }

  export type CRIESComputationMaxOrderByAggregateInput = {
    id?: SortOrder
    testResultId?: SortOrder
    userId?: SortOrder
    sigmaWindow?: SortOrder
    tauThreshold?: SortOrder
    piPolicy?: SortOrder
    citationQuality?: SortOrder
    criesScore?: SortOrder
    lamportClock?: SortOrder
    computedAt?: SortOrder
    receiptId?: SortOrder
  }

  export type CRIESComputationMinOrderByAggregateInput = {
    id?: SortOrder
    testResultId?: SortOrder
    userId?: SortOrder
    sigmaWindow?: SortOrder
    tauThreshold?: SortOrder
    piPolicy?: SortOrder
    citationQuality?: SortOrder
    criesScore?: SortOrder
    lamportClock?: SortOrder
    computedAt?: SortOrder
    receiptId?: SortOrder
  }

  export type CRIESComputationSumOrderByAggregateInput = {
    id?: SortOrder
    testResultId?: SortOrder
    userId?: SortOrder
    sigmaWindow?: SortOrder
    tauThreshold?: SortOrder
    piPolicy?: SortOrder
    citationQuality?: SortOrder
    criesScore?: SortOrder
    lamportClock?: SortOrder
    receiptId?: SortOrder
  }

  export type ZScanVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalRules?: SortOrder
    passed?: SortOrder
    warnings?: SortOrder
    critical?: SortOrder
    results?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
  }

  export type ZScanVerificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalRules?: SortOrder
    passed?: SortOrder
    warnings?: SortOrder
    critical?: SortOrder
  }

  export type ZScanVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalRules?: SortOrder
    passed?: SortOrder
    warnings?: SortOrder
    critical?: SortOrder
    createdAt?: SortOrder
  }

  export type ZScanVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalRules?: SortOrder
    passed?: SortOrder
    warnings?: SortOrder
    critical?: SortOrder
    createdAt?: SortOrder
  }

  export type ZScanVerificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalRules?: SortOrder
    passed?: SortOrder
    warnings?: SortOrder
    critical?: SortOrder
  }

  export type UserCreatepermissionsInput = {
    set: $Enums.Permission[]
  }

  export type UserCreatebackupCodesInput = {
    set: string[]
  }

  export type OrganizationCreateNestedOneWithoutUsersInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AuditRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditRecordCreateWithoutUserInput, AuditRecordUncheckedCreateWithoutUserInput> | AuditRecordCreateWithoutUserInput[] | AuditRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditRecordCreateOrConnectWithoutUserInput | AuditRecordCreateOrConnectWithoutUserInput[]
    createMany?: AuditRecordCreateManyUserInputEnvelope
    connect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
  }

  export type TeamMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type NotificationPreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type BudgetCreateNestedManyWithoutUserInput = {
    create?: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput> | BudgetCreateWithoutUserInput[] | BudgetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutUserInput | BudgetCreateOrConnectWithoutUserInput[]
    createMany?: BudgetCreateManyUserInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type RegressionBaselineCreateNestedManyWithoutUserInput = {
    create?: XOR<RegressionBaselineCreateWithoutUserInput, RegressionBaselineUncheckedCreateWithoutUserInput> | RegressionBaselineCreateWithoutUserInput[] | RegressionBaselineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RegressionBaselineCreateOrConnectWithoutUserInput | RegressionBaselineCreateOrConnectWithoutUserInput[]
    createMany?: RegressionBaselineCreateManyUserInputEnvelope
    connect?: RegressionBaselineWhereUniqueInput | RegressionBaselineWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type BENReceiptCreateNestedManyWithoutUserInput = {
    create?: XOR<BENReceiptCreateWithoutUserInput, BENReceiptUncheckedCreateWithoutUserInput> | BENReceiptCreateWithoutUserInput[] | BENReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BENReceiptCreateOrConnectWithoutUserInput | BENReceiptCreateOrConnectWithoutUserInput[]
    createMany?: BENReceiptCreateManyUserInputEnvelope
    connect?: BENReceiptWhereUniqueInput | BENReceiptWhereUniqueInput[]
  }

  export type BENSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<BENSessionCreateWithoutUserInput, BENSessionUncheckedCreateWithoutUserInput> | BENSessionCreateWithoutUserInput[] | BENSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BENSessionCreateOrConnectWithoutUserInput | BENSessionCreateOrConnectWithoutUserInput[]
    createMany?: BENSessionCreateManyUserInputEnvelope
    connect?: BENSessionWhereUniqueInput | BENSessionWhereUniqueInput[]
  }

  export type ZScanVerificationCreateNestedManyWithoutUserInput = {
    create?: XOR<ZScanVerificationCreateWithoutUserInput, ZScanVerificationUncheckedCreateWithoutUserInput> | ZScanVerificationCreateWithoutUserInput[] | ZScanVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZScanVerificationCreateOrConnectWithoutUserInput | ZScanVerificationCreateOrConnectWithoutUserInput[]
    createMany?: ZScanVerificationCreateManyUserInputEnvelope
    connect?: ZScanVerificationWhereUniqueInput | ZScanVerificationWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AuditRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditRecordCreateWithoutUserInput, AuditRecordUncheckedCreateWithoutUserInput> | AuditRecordCreateWithoutUserInput[] | AuditRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditRecordCreateOrConnectWithoutUserInput | AuditRecordCreateOrConnectWithoutUserInput[]
    createMany?: AuditRecordCreateManyUserInputEnvelope
    connect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type BudgetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput> | BudgetCreateWithoutUserInput[] | BudgetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutUserInput | BudgetCreateOrConnectWithoutUserInput[]
    createMany?: BudgetCreateManyUserInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type RegressionBaselineUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RegressionBaselineCreateWithoutUserInput, RegressionBaselineUncheckedCreateWithoutUserInput> | RegressionBaselineCreateWithoutUserInput[] | RegressionBaselineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RegressionBaselineCreateOrConnectWithoutUserInput | RegressionBaselineCreateOrConnectWithoutUserInput[]
    createMany?: RegressionBaselineCreateManyUserInputEnvelope
    connect?: RegressionBaselineWhereUniqueInput | RegressionBaselineWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type BENReceiptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BENReceiptCreateWithoutUserInput, BENReceiptUncheckedCreateWithoutUserInput> | BENReceiptCreateWithoutUserInput[] | BENReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BENReceiptCreateOrConnectWithoutUserInput | BENReceiptCreateOrConnectWithoutUserInput[]
    createMany?: BENReceiptCreateManyUserInputEnvelope
    connect?: BENReceiptWhereUniqueInput | BENReceiptWhereUniqueInput[]
  }

  export type BENSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BENSessionCreateWithoutUserInput, BENSessionUncheckedCreateWithoutUserInput> | BENSessionCreateWithoutUserInput[] | BENSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BENSessionCreateOrConnectWithoutUserInput | BENSessionCreateOrConnectWithoutUserInput[]
    createMany?: BENSessionCreateManyUserInputEnvelope
    connect?: BENSessionWhereUniqueInput | BENSessionWhereUniqueInput[]
  }

  export type ZScanVerificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ZScanVerificationCreateWithoutUserInput, ZScanVerificationUncheckedCreateWithoutUserInput> | ZScanVerificationCreateWithoutUserInput[] | ZScanVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZScanVerificationCreateOrConnectWithoutUserInput | ZScanVerificationCreateOrConnectWithoutUserInput[]
    createMany?: ZScanVerificationCreateManyUserInputEnvelope
    connect?: ZScanVerificationWhereUniqueInput | ZScanVerificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type EnumUserTierFieldUpdateOperationsInput = {
    set?: $Enums.UserTier
  }

  export type UserUpdatepermissionsInput = {
    set?: $Enums.Permission[]
    push?: $Enums.Permission | $Enums.Permission[]
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdatebackupCodesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumBENPersonaFieldUpdateOperationsInput = {
    set?: $Enums.BENPersona
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrganizationUpdateOneWithoutUsersNestedInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    upsert?: OrganizationUpsertWithoutUsersInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUsersInput, OrganizationUpdateWithoutUsersInput>, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AuditRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditRecordCreateWithoutUserInput, AuditRecordUncheckedCreateWithoutUserInput> | AuditRecordCreateWithoutUserInput[] | AuditRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditRecordCreateOrConnectWithoutUserInput | AuditRecordCreateOrConnectWithoutUserInput[]
    upsert?: AuditRecordUpsertWithWhereUniqueWithoutUserInput | AuditRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditRecordCreateManyUserInputEnvelope
    set?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    disconnect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    delete?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    connect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    update?: AuditRecordUpdateWithWhereUniqueWithoutUserInput | AuditRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditRecordUpdateManyWithWhereWithoutUserInput | AuditRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditRecordScalarWhereInput | AuditRecordScalarWhereInput[]
  }

  export type TeamMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type NotificationPreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type BudgetUpdateManyWithoutUserNestedInput = {
    create?: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput> | BudgetCreateWithoutUserInput[] | BudgetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutUserInput | BudgetCreateOrConnectWithoutUserInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutUserInput | BudgetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BudgetCreateManyUserInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutUserInput | BudgetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutUserInput | BudgetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type RegressionBaselineUpdateManyWithoutUserNestedInput = {
    create?: XOR<RegressionBaselineCreateWithoutUserInput, RegressionBaselineUncheckedCreateWithoutUserInput> | RegressionBaselineCreateWithoutUserInput[] | RegressionBaselineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RegressionBaselineCreateOrConnectWithoutUserInput | RegressionBaselineCreateOrConnectWithoutUserInput[]
    upsert?: RegressionBaselineUpsertWithWhereUniqueWithoutUserInput | RegressionBaselineUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RegressionBaselineCreateManyUserInputEnvelope
    set?: RegressionBaselineWhereUniqueInput | RegressionBaselineWhereUniqueInput[]
    disconnect?: RegressionBaselineWhereUniqueInput | RegressionBaselineWhereUniqueInput[]
    delete?: RegressionBaselineWhereUniqueInput | RegressionBaselineWhereUniqueInput[]
    connect?: RegressionBaselineWhereUniqueInput | RegressionBaselineWhereUniqueInput[]
    update?: RegressionBaselineUpdateWithWhereUniqueWithoutUserInput | RegressionBaselineUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RegressionBaselineUpdateManyWithWhereWithoutUserInput | RegressionBaselineUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RegressionBaselineScalarWhereInput | RegressionBaselineScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutUserInput | FeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutUserInput | FeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutUserInput | FeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type BENReceiptUpdateManyWithoutUserNestedInput = {
    create?: XOR<BENReceiptCreateWithoutUserInput, BENReceiptUncheckedCreateWithoutUserInput> | BENReceiptCreateWithoutUserInput[] | BENReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BENReceiptCreateOrConnectWithoutUserInput | BENReceiptCreateOrConnectWithoutUserInput[]
    upsert?: BENReceiptUpsertWithWhereUniqueWithoutUserInput | BENReceiptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BENReceiptCreateManyUserInputEnvelope
    set?: BENReceiptWhereUniqueInput | BENReceiptWhereUniqueInput[]
    disconnect?: BENReceiptWhereUniqueInput | BENReceiptWhereUniqueInput[]
    delete?: BENReceiptWhereUniqueInput | BENReceiptWhereUniqueInput[]
    connect?: BENReceiptWhereUniqueInput | BENReceiptWhereUniqueInput[]
    update?: BENReceiptUpdateWithWhereUniqueWithoutUserInput | BENReceiptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BENReceiptUpdateManyWithWhereWithoutUserInput | BENReceiptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BENReceiptScalarWhereInput | BENReceiptScalarWhereInput[]
  }

  export type BENSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<BENSessionCreateWithoutUserInput, BENSessionUncheckedCreateWithoutUserInput> | BENSessionCreateWithoutUserInput[] | BENSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BENSessionCreateOrConnectWithoutUserInput | BENSessionCreateOrConnectWithoutUserInput[]
    upsert?: BENSessionUpsertWithWhereUniqueWithoutUserInput | BENSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BENSessionCreateManyUserInputEnvelope
    set?: BENSessionWhereUniqueInput | BENSessionWhereUniqueInput[]
    disconnect?: BENSessionWhereUniqueInput | BENSessionWhereUniqueInput[]
    delete?: BENSessionWhereUniqueInput | BENSessionWhereUniqueInput[]
    connect?: BENSessionWhereUniqueInput | BENSessionWhereUniqueInput[]
    update?: BENSessionUpdateWithWhereUniqueWithoutUserInput | BENSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BENSessionUpdateManyWithWhereWithoutUserInput | BENSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BENSessionScalarWhereInput | BENSessionScalarWhereInput[]
  }

  export type ZScanVerificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ZScanVerificationCreateWithoutUserInput, ZScanVerificationUncheckedCreateWithoutUserInput> | ZScanVerificationCreateWithoutUserInput[] | ZScanVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZScanVerificationCreateOrConnectWithoutUserInput | ZScanVerificationCreateOrConnectWithoutUserInput[]
    upsert?: ZScanVerificationUpsertWithWhereUniqueWithoutUserInput | ZScanVerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ZScanVerificationCreateManyUserInputEnvelope
    set?: ZScanVerificationWhereUniqueInput | ZScanVerificationWhereUniqueInput[]
    disconnect?: ZScanVerificationWhereUniqueInput | ZScanVerificationWhereUniqueInput[]
    delete?: ZScanVerificationWhereUniqueInput | ZScanVerificationWhereUniqueInput[]
    connect?: ZScanVerificationWhereUniqueInput | ZScanVerificationWhereUniqueInput[]
    update?: ZScanVerificationUpdateWithWhereUniqueWithoutUserInput | ZScanVerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ZScanVerificationUpdateManyWithWhereWithoutUserInput | ZScanVerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ZScanVerificationScalarWhereInput | ZScanVerificationScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AuditRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditRecordCreateWithoutUserInput, AuditRecordUncheckedCreateWithoutUserInput> | AuditRecordCreateWithoutUserInput[] | AuditRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditRecordCreateOrConnectWithoutUserInput | AuditRecordCreateOrConnectWithoutUserInput[]
    upsert?: AuditRecordUpsertWithWhereUniqueWithoutUserInput | AuditRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditRecordCreateManyUserInputEnvelope
    set?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    disconnect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    delete?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    connect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    update?: AuditRecordUpdateWithWhereUniqueWithoutUserInput | AuditRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditRecordUpdateManyWithWhereWithoutUserInput | AuditRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditRecordScalarWhereInput | AuditRecordScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type BudgetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput> | BudgetCreateWithoutUserInput[] | BudgetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutUserInput | BudgetCreateOrConnectWithoutUserInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutUserInput | BudgetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BudgetCreateManyUserInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutUserInput | BudgetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutUserInput | BudgetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RegressionBaselineCreateWithoutUserInput, RegressionBaselineUncheckedCreateWithoutUserInput> | RegressionBaselineCreateWithoutUserInput[] | RegressionBaselineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RegressionBaselineCreateOrConnectWithoutUserInput | RegressionBaselineCreateOrConnectWithoutUserInput[]
    upsert?: RegressionBaselineUpsertWithWhereUniqueWithoutUserInput | RegressionBaselineUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RegressionBaselineCreateManyUserInputEnvelope
    set?: RegressionBaselineWhereUniqueInput | RegressionBaselineWhereUniqueInput[]
    disconnect?: RegressionBaselineWhereUniqueInput | RegressionBaselineWhereUniqueInput[]
    delete?: RegressionBaselineWhereUniqueInput | RegressionBaselineWhereUniqueInput[]
    connect?: RegressionBaselineWhereUniqueInput | RegressionBaselineWhereUniqueInput[]
    update?: RegressionBaselineUpdateWithWhereUniqueWithoutUserInput | RegressionBaselineUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RegressionBaselineUpdateManyWithWhereWithoutUserInput | RegressionBaselineUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RegressionBaselineScalarWhereInput | RegressionBaselineScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutUserInput | FeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutUserInput | FeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutUserInput | FeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type BENReceiptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BENReceiptCreateWithoutUserInput, BENReceiptUncheckedCreateWithoutUserInput> | BENReceiptCreateWithoutUserInput[] | BENReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BENReceiptCreateOrConnectWithoutUserInput | BENReceiptCreateOrConnectWithoutUserInput[]
    upsert?: BENReceiptUpsertWithWhereUniqueWithoutUserInput | BENReceiptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BENReceiptCreateManyUserInputEnvelope
    set?: BENReceiptWhereUniqueInput | BENReceiptWhereUniqueInput[]
    disconnect?: BENReceiptWhereUniqueInput | BENReceiptWhereUniqueInput[]
    delete?: BENReceiptWhereUniqueInput | BENReceiptWhereUniqueInput[]
    connect?: BENReceiptWhereUniqueInput | BENReceiptWhereUniqueInput[]
    update?: BENReceiptUpdateWithWhereUniqueWithoutUserInput | BENReceiptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BENReceiptUpdateManyWithWhereWithoutUserInput | BENReceiptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BENReceiptScalarWhereInput | BENReceiptScalarWhereInput[]
  }

  export type BENSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BENSessionCreateWithoutUserInput, BENSessionUncheckedCreateWithoutUserInput> | BENSessionCreateWithoutUserInput[] | BENSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BENSessionCreateOrConnectWithoutUserInput | BENSessionCreateOrConnectWithoutUserInput[]
    upsert?: BENSessionUpsertWithWhereUniqueWithoutUserInput | BENSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BENSessionCreateManyUserInputEnvelope
    set?: BENSessionWhereUniqueInput | BENSessionWhereUniqueInput[]
    disconnect?: BENSessionWhereUniqueInput | BENSessionWhereUniqueInput[]
    delete?: BENSessionWhereUniqueInput | BENSessionWhereUniqueInput[]
    connect?: BENSessionWhereUniqueInput | BENSessionWhereUniqueInput[]
    update?: BENSessionUpdateWithWhereUniqueWithoutUserInput | BENSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BENSessionUpdateManyWithWhereWithoutUserInput | BENSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BENSessionScalarWhereInput | BENSessionScalarWhereInput[]
  }

  export type ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ZScanVerificationCreateWithoutUserInput, ZScanVerificationUncheckedCreateWithoutUserInput> | ZScanVerificationCreateWithoutUserInput[] | ZScanVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZScanVerificationCreateOrConnectWithoutUserInput | ZScanVerificationCreateOrConnectWithoutUserInput[]
    upsert?: ZScanVerificationUpsertWithWhereUniqueWithoutUserInput | ZScanVerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ZScanVerificationCreateManyUserInputEnvelope
    set?: ZScanVerificationWhereUniqueInput | ZScanVerificationWhereUniqueInput[]
    disconnect?: ZScanVerificationWhereUniqueInput | ZScanVerificationWhereUniqueInput[]
    delete?: ZScanVerificationWhereUniqueInput | ZScanVerificationWhereUniqueInput[]
    connect?: ZScanVerificationWhereUniqueInput | ZScanVerificationWhereUniqueInput[]
    update?: ZScanVerificationUpdateWithWhereUniqueWithoutUserInput | ZScanVerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ZScanVerificationUpdateManyWithWhereWithoutUserInput | ZScanVerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ZScanVerificationScalarWhereInput | ZScanVerificationScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TeamCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<TeamCreateWithoutOrganizationInput, TeamUncheckedCreateWithoutOrganizationInput> | TeamCreateWithoutOrganizationInput[] | TeamUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOrganizationInput | TeamCreateOrConnectWithoutOrganizationInput[]
    createMany?: TeamCreateManyOrganizationInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type SSOConfigurationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SSOConfigurationCreateWithoutOrganizationInput, SSOConfigurationUncheckedCreateWithoutOrganizationInput> | SSOConfigurationCreateWithoutOrganizationInput[] | SSOConfigurationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SSOConfigurationCreateOrConnectWithoutOrganizationInput | SSOConfigurationCreateOrConnectWithoutOrganizationInput[]
    createMany?: SSOConfigurationCreateManyOrganizationInputEnvelope
    connect?: SSOConfigurationWhereUniqueInput | SSOConfigurationWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<TeamCreateWithoutOrganizationInput, TeamUncheckedCreateWithoutOrganizationInput> | TeamCreateWithoutOrganizationInput[] | TeamUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOrganizationInput | TeamCreateOrConnectWithoutOrganizationInput[]
    createMany?: TeamCreateManyOrganizationInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type SSOConfigurationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SSOConfigurationCreateWithoutOrganizationInput, SSOConfigurationUncheckedCreateWithoutOrganizationInput> | SSOConfigurationCreateWithoutOrganizationInput[] | SSOConfigurationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SSOConfigurationCreateOrConnectWithoutOrganizationInput | SSOConfigurationCreateOrConnectWithoutOrganizationInput[]
    createMany?: SSOConfigurationCreateManyOrganizationInputEnvelope
    connect?: SSOConfigurationWhereUniqueInput | SSOConfigurationWhereUniqueInput[]
  }

  export type EnumPlanTypeFieldUpdateOperationsInput = {
    set?: $Enums.PlanType
  }

  export type EnumOrgStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrgStatus
  }

  export type UserUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TeamUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<TeamCreateWithoutOrganizationInput, TeamUncheckedCreateWithoutOrganizationInput> | TeamCreateWithoutOrganizationInput[] | TeamUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOrganizationInput | TeamCreateOrConnectWithoutOrganizationInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutOrganizationInput | TeamUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: TeamCreateManyOrganizationInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutOrganizationInput | TeamUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutOrganizationInput | TeamUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type SSOConfigurationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SSOConfigurationCreateWithoutOrganizationInput, SSOConfigurationUncheckedCreateWithoutOrganizationInput> | SSOConfigurationCreateWithoutOrganizationInput[] | SSOConfigurationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SSOConfigurationCreateOrConnectWithoutOrganizationInput | SSOConfigurationCreateOrConnectWithoutOrganizationInput[]
    upsert?: SSOConfigurationUpsertWithWhereUniqueWithoutOrganizationInput | SSOConfigurationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SSOConfigurationCreateManyOrganizationInputEnvelope
    set?: SSOConfigurationWhereUniqueInput | SSOConfigurationWhereUniqueInput[]
    disconnect?: SSOConfigurationWhereUniqueInput | SSOConfigurationWhereUniqueInput[]
    delete?: SSOConfigurationWhereUniqueInput | SSOConfigurationWhereUniqueInput[]
    connect?: SSOConfigurationWhereUniqueInput | SSOConfigurationWhereUniqueInput[]
    update?: SSOConfigurationUpdateWithWhereUniqueWithoutOrganizationInput | SSOConfigurationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SSOConfigurationUpdateManyWithWhereWithoutOrganizationInput | SSOConfigurationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SSOConfigurationScalarWhereInput | SSOConfigurationScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<TeamCreateWithoutOrganizationInput, TeamUncheckedCreateWithoutOrganizationInput> | TeamCreateWithoutOrganizationInput[] | TeamUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOrganizationInput | TeamCreateOrConnectWithoutOrganizationInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutOrganizationInput | TeamUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: TeamCreateManyOrganizationInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutOrganizationInput | TeamUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutOrganizationInput | TeamUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type SSOConfigurationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SSOConfigurationCreateWithoutOrganizationInput, SSOConfigurationUncheckedCreateWithoutOrganizationInput> | SSOConfigurationCreateWithoutOrganizationInput[] | SSOConfigurationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SSOConfigurationCreateOrConnectWithoutOrganizationInput | SSOConfigurationCreateOrConnectWithoutOrganizationInput[]
    upsert?: SSOConfigurationUpsertWithWhereUniqueWithoutOrganizationInput | SSOConfigurationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SSOConfigurationCreateManyOrganizationInputEnvelope
    set?: SSOConfigurationWhereUniqueInput | SSOConfigurationWhereUniqueInput[]
    disconnect?: SSOConfigurationWhereUniqueInput | SSOConfigurationWhereUniqueInput[]
    delete?: SSOConfigurationWhereUniqueInput | SSOConfigurationWhereUniqueInput[]
    connect?: SSOConfigurationWhereUniqueInput | SSOConfigurationWhereUniqueInput[]
    update?: SSOConfigurationUpdateWithWhereUniqueWithoutOrganizationInput | SSOConfigurationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SSOConfigurationUpdateManyWithWhereWithoutOrganizationInput | SSOConfigurationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SSOConfigurationScalarWhereInput | SSOConfigurationScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutTeamsInput = {
    create?: XOR<OrganizationCreateWithoutTeamsInput, OrganizationUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTeamsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type TeamMemberCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<OrganizationCreateWithoutTeamsInput, OrganizationUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTeamsInput
    upsert?: OrganizationUpsertWithoutTeamsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutTeamsInput, OrganizationUpdateWithoutTeamsInput>, OrganizationUncheckedUpdateWithoutTeamsInput>
  }

  export type TeamMemberUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutMembersInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeamsInput = {
    create?: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTeamRoleFieldUpdateOperationsInput = {
    set?: $Enums.TeamRole
  }

  export type TeamUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    upsert?: TeamUpsertWithoutMembersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMembersInput, TeamUpdateWithoutMembersInput>, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsInput
    upsert?: UserUpsertWithoutTeamsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamsInput, UserUpdateWithoutTeamsInput>, UserUncheckedUpdateWithoutTeamsInput>
  }

  export type SharedTestCollectionCreatetagsInput = {
    set: string[]
  }

  export type SharedTestCollectionCreatetestIdsInput = {
    set: number[]
  }

  export type SharedTestCollectionUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SharedTestCollectionUpdatetestIdsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type TestTemplateCreatetagsInput = {
    set: string[]
  }

  export type TestTemplateCreatesharedWithInput = {
    set: number[]
  }

  export type TestTemplateUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TestTemplateUpdatesharedWithInput = {
    set?: number[]
    push?: number | number[]
  }

  export type WebhookCreateeventsInput = {
    set: string[]
  }

  export type WebhookUpdateeventsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAuditsInput = {
    create?: XOR<UserCreateWithoutAuditsInput, UserUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuditCategoryFieldUpdateOperationsInput = {
    set?: $Enums.AuditCategory
  }

  export type EnumAuditStatusFieldUpdateOperationsInput = {
    set?: $Enums.AuditStatus
  }

  export type UserUpdateOneRequiredWithoutAuditsNestedInput = {
    create?: XOR<UserCreateWithoutAuditsInput, UserUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditsInput
    upsert?: UserUpsertWithoutAuditsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditsInput, UserUpdateWithoutAuditsInput>, UserUncheckedUpdateWithoutAuditsInput>
  }

  export type UserCreateNestedOneWithoutBudgetsInput = {
    create?: XOR<UserCreateWithoutBudgetsInput, UserUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBudgetsInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutBudgetsNestedInput = {
    create?: XOR<UserCreateWithoutBudgetsInput, UserUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBudgetsInput
    upsert?: UserUpsertWithoutBudgetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBudgetsInput, UserUpdateWithoutBudgetsInput>, UserUncheckedUpdateWithoutBudgetsInput>
  }

  export type UserCreateNestedOneWithoutRegressionBaselinesInput = {
    create?: XOR<UserCreateWithoutRegressionBaselinesInput, UserUncheckedCreateWithoutRegressionBaselinesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRegressionBaselinesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRegressionBaselinesNestedInput = {
    create?: XOR<UserCreateWithoutRegressionBaselinesInput, UserUncheckedCreateWithoutRegressionBaselinesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRegressionBaselinesInput
    upsert?: UserUpsertWithoutRegressionBaselinesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRegressionBaselinesInput, UserUpdateWithoutRegressionBaselinesInput>, UserUncheckedUpdateWithoutRegressionBaselinesInput>
  }

  export type FeedbackCreateattachmentUrlsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbacksInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFeedbackTypeFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackType
  }

  export type EnumFeedbackCategoryFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackCategory
  }

  export type EnumFeedbackPriorityFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackPriority
  }

  export type FeedbackUpdateattachmentUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumFeedbackStatusFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbacksInput
    upsert?: UserUpsertWithoutFeedbacksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedbacksInput, UserUpdateWithoutFeedbacksInput>, UserUncheckedUpdateWithoutFeedbacksInput>
  }

  export type EnumSecurityEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.SecurityEventType
  }

  export type EnumSecuritySeverityFieldUpdateOperationsInput = {
    set?: $Enums.SecuritySeverity
  }

  export type SSOConfigurationCreateoauthScopesInput = {
    set: string[]
  }

  export type SSOConfigurationCreatedomainRestrictionInput = {
    set: string[]
  }

  export type OrganizationCreateNestedOneWithoutSsoConfigsInput = {
    create?: XOR<OrganizationCreateWithoutSsoConfigsInput, OrganizationUncheckedCreateWithoutSsoConfigsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSsoConfigsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type EnumSSOProviderFieldUpdateOperationsInput = {
    set?: $Enums.SSOProvider
  }

  export type SSOConfigurationUpdateoauthScopesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SSOConfigurationUpdatedomainRestrictionInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OrganizationUpdateOneRequiredWithoutSsoConfigsNestedInput = {
    create?: XOR<OrganizationCreateWithoutSsoConfigsInput, OrganizationUncheckedCreateWithoutSsoConfigsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSsoConfigsInput
    upsert?: OrganizationUpsertWithoutSsoConfigsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutSsoConfigsInput, OrganizationUpdateWithoutSsoConfigsInput>, OrganizationUncheckedUpdateWithoutSsoConfigsInput>
  }

  export type EnumSSOEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.SSOEventType
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutBenReceiptsInput = {
    create?: XOR<UserCreateWithoutBenReceiptsInput, UserUncheckedCreateWithoutBenReceiptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBenReceiptsInput
    connect?: UserWhereUniqueInput
  }

  export type TriTrackHandoffCreateNestedManyWithoutFromReceiptInput = {
    create?: XOR<TriTrackHandoffCreateWithoutFromReceiptInput, TriTrackHandoffUncheckedCreateWithoutFromReceiptInput> | TriTrackHandoffCreateWithoutFromReceiptInput[] | TriTrackHandoffUncheckedCreateWithoutFromReceiptInput[]
    connectOrCreate?: TriTrackHandoffCreateOrConnectWithoutFromReceiptInput | TriTrackHandoffCreateOrConnectWithoutFromReceiptInput[]
    createMany?: TriTrackHandoffCreateManyFromReceiptInputEnvelope
    connect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
  }

  export type TriTrackHandoffCreateNestedManyWithoutToReceiptInput = {
    create?: XOR<TriTrackHandoffCreateWithoutToReceiptInput, TriTrackHandoffUncheckedCreateWithoutToReceiptInput> | TriTrackHandoffCreateWithoutToReceiptInput[] | TriTrackHandoffUncheckedCreateWithoutToReceiptInput[]
    connectOrCreate?: TriTrackHandoffCreateOrConnectWithoutToReceiptInput | TriTrackHandoffCreateOrConnectWithoutToReceiptInput[]
    createMany?: TriTrackHandoffCreateManyToReceiptInputEnvelope
    connect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
  }

  export type TriTrackHandoffUncheckedCreateNestedManyWithoutFromReceiptInput = {
    create?: XOR<TriTrackHandoffCreateWithoutFromReceiptInput, TriTrackHandoffUncheckedCreateWithoutFromReceiptInput> | TriTrackHandoffCreateWithoutFromReceiptInput[] | TriTrackHandoffUncheckedCreateWithoutFromReceiptInput[]
    connectOrCreate?: TriTrackHandoffCreateOrConnectWithoutFromReceiptInput | TriTrackHandoffCreateOrConnectWithoutFromReceiptInput[]
    createMany?: TriTrackHandoffCreateManyFromReceiptInputEnvelope
    connect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
  }

  export type TriTrackHandoffUncheckedCreateNestedManyWithoutToReceiptInput = {
    create?: XOR<TriTrackHandoffCreateWithoutToReceiptInput, TriTrackHandoffUncheckedCreateWithoutToReceiptInput> | TriTrackHandoffCreateWithoutToReceiptInput[] | TriTrackHandoffUncheckedCreateWithoutToReceiptInput[]
    connectOrCreate?: TriTrackHandoffCreateOrConnectWithoutToReceiptInput | TriTrackHandoffCreateOrConnectWithoutToReceiptInput[]
    createMany?: TriTrackHandoffCreateManyToReceiptInputEnvelope
    connect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
  }

  export type EnumReceiptTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReceiptType
  }

  export type NullableEnumTrackTypeFieldUpdateOperationsInput = {
    set?: $Enums.TrackType | null
  }

  export type UserUpdateOneWithoutBenReceiptsNestedInput = {
    create?: XOR<UserCreateWithoutBenReceiptsInput, UserUncheckedCreateWithoutBenReceiptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBenReceiptsInput
    upsert?: UserUpsertWithoutBenReceiptsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBenReceiptsInput, UserUpdateWithoutBenReceiptsInput>, UserUncheckedUpdateWithoutBenReceiptsInput>
  }

  export type TriTrackHandoffUpdateManyWithoutFromReceiptNestedInput = {
    create?: XOR<TriTrackHandoffCreateWithoutFromReceiptInput, TriTrackHandoffUncheckedCreateWithoutFromReceiptInput> | TriTrackHandoffCreateWithoutFromReceiptInput[] | TriTrackHandoffUncheckedCreateWithoutFromReceiptInput[]
    connectOrCreate?: TriTrackHandoffCreateOrConnectWithoutFromReceiptInput | TriTrackHandoffCreateOrConnectWithoutFromReceiptInput[]
    upsert?: TriTrackHandoffUpsertWithWhereUniqueWithoutFromReceiptInput | TriTrackHandoffUpsertWithWhereUniqueWithoutFromReceiptInput[]
    createMany?: TriTrackHandoffCreateManyFromReceiptInputEnvelope
    set?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    disconnect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    delete?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    connect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    update?: TriTrackHandoffUpdateWithWhereUniqueWithoutFromReceiptInput | TriTrackHandoffUpdateWithWhereUniqueWithoutFromReceiptInput[]
    updateMany?: TriTrackHandoffUpdateManyWithWhereWithoutFromReceiptInput | TriTrackHandoffUpdateManyWithWhereWithoutFromReceiptInput[]
    deleteMany?: TriTrackHandoffScalarWhereInput | TriTrackHandoffScalarWhereInput[]
  }

  export type TriTrackHandoffUpdateManyWithoutToReceiptNestedInput = {
    create?: XOR<TriTrackHandoffCreateWithoutToReceiptInput, TriTrackHandoffUncheckedCreateWithoutToReceiptInput> | TriTrackHandoffCreateWithoutToReceiptInput[] | TriTrackHandoffUncheckedCreateWithoutToReceiptInput[]
    connectOrCreate?: TriTrackHandoffCreateOrConnectWithoutToReceiptInput | TriTrackHandoffCreateOrConnectWithoutToReceiptInput[]
    upsert?: TriTrackHandoffUpsertWithWhereUniqueWithoutToReceiptInput | TriTrackHandoffUpsertWithWhereUniqueWithoutToReceiptInput[]
    createMany?: TriTrackHandoffCreateManyToReceiptInputEnvelope
    set?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    disconnect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    delete?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    connect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    update?: TriTrackHandoffUpdateWithWhereUniqueWithoutToReceiptInput | TriTrackHandoffUpdateWithWhereUniqueWithoutToReceiptInput[]
    updateMany?: TriTrackHandoffUpdateManyWithWhereWithoutToReceiptInput | TriTrackHandoffUpdateManyWithWhereWithoutToReceiptInput[]
    deleteMany?: TriTrackHandoffScalarWhereInput | TriTrackHandoffScalarWhereInput[]
  }

  export type TriTrackHandoffUncheckedUpdateManyWithoutFromReceiptNestedInput = {
    create?: XOR<TriTrackHandoffCreateWithoutFromReceiptInput, TriTrackHandoffUncheckedCreateWithoutFromReceiptInput> | TriTrackHandoffCreateWithoutFromReceiptInput[] | TriTrackHandoffUncheckedCreateWithoutFromReceiptInput[]
    connectOrCreate?: TriTrackHandoffCreateOrConnectWithoutFromReceiptInput | TriTrackHandoffCreateOrConnectWithoutFromReceiptInput[]
    upsert?: TriTrackHandoffUpsertWithWhereUniqueWithoutFromReceiptInput | TriTrackHandoffUpsertWithWhereUniqueWithoutFromReceiptInput[]
    createMany?: TriTrackHandoffCreateManyFromReceiptInputEnvelope
    set?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    disconnect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    delete?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    connect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    update?: TriTrackHandoffUpdateWithWhereUniqueWithoutFromReceiptInput | TriTrackHandoffUpdateWithWhereUniqueWithoutFromReceiptInput[]
    updateMany?: TriTrackHandoffUpdateManyWithWhereWithoutFromReceiptInput | TriTrackHandoffUpdateManyWithWhereWithoutFromReceiptInput[]
    deleteMany?: TriTrackHandoffScalarWhereInput | TriTrackHandoffScalarWhereInput[]
  }

  export type TriTrackHandoffUncheckedUpdateManyWithoutToReceiptNestedInput = {
    create?: XOR<TriTrackHandoffCreateWithoutToReceiptInput, TriTrackHandoffUncheckedCreateWithoutToReceiptInput> | TriTrackHandoffCreateWithoutToReceiptInput[] | TriTrackHandoffUncheckedCreateWithoutToReceiptInput[]
    connectOrCreate?: TriTrackHandoffCreateOrConnectWithoutToReceiptInput | TriTrackHandoffCreateOrConnectWithoutToReceiptInput[]
    upsert?: TriTrackHandoffUpsertWithWhereUniqueWithoutToReceiptInput | TriTrackHandoffUpsertWithWhereUniqueWithoutToReceiptInput[]
    createMany?: TriTrackHandoffCreateManyToReceiptInputEnvelope
    set?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    disconnect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    delete?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    connect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    update?: TriTrackHandoffUpdateWithWhereUniqueWithoutToReceiptInput | TriTrackHandoffUpdateWithWhereUniqueWithoutToReceiptInput[]
    updateMany?: TriTrackHandoffUpdateManyWithWhereWithoutToReceiptInput | TriTrackHandoffUpdateManyWithWhereWithoutToReceiptInput[]
    deleteMany?: TriTrackHandoffScalarWhereInput | TriTrackHandoffScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBenSessionsInput = {
    create?: XOR<UserCreateWithoutBenSessionsInput, UserUncheckedCreateWithoutBenSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBenSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBenSessionsNestedInput = {
    create?: XOR<UserCreateWithoutBenSessionsInput, UserUncheckedCreateWithoutBenSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBenSessionsInput
    upsert?: UserUpsertWithoutBenSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBenSessionsInput, UserUpdateWithoutBenSessionsInput>, UserUncheckedUpdateWithoutBenSessionsInput>
  }

  export type BENReceiptCreateNestedOneWithoutHandoffsFromInput = {
    create?: XOR<BENReceiptCreateWithoutHandoffsFromInput, BENReceiptUncheckedCreateWithoutHandoffsFromInput>
    connectOrCreate?: BENReceiptCreateOrConnectWithoutHandoffsFromInput
    connect?: BENReceiptWhereUniqueInput
  }

  export type BENReceiptCreateNestedOneWithoutHandoffsToInput = {
    create?: XOR<BENReceiptCreateWithoutHandoffsToInput, BENReceiptUncheckedCreateWithoutHandoffsToInput>
    connectOrCreate?: BENReceiptCreateOrConnectWithoutHandoffsToInput
    connect?: BENReceiptWhereUniqueInput
  }

  export type EnumTrackTypeFieldUpdateOperationsInput = {
    set?: $Enums.TrackType
  }

  export type EnumHandoffStatusFieldUpdateOperationsInput = {
    set?: $Enums.HandoffStatus
  }

  export type BENReceiptUpdateOneRequiredWithoutHandoffsFromNestedInput = {
    create?: XOR<BENReceiptCreateWithoutHandoffsFromInput, BENReceiptUncheckedCreateWithoutHandoffsFromInput>
    connectOrCreate?: BENReceiptCreateOrConnectWithoutHandoffsFromInput
    upsert?: BENReceiptUpsertWithoutHandoffsFromInput
    connect?: BENReceiptWhereUniqueInput
    update?: XOR<XOR<BENReceiptUpdateToOneWithWhereWithoutHandoffsFromInput, BENReceiptUpdateWithoutHandoffsFromInput>, BENReceiptUncheckedUpdateWithoutHandoffsFromInput>
  }

  export type BENReceiptUpdateOneWithoutHandoffsToNestedInput = {
    create?: XOR<BENReceiptCreateWithoutHandoffsToInput, BENReceiptUncheckedCreateWithoutHandoffsToInput>
    connectOrCreate?: BENReceiptCreateOrConnectWithoutHandoffsToInput
    upsert?: BENReceiptUpsertWithoutHandoffsToInput
    disconnect?: BENReceiptWhereInput | boolean
    delete?: BENReceiptWhereInput | boolean
    connect?: BENReceiptWhereUniqueInput
    update?: XOR<XOR<BENReceiptUpdateToOneWithWhereWithoutHandoffsToInput, BENReceiptUpdateWithoutHandoffsToInput>, BENReceiptUncheckedUpdateWithoutHandoffsToInput>
  }

  export type UserCreateNestedOneWithoutZscansInput = {
    create?: XOR<UserCreateWithoutZscansInput, UserUncheckedCreateWithoutZscansInput>
    connectOrCreate?: UserCreateOrConnectWithoutZscansInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutZscansNestedInput = {
    create?: XOR<UserCreateWithoutZscansInput, UserUncheckedCreateWithoutZscansInput>
    connectOrCreate?: UserCreateOrConnectWithoutZscansInput
    upsert?: UserUpsertWithoutZscansInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutZscansInput, UserUpdateWithoutZscansInput>, UserUncheckedUpdateWithoutZscansInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumUserTierFilter<$PrismaModel = never> = {
    equals?: $Enums.UserTier | EnumUserTierFieldRefInput<$PrismaModel>
    in?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTierFilter<$PrismaModel> | $Enums.UserTier
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumBENPersonaFilter<$PrismaModel = never> = {
    equals?: $Enums.BENPersona | EnumBENPersonaFieldRefInput<$PrismaModel>
    in?: $Enums.BENPersona[] | ListEnumBENPersonaFieldRefInput<$PrismaModel>
    notIn?: $Enums.BENPersona[] | ListEnumBENPersonaFieldRefInput<$PrismaModel>
    not?: NestedEnumBENPersonaFilter<$PrismaModel> | $Enums.BENPersona
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserTier | EnumUserTierFieldRefInput<$PrismaModel>
    in?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTierWithAggregatesFilter<$PrismaModel> | $Enums.UserTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTierFilter<$PrismaModel>
    _max?: NestedEnumUserTierFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumBENPersonaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BENPersona | EnumBENPersonaFieldRefInput<$PrismaModel>
    in?: $Enums.BENPersona[] | ListEnumBENPersonaFieldRefInput<$PrismaModel>
    notIn?: $Enums.BENPersona[] | ListEnumBENPersonaFieldRefInput<$PrismaModel>
    not?: NestedEnumBENPersonaWithAggregatesFilter<$PrismaModel> | $Enums.BENPersona
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBENPersonaFilter<$PrismaModel>
    _max?: NestedEnumBENPersonaFilter<$PrismaModel>
  }

  export type NestedEnumPlanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeFilter<$PrismaModel> | $Enums.PlanType
  }

  export type NestedEnumOrgStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgStatus | EnumOrgStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrgStatus[] | ListEnumOrgStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgStatus[] | ListEnumOrgStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgStatusFilter<$PrismaModel> | $Enums.OrgStatus
  }

  export type NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTypeFilter<$PrismaModel>
    _max?: NestedEnumPlanTypeFilter<$PrismaModel>
  }

  export type NestedEnumOrgStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgStatus | EnumOrgStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrgStatus[] | ListEnumOrgStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgStatus[] | ListEnumOrgStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrgStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrgStatusFilter<$PrismaModel>
    _max?: NestedEnumOrgStatusFilter<$PrismaModel>
  }

  export type NestedEnumTeamRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleFilter<$PrismaModel> | $Enums.TeamRole
  }

  export type NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel> | $Enums.TeamRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamRoleFilter<$PrismaModel>
    _max?: NestedEnumTeamRoleFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAuditCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditCategory | EnumAuditCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AuditCategory[] | ListEnumAuditCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditCategory[] | ListEnumAuditCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditCategoryFilter<$PrismaModel> | $Enums.AuditCategory
  }

  export type NestedEnumAuditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusFilter<$PrismaModel> | $Enums.AuditStatus
  }

  export type NestedEnumAuditCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditCategory | EnumAuditCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AuditCategory[] | ListEnumAuditCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditCategory[] | ListEnumAuditCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AuditCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditCategoryFilter<$PrismaModel>
    _max?: NestedEnumAuditCategoryFilter<$PrismaModel>
  }

  export type NestedEnumAuditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditStatusFilter<$PrismaModel>
    _max?: NestedEnumAuditStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeFilter<$PrismaModel> | $Enums.FeedbackType
  }

  export type NestedEnumFeedbackCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackCategory | EnumFeedbackCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackCategoryFilter<$PrismaModel> | $Enums.FeedbackCategory
  }

  export type NestedEnumFeedbackPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackPriority | EnumFeedbackPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackPriorityFilter<$PrismaModel> | $Enums.FeedbackPriority
  }

  export type NestedEnumFeedbackStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackStatus | EnumFeedbackStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackStatusFilter<$PrismaModel> | $Enums.FeedbackStatus
  }

  export type NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedbackTypeFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackCategory | EnumFeedbackCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackCategoryFilter<$PrismaModel>
    _max?: NestedEnumFeedbackCategoryFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackPriority | EnumFeedbackPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackPriorityWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackPriorityFilter<$PrismaModel>
    _max?: NestedEnumFeedbackPriorityFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackStatus | EnumFeedbackStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackStatusWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackStatusFilter<$PrismaModel>
    _max?: NestedEnumFeedbackStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumSecurityEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SecurityEventType | EnumSecurityEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSecurityEventTypeFilter<$PrismaModel> | $Enums.SecurityEventType
  }

  export type NestedEnumSecuritySeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.SecuritySeverity | EnumSecuritySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSecuritySeverityFilter<$PrismaModel> | $Enums.SecuritySeverity
  }

  export type NestedEnumSecurityEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SecurityEventType | EnumSecurityEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecurityEventType[] | ListEnumSecurityEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSecurityEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.SecurityEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSecurityEventTypeFilter<$PrismaModel>
    _max?: NestedEnumSecurityEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumSecuritySeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SecuritySeverity | EnumSecuritySeverityFieldRefInput<$PrismaModel>
    in?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecuritySeverity[] | ListEnumSecuritySeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSecuritySeverityWithAggregatesFilter<$PrismaModel> | $Enums.SecuritySeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSecuritySeverityFilter<$PrismaModel>
    _max?: NestedEnumSecuritySeverityFilter<$PrismaModel>
  }

  export type NestedEnumSSOProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.SSOProvider | EnumSSOProviderFieldRefInput<$PrismaModel>
    in?: $Enums.SSOProvider[] | ListEnumSSOProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.SSOProvider[] | ListEnumSSOProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumSSOProviderFilter<$PrismaModel> | $Enums.SSOProvider
  }

  export type NestedEnumSSOProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SSOProvider | EnumSSOProviderFieldRefInput<$PrismaModel>
    in?: $Enums.SSOProvider[] | ListEnumSSOProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.SSOProvider[] | ListEnumSSOProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumSSOProviderWithAggregatesFilter<$PrismaModel> | $Enums.SSOProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSSOProviderFilter<$PrismaModel>
    _max?: NestedEnumSSOProviderFilter<$PrismaModel>
  }

  export type NestedEnumSSOEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SSOEventType | EnumSSOEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SSOEventType[] | ListEnumSSOEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SSOEventType[] | ListEnumSSOEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSSOEventTypeFilter<$PrismaModel> | $Enums.SSOEventType
  }

  export type NestedEnumSSOEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SSOEventType | EnumSSOEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SSOEventType[] | ListEnumSSOEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SSOEventType[] | ListEnumSSOEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSSOEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.SSOEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSSOEventTypeFilter<$PrismaModel>
    _max?: NestedEnumSSOEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumReceiptTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReceiptType | EnumReceiptTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReceiptType[] | ListEnumReceiptTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReceiptType[] | ListEnumReceiptTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReceiptTypeFilter<$PrismaModel> | $Enums.ReceiptType
  }

  export type NestedEnumTrackTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackType | EnumTrackTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTrackTypeNullableFilter<$PrismaModel> | $Enums.TrackType | null
  }

  export type NestedEnumReceiptTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReceiptType | EnumReceiptTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReceiptType[] | ListEnumReceiptTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReceiptType[] | ListEnumReceiptTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReceiptTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReceiptType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReceiptTypeFilter<$PrismaModel>
    _max?: NestedEnumReceiptTypeFilter<$PrismaModel>
  }

  export type NestedEnumTrackTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackType | EnumTrackTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTrackTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TrackType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTrackTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumTrackTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTrackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackType | EnumTrackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrackTypeFilter<$PrismaModel> | $Enums.TrackType
  }

  export type NestedEnumHandoffStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HandoffStatus | EnumHandoffStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HandoffStatus[] | ListEnumHandoffStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HandoffStatus[] | ListEnumHandoffStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHandoffStatusFilter<$PrismaModel> | $Enums.HandoffStatus
  }

  export type NestedEnumTrackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackType | EnumTrackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrackTypeWithAggregatesFilter<$PrismaModel> | $Enums.TrackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrackTypeFilter<$PrismaModel>
    _max?: NestedEnumTrackTypeFilter<$PrismaModel>
  }

  export type NestedEnumHandoffStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HandoffStatus | EnumHandoffStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HandoffStatus[] | ListEnumHandoffStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HandoffStatus[] | ListEnumHandoffStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHandoffStatusWithAggregatesFilter<$PrismaModel> | $Enums.HandoffStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHandoffStatusFilter<$PrismaModel>
    _max?: NestedEnumHandoffStatusFilter<$PrismaModel>
  }

  export type OrganizationCreateWithoutUsersInput = {
    name: string
    plan?: $Enums.PlanType
    status?: $Enums.OrgStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamCreateNestedManyWithoutOrganizationInput
    ssoConfigs?: SSOConfigurationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    plan?: $Enums.PlanType
    status?: $Enums.OrgStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutOrganizationInput
    ssoConfigs?: SSOConfigurationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutUsersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
  }

  export type SessionCreateWithoutUserInput = {
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: number
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditRecordCreateWithoutUserInput = {
    action: string
    category: $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AuditStatus
    lamport: number
    hashPointer?: string | null
    createdAt?: Date | string
  }

  export type AuditRecordUncheckedCreateWithoutUserInput = {
    id?: number
    action: string
    category: $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AuditStatus
    lamport: number
    hashPointer?: string | null
    createdAt?: Date | string
  }

  export type AuditRecordCreateOrConnectWithoutUserInput = {
    where: AuditRecordWhereUniqueInput
    create: XOR<AuditRecordCreateWithoutUserInput, AuditRecordUncheckedCreateWithoutUserInput>
  }

  export type AuditRecordCreateManyUserInputEnvelope = {
    data: AuditRecordCreateManyUserInput | AuditRecordCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TeamMemberCreateWithoutUserInput = {
    role?: $Enums.TeamRole
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
  }

  export type TeamMemberUncheckedCreateWithoutUserInput = {
    id?: number
    teamId: number
    role?: $Enums.TeamRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberCreateManyUserInputEnvelope = {
    data: TeamMemberCreateManyUserInput | TeamMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationPreferenceCreateWithoutUserInput = {
    emailEnabled?: boolean
    testComplete?: boolean
    batchComplete?: boolean
    scheduledTestComplete?: boolean
    alertsEnabled?: boolean
    lowScoreThreshold?: number
    highScoreThreshold?: number
    scoreDropAlert?: boolean
    witnessFailureAlert?: boolean
    dailyReport?: boolean
    weeklyReport?: boolean
    monthlyReport?: boolean
    reportTime?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUncheckedCreateWithoutUserInput = {
    id?: number
    emailEnabled?: boolean
    testComplete?: boolean
    batchComplete?: boolean
    scheduledTestComplete?: boolean
    alertsEnabled?: boolean
    lowScoreThreshold?: number
    highScoreThreshold?: number
    scoreDropAlert?: boolean
    witnessFailureAlert?: boolean
    dailyReport?: boolean
    weeklyReport?: boolean
    monthlyReport?: boolean
    reportTime?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceCreateOrConnectWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type BudgetCreateWithoutUserInput = {
    limit: number
    period?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetUncheckedCreateWithoutUserInput = {
    id?: number
    limit: number
    period?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCreateOrConnectWithoutUserInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput>
  }

  export type BudgetCreateManyUserInputEnvelope = {
    data: BudgetCreateManyUserInput | BudgetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RegressionBaselineCreateWithoutUserInput = {
    modelName: string
    modelVersion?: string | null
    testType: string
    avgResponseTime: number
    avgCost: number
    avgQualityScore: number
    avgAccuracy: number
    successRate: number
    alertThreshold?: number
    sampleSize: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegressionBaselineUncheckedCreateWithoutUserInput = {
    id?: number
    modelName: string
    modelVersion?: string | null
    testType: string
    avgResponseTime: number
    avgCost: number
    avgQualityScore: number
    avgAccuracy: number
    successRate: number
    alertThreshold?: number
    sampleSize: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegressionBaselineCreateOrConnectWithoutUserInput = {
    where: RegressionBaselineWhereUniqueInput
    create: XOR<RegressionBaselineCreateWithoutUserInput, RegressionBaselineUncheckedCreateWithoutUserInput>
  }

  export type RegressionBaselineCreateManyUserInputEnvelope = {
    data: RegressionBaselineCreateManyUserInput | RegressionBaselineCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutUserInput = {
    type: $Enums.FeedbackType
    category: $Enums.FeedbackCategory
    priority?: $Enums.FeedbackPriority
    subject: string
    message: string
    url?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachmentUrls?: FeedbackCreateattachmentUrlsInput | string[]
    status?: $Enums.FeedbackStatus
    assignedTo?: number | null
    response?: string | null
    respondedAt?: Date | string | null
    respondedBy?: number | null
    sentiment?: string | null
    sentimentScore?: number | null
    upvotes?: number
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type FeedbackUncheckedCreateWithoutUserInput = {
    id?: number
    type: $Enums.FeedbackType
    category: $Enums.FeedbackCategory
    priority?: $Enums.FeedbackPriority
    subject: string
    message: string
    url?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachmentUrls?: FeedbackCreateattachmentUrlsInput | string[]
    status?: $Enums.FeedbackStatus
    assignedTo?: number | null
    response?: string | null
    respondedAt?: Date | string | null
    respondedBy?: number | null
    sentiment?: string | null
    sentimentScore?: number | null
    upvotes?: number
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type FeedbackCreateOrConnectWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput>
  }

  export type FeedbackCreateManyUserInputEnvelope = {
    data: FeedbackCreateManyUserInput | FeedbackCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BENReceiptCreateWithoutUserInput = {
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp?: Date | string
    persona?: $Enums.BENPersona
    track?: $Enums.TrackType | null
    payload: JsonNullValueInput | InputJsonValue
    digest: string
    previousDigest?: string | null
    baselineDigest?: string | null
    witnessModel?: string | null
    witnessSignature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    handoffsFrom?: TriTrackHandoffCreateNestedManyWithoutFromReceiptInput
    handoffsTo?: TriTrackHandoffCreateNestedManyWithoutToReceiptInput
  }

  export type BENReceiptUncheckedCreateWithoutUserInput = {
    id?: number
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp?: Date | string
    persona?: $Enums.BENPersona
    track?: $Enums.TrackType | null
    payload: JsonNullValueInput | InputJsonValue
    digest: string
    previousDigest?: string | null
    baselineDigest?: string | null
    witnessModel?: string | null
    witnessSignature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    handoffsFrom?: TriTrackHandoffUncheckedCreateNestedManyWithoutFromReceiptInput
    handoffsTo?: TriTrackHandoffUncheckedCreateNestedManyWithoutToReceiptInput
  }

  export type BENReceiptCreateOrConnectWithoutUserInput = {
    where: BENReceiptWhereUniqueInput
    create: XOR<BENReceiptCreateWithoutUserInput, BENReceiptUncheckedCreateWithoutUserInput>
  }

  export type BENReceiptCreateManyUserInputEnvelope = {
    data: BENReceiptCreateManyUserInput | BENReceiptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BENSessionCreateWithoutUserInput = {
    persona: $Enums.BENPersona
    priority: number
    locked?: boolean
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    startLamport: number
    endLamport?: number | null
    switchReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BENSessionUncheckedCreateWithoutUserInput = {
    id?: number
    persona: $Enums.BENPersona
    priority: number
    locked?: boolean
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    startLamport: number
    endLamport?: number | null
    switchReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BENSessionCreateOrConnectWithoutUserInput = {
    where: BENSessionWhereUniqueInput
    create: XOR<BENSessionCreateWithoutUserInput, BENSessionUncheckedCreateWithoutUserInput>
  }

  export type BENSessionCreateManyUserInputEnvelope = {
    data: BENSessionCreateManyUserInput | BENSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ZScanVerificationCreateWithoutUserInput = {
    totalRules: number
    passed: number
    warnings: number
    critical: number
    results: JsonNullValueInput | InputJsonValue
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ZScanVerificationUncheckedCreateWithoutUserInput = {
    id?: number
    totalRules: number
    passed: number
    warnings: number
    critical: number
    results: JsonNullValueInput | InputJsonValue
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ZScanVerificationCreateOrConnectWithoutUserInput = {
    where: ZScanVerificationWhereUniqueInput
    create: XOR<ZScanVerificationCreateWithoutUserInput, ZScanVerificationUncheckedCreateWithoutUserInput>
  }

  export type ZScanVerificationCreateManyUserInputEnvelope = {
    data: ZScanVerificationCreateManyUserInput | ZScanVerificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutUsersInput = {
    update: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUsersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type OrganizationUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    status?: EnumOrgStatusFieldUpdateOperationsInput | $Enums.OrgStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUpdateManyWithoutOrganizationNestedInput
    ssoConfigs?: SSOConfigurationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    status?: EnumOrgStatusFieldUpdateOperationsInput | $Enums.OrgStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutOrganizationNestedInput
    ssoConfigs?: SSOConfigurationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: IntFilter<"Session"> | number
    userId?: IntFilter<"Session"> | number
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    userAgent?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    lastUsedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type AuditRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditRecordWhereUniqueInput
    update: XOR<AuditRecordUpdateWithoutUserInput, AuditRecordUncheckedUpdateWithoutUserInput>
    create: XOR<AuditRecordCreateWithoutUserInput, AuditRecordUncheckedCreateWithoutUserInput>
  }

  export type AuditRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditRecordWhereUniqueInput
    data: XOR<AuditRecordUpdateWithoutUserInput, AuditRecordUncheckedUpdateWithoutUserInput>
  }

  export type AuditRecordUpdateManyWithWhereWithoutUserInput = {
    where: AuditRecordScalarWhereInput
    data: XOR<AuditRecordUpdateManyMutationInput, AuditRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditRecordScalarWhereInput = {
    AND?: AuditRecordScalarWhereInput | AuditRecordScalarWhereInput[]
    OR?: AuditRecordScalarWhereInput[]
    NOT?: AuditRecordScalarWhereInput | AuditRecordScalarWhereInput[]
    id?: IntFilter<"AuditRecord"> | number
    userId?: IntFilter<"AuditRecord"> | number
    action?: StringFilter<"AuditRecord"> | string
    category?: EnumAuditCategoryFilter<"AuditRecord"> | $Enums.AuditCategory
    details?: JsonNullableFilter<"AuditRecord">
    metadata?: JsonNullableFilter<"AuditRecord">
    status?: EnumAuditStatusFilter<"AuditRecord"> | $Enums.AuditStatus
    lamport?: IntFilter<"AuditRecord"> | number
    hashPointer?: StringNullableFilter<"AuditRecord"> | string | null
    createdAt?: DateTimeFilter<"AuditRecord"> | Date | string
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutUserInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamMemberScalarWhereInput = {
    AND?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    OR?: TeamMemberScalarWhereInput[]
    NOT?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    id?: IntFilter<"TeamMember"> | number
    teamId?: IntFilter<"TeamMember"> | number
    userId?: IntFilter<"TeamMember"> | number
    role?: EnumTeamRoleFilter<"TeamMember"> | $Enums.TeamRole
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"TeamMember"> | Date | string
  }

  export type NotificationPreferenceUpsertWithoutUserInput = {
    update: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    where?: NotificationPreferenceWhereInput
  }

  export type NotificationPreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationPreferenceWhereInput
    data: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateWithoutUserInput = {
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    testComplete?: BoolFieldUpdateOperationsInput | boolean
    batchComplete?: BoolFieldUpdateOperationsInput | boolean
    scheduledTestComplete?: BoolFieldUpdateOperationsInput | boolean
    alertsEnabled?: BoolFieldUpdateOperationsInput | boolean
    lowScoreThreshold?: FloatFieldUpdateOperationsInput | number
    highScoreThreshold?: FloatFieldUpdateOperationsInput | number
    scoreDropAlert?: BoolFieldUpdateOperationsInput | boolean
    witnessFailureAlert?: BoolFieldUpdateOperationsInput | boolean
    dailyReport?: BoolFieldUpdateOperationsInput | boolean
    weeklyReport?: BoolFieldUpdateOperationsInput | boolean
    monthlyReport?: BoolFieldUpdateOperationsInput | boolean
    reportTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    testComplete?: BoolFieldUpdateOperationsInput | boolean
    batchComplete?: BoolFieldUpdateOperationsInput | boolean
    scheduledTestComplete?: BoolFieldUpdateOperationsInput | boolean
    alertsEnabled?: BoolFieldUpdateOperationsInput | boolean
    lowScoreThreshold?: FloatFieldUpdateOperationsInput | number
    highScoreThreshold?: FloatFieldUpdateOperationsInput | number
    scoreDropAlert?: BoolFieldUpdateOperationsInput | boolean
    witnessFailureAlert?: BoolFieldUpdateOperationsInput | boolean
    dailyReport?: BoolFieldUpdateOperationsInput | boolean
    weeklyReport?: BoolFieldUpdateOperationsInput | boolean
    monthlyReport?: BoolFieldUpdateOperationsInput | boolean
    reportTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUpsertWithWhereUniqueWithoutUserInput = {
    where: BudgetWhereUniqueInput
    update: XOR<BudgetUpdateWithoutUserInput, BudgetUncheckedUpdateWithoutUserInput>
    create: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput>
  }

  export type BudgetUpdateWithWhereUniqueWithoutUserInput = {
    where: BudgetWhereUniqueInput
    data: XOR<BudgetUpdateWithoutUserInput, BudgetUncheckedUpdateWithoutUserInput>
  }

  export type BudgetUpdateManyWithWhereWithoutUserInput = {
    where: BudgetScalarWhereInput
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyWithoutUserInput>
  }

  export type BudgetScalarWhereInput = {
    AND?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    OR?: BudgetScalarWhereInput[]
    NOT?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    id?: IntFilter<"Budget"> | number
    userId?: IntFilter<"Budget"> | number
    limit?: FloatFilter<"Budget"> | number
    period?: StringFilter<"Budget"> | string
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
  }

  export type RegressionBaselineUpsertWithWhereUniqueWithoutUserInput = {
    where: RegressionBaselineWhereUniqueInput
    update: XOR<RegressionBaselineUpdateWithoutUserInput, RegressionBaselineUncheckedUpdateWithoutUserInput>
    create: XOR<RegressionBaselineCreateWithoutUserInput, RegressionBaselineUncheckedCreateWithoutUserInput>
  }

  export type RegressionBaselineUpdateWithWhereUniqueWithoutUserInput = {
    where: RegressionBaselineWhereUniqueInput
    data: XOR<RegressionBaselineUpdateWithoutUserInput, RegressionBaselineUncheckedUpdateWithoutUserInput>
  }

  export type RegressionBaselineUpdateManyWithWhereWithoutUserInput = {
    where: RegressionBaselineScalarWhereInput
    data: XOR<RegressionBaselineUpdateManyMutationInput, RegressionBaselineUncheckedUpdateManyWithoutUserInput>
  }

  export type RegressionBaselineScalarWhereInput = {
    AND?: RegressionBaselineScalarWhereInput | RegressionBaselineScalarWhereInput[]
    OR?: RegressionBaselineScalarWhereInput[]
    NOT?: RegressionBaselineScalarWhereInput | RegressionBaselineScalarWhereInput[]
    id?: IntFilter<"RegressionBaseline"> | number
    userId?: IntFilter<"RegressionBaseline"> | number
    modelName?: StringFilter<"RegressionBaseline"> | string
    modelVersion?: StringNullableFilter<"RegressionBaseline"> | string | null
    testType?: StringFilter<"RegressionBaseline"> | string
    avgResponseTime?: FloatFilter<"RegressionBaseline"> | number
    avgCost?: FloatFilter<"RegressionBaseline"> | number
    avgQualityScore?: FloatFilter<"RegressionBaseline"> | number
    avgAccuracy?: FloatFilter<"RegressionBaseline"> | number
    successRate?: FloatFilter<"RegressionBaseline"> | number
    alertThreshold?: FloatFilter<"RegressionBaseline"> | number
    sampleSize?: IntFilter<"RegressionBaseline"> | number
    isActive?: BoolFilter<"RegressionBaseline"> | boolean
    createdAt?: DateTimeFilter<"RegressionBaseline"> | Date | string
    updatedAt?: DateTimeFilter<"RegressionBaseline"> | Date | string
  }

  export type FeedbackUpsertWithWhereUniqueWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutUserInput, FeedbackUncheckedUpdateWithoutUserInput>
    create: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutUserInput, FeedbackUncheckedUpdateWithoutUserInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutUserInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutUserInput>
  }

  export type FeedbackScalarWhereInput = {
    AND?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    OR?: FeedbackScalarWhereInput[]
    NOT?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    id?: IntFilter<"Feedback"> | number
    userId?: IntFilter<"Feedback"> | number
    type?: EnumFeedbackTypeFilter<"Feedback"> | $Enums.FeedbackType
    category?: EnumFeedbackCategoryFilter<"Feedback"> | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityFilter<"Feedback"> | $Enums.FeedbackPriority
    subject?: StringFilter<"Feedback"> | string
    message?: StringFilter<"Feedback"> | string
    url?: StringNullableFilter<"Feedback"> | string | null
    userAgent?: StringNullableFilter<"Feedback"> | string | null
    metadata?: JsonNullableFilter<"Feedback">
    attachmentUrls?: StringNullableListFilter<"Feedback">
    status?: EnumFeedbackStatusFilter<"Feedback"> | $Enums.FeedbackStatus
    assignedTo?: IntNullableFilter<"Feedback"> | number | null
    response?: StringNullableFilter<"Feedback"> | string | null
    respondedAt?: DateTimeNullableFilter<"Feedback"> | Date | string | null
    respondedBy?: IntNullableFilter<"Feedback"> | number | null
    sentiment?: StringNullableFilter<"Feedback"> | string | null
    sentimentScore?: FloatNullableFilter<"Feedback"> | number | null
    upvotes?: IntFilter<"Feedback"> | number
    isPublic?: BoolFilter<"Feedback"> | boolean
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeFilter<"Feedback"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Feedback"> | Date | string | null
  }

  export type BENReceiptUpsertWithWhereUniqueWithoutUserInput = {
    where: BENReceiptWhereUniqueInput
    update: XOR<BENReceiptUpdateWithoutUserInput, BENReceiptUncheckedUpdateWithoutUserInput>
    create: XOR<BENReceiptCreateWithoutUserInput, BENReceiptUncheckedCreateWithoutUserInput>
  }

  export type BENReceiptUpdateWithWhereUniqueWithoutUserInput = {
    where: BENReceiptWhereUniqueInput
    data: XOR<BENReceiptUpdateWithoutUserInput, BENReceiptUncheckedUpdateWithoutUserInput>
  }

  export type BENReceiptUpdateManyWithWhereWithoutUserInput = {
    where: BENReceiptScalarWhereInput
    data: XOR<BENReceiptUpdateManyMutationInput, BENReceiptUncheckedUpdateManyWithoutUserInput>
  }

  export type BENReceiptScalarWhereInput = {
    AND?: BENReceiptScalarWhereInput | BENReceiptScalarWhereInput[]
    OR?: BENReceiptScalarWhereInput[]
    NOT?: BENReceiptScalarWhereInput | BENReceiptScalarWhereInput[]
    id?: IntFilter<"BENReceipt"> | number
    receiptType?: EnumReceiptTypeFilter<"BENReceipt"> | $Enums.ReceiptType
    lamportClock?: IntFilter<"BENReceipt"> | number
    realTimestamp?: DateTimeFilter<"BENReceipt"> | Date | string
    userId?: IntNullableFilter<"BENReceipt"> | number | null
    persona?: EnumBENPersonaFilter<"BENReceipt"> | $Enums.BENPersona
    track?: EnumTrackTypeNullableFilter<"BENReceipt"> | $Enums.TrackType | null
    payload?: JsonFilter<"BENReceipt">
    digest?: StringFilter<"BENReceipt"> | string
    previousDigest?: StringNullableFilter<"BENReceipt"> | string | null
    baselineDigest?: StringNullableFilter<"BENReceipt"> | string | null
    witnessModel?: StringNullableFilter<"BENReceipt"> | string | null
    witnessSignature?: StringNullableFilter<"BENReceipt"> | string | null
    metadata?: JsonNullableFilter<"BENReceipt">
    createdAt?: DateTimeFilter<"BENReceipt"> | Date | string
  }

  export type BENSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: BENSessionWhereUniqueInput
    update: XOR<BENSessionUpdateWithoutUserInput, BENSessionUncheckedUpdateWithoutUserInput>
    create: XOR<BENSessionCreateWithoutUserInput, BENSessionUncheckedCreateWithoutUserInput>
  }

  export type BENSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: BENSessionWhereUniqueInput
    data: XOR<BENSessionUpdateWithoutUserInput, BENSessionUncheckedUpdateWithoutUserInput>
  }

  export type BENSessionUpdateManyWithWhereWithoutUserInput = {
    where: BENSessionScalarWhereInput
    data: XOR<BENSessionUpdateManyMutationInput, BENSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type BENSessionScalarWhereInput = {
    AND?: BENSessionScalarWhereInput | BENSessionScalarWhereInput[]
    OR?: BENSessionScalarWhereInput[]
    NOT?: BENSessionScalarWhereInput | BENSessionScalarWhereInput[]
    id?: IntFilter<"BENSession"> | number
    userId?: IntFilter<"BENSession"> | number
    persona?: EnumBENPersonaFilter<"BENSession"> | $Enums.BENPersona
    priority?: IntFilter<"BENSession"> | number
    locked?: BoolFilter<"BENSession"> | boolean
    startedAt?: DateTimeFilter<"BENSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"BENSession"> | Date | string | null
    duration?: IntNullableFilter<"BENSession"> | number | null
    startLamport?: IntFilter<"BENSession"> | number
    endLamport?: IntNullableFilter<"BENSession"> | number | null
    switchReason?: StringNullableFilter<"BENSession"> | string | null
    metadata?: JsonNullableFilter<"BENSession">
  }

  export type ZScanVerificationUpsertWithWhereUniqueWithoutUserInput = {
    where: ZScanVerificationWhereUniqueInput
    update: XOR<ZScanVerificationUpdateWithoutUserInput, ZScanVerificationUncheckedUpdateWithoutUserInput>
    create: XOR<ZScanVerificationCreateWithoutUserInput, ZScanVerificationUncheckedCreateWithoutUserInput>
  }

  export type ZScanVerificationUpdateWithWhereUniqueWithoutUserInput = {
    where: ZScanVerificationWhereUniqueInput
    data: XOR<ZScanVerificationUpdateWithoutUserInput, ZScanVerificationUncheckedUpdateWithoutUserInput>
  }

  export type ZScanVerificationUpdateManyWithWhereWithoutUserInput = {
    where: ZScanVerificationScalarWhereInput
    data: XOR<ZScanVerificationUpdateManyMutationInput, ZScanVerificationUncheckedUpdateManyWithoutUserInput>
  }

  export type ZScanVerificationScalarWhereInput = {
    AND?: ZScanVerificationScalarWhereInput | ZScanVerificationScalarWhereInput[]
    OR?: ZScanVerificationScalarWhereInput[]
    NOT?: ZScanVerificationScalarWhereInput | ZScanVerificationScalarWhereInput[]
    id?: IntFilter<"ZScanVerification"> | number
    userId?: IntNullableFilter<"ZScanVerification"> | number | null
    totalRules?: IntFilter<"ZScanVerification"> | number
    passed?: IntFilter<"ZScanVerification"> | number
    warnings?: IntFilter<"ZScanVerification"> | number
    critical?: IntFilter<"ZScanVerification"> | number
    results?: JsonFilter<"ZScanVerification">
    config?: JsonFilter<"ZScanVerification">
    createdAt?: DateTimeFilter<"ZScanVerification"> | Date | string
  }

  export type UserCreateWithoutOrganizationInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserCreateManyOrganizationInputEnvelope = {
    data: UserCreateManyOrganizationInput | UserCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutOrganizationInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutOrganizationInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutOrganizationInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutOrganizationInput, TeamUncheckedCreateWithoutOrganizationInput>
  }

  export type TeamCreateManyOrganizationInputEnvelope = {
    data: TeamCreateManyOrganizationInput | TeamCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type SSOConfigurationCreateWithoutOrganizationInput = {
    provider: $Enums.SSOProvider
    enabled?: boolean
    samlEntryPoint?: string | null
    samlIssuer?: string | null
    samlCert?: string | null
    samlCallbackUrl?: string | null
    samlLogoutUrl?: string | null
    oauthClientId?: string | null
    oauthClientSecret?: string | null
    oauthAuthUrl?: string | null
    oauthTokenUrl?: string | null
    oauthUserInfoUrl?: string | null
    oauthScopes?: SSOConfigurationCreateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationCreatedomainRestrictionInput | string[]
    jitProvisioning?: boolean
    defaultRole?: $Enums.Role
    defaultTier?: $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type SSOConfigurationUncheckedCreateWithoutOrganizationInput = {
    id?: number
    provider: $Enums.SSOProvider
    enabled?: boolean
    samlEntryPoint?: string | null
    samlIssuer?: string | null
    samlCert?: string | null
    samlCallbackUrl?: string | null
    samlLogoutUrl?: string | null
    oauthClientId?: string | null
    oauthClientSecret?: string | null
    oauthAuthUrl?: string | null
    oauthTokenUrl?: string | null
    oauthUserInfoUrl?: string | null
    oauthScopes?: SSOConfigurationCreateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationCreatedomainRestrictionInput | string[]
    jitProvisioning?: boolean
    defaultRole?: $Enums.Role
    defaultTier?: $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type SSOConfigurationCreateOrConnectWithoutOrganizationInput = {
    where: SSOConfigurationWhereUniqueInput
    create: XOR<SSOConfigurationCreateWithoutOrganizationInput, SSOConfigurationUncheckedCreateWithoutOrganizationInput>
  }

  export type SSOConfigurationCreateManyOrganizationInputEnvelope = {
    data: SSOConfigurationCreateManyOrganizationInput | SSOConfigurationCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
  }

  export type UserUpdateManyWithWhereWithoutOrganizationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    tier?: EnumUserTierFilter<"User"> | $Enums.UserTier
    permissions?: EnumPermissionNullableListFilter<"User">
    orgId?: IntNullableFilter<"User"> | number | null
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    backupCodes?: StringNullableListFilter<"User">
    failedLoginAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordChangedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    ssoProvider?: StringNullableFilter<"User"> | string | null
    ssoId?: StringNullableFilter<"User"> | string | null
    ssoMetadata?: JsonNullableFilter<"User">
    currentPersona?: EnumBENPersonaFilter<"User"> | $Enums.BENPersona
    personaLocked?: BoolFilter<"User"> | boolean
    lamportCounter?: IntFilter<"User"> | number
    lastReceiptId?: IntNullableFilter<"User"> | number | null
  }

  export type TeamUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutOrganizationInput, TeamUncheckedUpdateWithoutOrganizationInput>
    create: XOR<TeamCreateWithoutOrganizationInput, TeamUncheckedCreateWithoutOrganizationInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutOrganizationInput, TeamUncheckedUpdateWithoutOrganizationInput>
  }

  export type TeamUpdateManyWithWhereWithoutOrganizationInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: IntFilter<"Team"> | number
    name?: StringFilter<"Team"> | string
    orgId?: IntFilter<"Team"> | number
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
  }

  export type SSOConfigurationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: SSOConfigurationWhereUniqueInput
    update: XOR<SSOConfigurationUpdateWithoutOrganizationInput, SSOConfigurationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<SSOConfigurationCreateWithoutOrganizationInput, SSOConfigurationUncheckedCreateWithoutOrganizationInput>
  }

  export type SSOConfigurationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: SSOConfigurationWhereUniqueInput
    data: XOR<SSOConfigurationUpdateWithoutOrganizationInput, SSOConfigurationUncheckedUpdateWithoutOrganizationInput>
  }

  export type SSOConfigurationUpdateManyWithWhereWithoutOrganizationInput = {
    where: SSOConfigurationScalarWhereInput
    data: XOR<SSOConfigurationUpdateManyMutationInput, SSOConfigurationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type SSOConfigurationScalarWhereInput = {
    AND?: SSOConfigurationScalarWhereInput | SSOConfigurationScalarWhereInput[]
    OR?: SSOConfigurationScalarWhereInput[]
    NOT?: SSOConfigurationScalarWhereInput | SSOConfigurationScalarWhereInput[]
    id?: IntFilter<"SSOConfiguration"> | number
    orgId?: IntFilter<"SSOConfiguration"> | number
    provider?: EnumSSOProviderFilter<"SSOConfiguration"> | $Enums.SSOProvider
    enabled?: BoolFilter<"SSOConfiguration"> | boolean
    samlEntryPoint?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlIssuer?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlCert?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlCallbackUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlLogoutUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthClientId?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthClientSecret?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthAuthUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthTokenUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthUserInfoUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthScopes?: StringNullableListFilter<"SSOConfiguration">
    domainRestriction?: StringNullableListFilter<"SSOConfiguration">
    jitProvisioning?: BoolFilter<"SSOConfiguration"> | boolean
    defaultRole?: EnumRoleFilter<"SSOConfiguration"> | $Enums.Role
    defaultTier?: EnumUserTierFilter<"SSOConfiguration"> | $Enums.UserTier
    metadata?: JsonNullableFilter<"SSOConfiguration">
    createdBy?: IntFilter<"SSOConfiguration"> | number
    createdAt?: DateTimeFilter<"SSOConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"SSOConfiguration"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"SSOConfiguration"> | Date | string | null
  }

  export type OrganizationCreateWithoutTeamsInput = {
    name: string
    plan?: $Enums.PlanType
    status?: $Enums.OrgStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    ssoConfigs?: SSOConfigurationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutTeamsInput = {
    id?: number
    name: string
    plan?: $Enums.PlanType
    status?: $Enums.OrgStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    ssoConfigs?: SSOConfigurationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutTeamsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutTeamsInput, OrganizationUncheckedCreateWithoutTeamsInput>
  }

  export type TeamMemberCreateWithoutTeamInput = {
    role?: $Enums.TeamRole
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeamsInput
  }

  export type TeamMemberUncheckedCreateWithoutTeamInput = {
    id?: number
    userId: number
    role?: $Enums.TeamRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberCreateManyTeamInputEnvelope = {
    data: TeamMemberCreateManyTeamInput | TeamMemberCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutTeamsInput = {
    update: XOR<OrganizationUpdateWithoutTeamsInput, OrganizationUncheckedUpdateWithoutTeamsInput>
    create: XOR<OrganizationCreateWithoutTeamsInput, OrganizationUncheckedCreateWithoutTeamsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutTeamsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutTeamsInput, OrganizationUncheckedUpdateWithoutTeamsInput>
  }

  export type OrganizationUpdateWithoutTeamsInput = {
    name?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    status?: EnumOrgStatusFieldUpdateOperationsInput | $Enums.OrgStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    ssoConfigs?: SSOConfigurationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutTeamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    status?: EnumOrgStatusFieldUpdateOperationsInput | $Enums.OrgStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    ssoConfigs?: SSOConfigurationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamCreateWithoutMembersInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutTeamsInput
  }

  export type TeamUncheckedCreateWithoutMembersInput = {
    id?: number
    name: string
    orgId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamCreateOrConnectWithoutMembersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutTeamsInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamsInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
  }

  export type TeamUpsertWithoutMembersInput = {
    update: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMembersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type TeamUpdateWithoutMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutTeamsNestedInput
  }

  export type TeamUncheckedUpdateWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    orgId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTeamsInput = {
    update: XOR<UserUpdateWithoutTeamsInput, UserUncheckedUpdateWithoutTeamsInput>
    create: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamsInput, UserUncheckedUpdateWithoutTeamsInput>
  }

  export type UserUpdateWithoutTeamsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditsInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditsInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditsInput, UserUncheckedCreateWithoutAuditsInput>
  }

  export type UserUpsertWithoutAuditsInput = {
    update: XOR<UserUpdateWithoutAuditsInput, UserUncheckedUpdateWithoutAuditsInput>
    create: XOR<UserCreateWithoutAuditsInput, UserUncheckedCreateWithoutAuditsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditsInput, UserUncheckedUpdateWithoutAuditsInput>
  }

  export type UserUpdateWithoutAuditsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBudgetsInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBudgetsInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBudgetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBudgetsInput, UserUncheckedCreateWithoutBudgetsInput>
  }

  export type UserUpsertWithoutBudgetsInput = {
    update: XOR<UserUpdateWithoutBudgetsInput, UserUncheckedUpdateWithoutBudgetsInput>
    create: XOR<UserCreateWithoutBudgetsInput, UserUncheckedCreateWithoutBudgetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBudgetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBudgetsInput, UserUncheckedUpdateWithoutBudgetsInput>
  }

  export type UserUpdateWithoutBudgetsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBudgetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRegressionBaselinesInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRegressionBaselinesInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRegressionBaselinesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRegressionBaselinesInput, UserUncheckedCreateWithoutRegressionBaselinesInput>
  }

  export type UserUpsertWithoutRegressionBaselinesInput = {
    update: XOR<UserUpdateWithoutRegressionBaselinesInput, UserUncheckedUpdateWithoutRegressionBaselinesInput>
    create: XOR<UserCreateWithoutRegressionBaselinesInput, UserUncheckedCreateWithoutRegressionBaselinesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRegressionBaselinesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRegressionBaselinesInput, UserUncheckedUpdateWithoutRegressionBaselinesInput>
  }

  export type UserUpdateWithoutRegressionBaselinesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRegressionBaselinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFeedbacksInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeedbacksInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeedbacksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
  }

  export type UserUpsertWithoutFeedbacksInput = {
    update: XOR<UserUpdateWithoutFeedbacksInput, UserUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedbacksInput, UserUncheckedUpdateWithoutFeedbacksInput>
  }

  export type UserUpdateWithoutFeedbacksInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbacksInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutSsoConfigsInput = {
    name: string
    plan?: $Enums.PlanType
    status?: $Enums.OrgStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    teams?: TeamCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutSsoConfigsInput = {
    id?: number
    name: string
    plan?: $Enums.PlanType
    status?: $Enums.OrgStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    teams?: TeamUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutSsoConfigsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSsoConfigsInput, OrganizationUncheckedCreateWithoutSsoConfigsInput>
  }

  export type OrganizationUpsertWithoutSsoConfigsInput = {
    update: XOR<OrganizationUpdateWithoutSsoConfigsInput, OrganizationUncheckedUpdateWithoutSsoConfigsInput>
    create: XOR<OrganizationCreateWithoutSsoConfigsInput, OrganizationUncheckedCreateWithoutSsoConfigsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutSsoConfigsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutSsoConfigsInput, OrganizationUncheckedUpdateWithoutSsoConfigsInput>
  }

  export type OrganizationUpdateWithoutSsoConfigsInput = {
    name?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    status?: EnumOrgStatusFieldUpdateOperationsInput | $Enums.OrgStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    teams?: TeamUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutSsoConfigsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    status?: EnumOrgStatusFieldUpdateOperationsInput | $Enums.OrgStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    teams?: TeamUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBenReceiptsInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBenReceiptsInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBenReceiptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBenReceiptsInput, UserUncheckedCreateWithoutBenReceiptsInput>
  }

  export type TriTrackHandoffCreateWithoutFromReceiptInput = {
    fromTrack: $Enums.TrackType
    toTrack: $Enums.TrackType
    status?: $Enums.HandoffStatus
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    latencyMs?: number | null
    exceededLimit?: boolean
    payload: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    toReceipt?: BENReceiptCreateNestedOneWithoutHandoffsToInput
  }

  export type TriTrackHandoffUncheckedCreateWithoutFromReceiptInput = {
    id?: number
    fromTrack: $Enums.TrackType
    toTrack: $Enums.TrackType
    status?: $Enums.HandoffStatus
    toReceiptId?: number | null
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    latencyMs?: number | null
    exceededLimit?: boolean
    payload: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffCreateOrConnectWithoutFromReceiptInput = {
    where: TriTrackHandoffWhereUniqueInput
    create: XOR<TriTrackHandoffCreateWithoutFromReceiptInput, TriTrackHandoffUncheckedCreateWithoutFromReceiptInput>
  }

  export type TriTrackHandoffCreateManyFromReceiptInputEnvelope = {
    data: TriTrackHandoffCreateManyFromReceiptInput | TriTrackHandoffCreateManyFromReceiptInput[]
    skipDuplicates?: boolean
  }

  export type TriTrackHandoffCreateWithoutToReceiptInput = {
    fromTrack: $Enums.TrackType
    toTrack: $Enums.TrackType
    status?: $Enums.HandoffStatus
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    latencyMs?: number | null
    exceededLimit?: boolean
    payload: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    fromReceipt: BENReceiptCreateNestedOneWithoutHandoffsFromInput
  }

  export type TriTrackHandoffUncheckedCreateWithoutToReceiptInput = {
    id?: number
    fromTrack: $Enums.TrackType
    toTrack: $Enums.TrackType
    status?: $Enums.HandoffStatus
    fromReceiptId: number
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    latencyMs?: number | null
    exceededLimit?: boolean
    payload: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffCreateOrConnectWithoutToReceiptInput = {
    where: TriTrackHandoffWhereUniqueInput
    create: XOR<TriTrackHandoffCreateWithoutToReceiptInput, TriTrackHandoffUncheckedCreateWithoutToReceiptInput>
  }

  export type TriTrackHandoffCreateManyToReceiptInputEnvelope = {
    data: TriTrackHandoffCreateManyToReceiptInput | TriTrackHandoffCreateManyToReceiptInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBenReceiptsInput = {
    update: XOR<UserUpdateWithoutBenReceiptsInput, UserUncheckedUpdateWithoutBenReceiptsInput>
    create: XOR<UserCreateWithoutBenReceiptsInput, UserUncheckedCreateWithoutBenReceiptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBenReceiptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBenReceiptsInput, UserUncheckedUpdateWithoutBenReceiptsInput>
  }

  export type UserUpdateWithoutBenReceiptsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBenReceiptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TriTrackHandoffUpsertWithWhereUniqueWithoutFromReceiptInput = {
    where: TriTrackHandoffWhereUniqueInput
    update: XOR<TriTrackHandoffUpdateWithoutFromReceiptInput, TriTrackHandoffUncheckedUpdateWithoutFromReceiptInput>
    create: XOR<TriTrackHandoffCreateWithoutFromReceiptInput, TriTrackHandoffUncheckedCreateWithoutFromReceiptInput>
  }

  export type TriTrackHandoffUpdateWithWhereUniqueWithoutFromReceiptInput = {
    where: TriTrackHandoffWhereUniqueInput
    data: XOR<TriTrackHandoffUpdateWithoutFromReceiptInput, TriTrackHandoffUncheckedUpdateWithoutFromReceiptInput>
  }

  export type TriTrackHandoffUpdateManyWithWhereWithoutFromReceiptInput = {
    where: TriTrackHandoffScalarWhereInput
    data: XOR<TriTrackHandoffUpdateManyMutationInput, TriTrackHandoffUncheckedUpdateManyWithoutFromReceiptInput>
  }

  export type TriTrackHandoffScalarWhereInput = {
    AND?: TriTrackHandoffScalarWhereInput | TriTrackHandoffScalarWhereInput[]
    OR?: TriTrackHandoffScalarWhereInput[]
    NOT?: TriTrackHandoffScalarWhereInput | TriTrackHandoffScalarWhereInput[]
    id?: IntFilter<"TriTrackHandoff"> | number
    fromTrack?: EnumTrackTypeFilter<"TriTrackHandoff"> | $Enums.TrackType
    toTrack?: EnumTrackTypeFilter<"TriTrackHandoff"> | $Enums.TrackType
    status?: EnumHandoffStatusFilter<"TriTrackHandoff"> | $Enums.HandoffStatus
    fromReceiptId?: IntFilter<"TriTrackHandoff"> | number
    toReceiptId?: IntNullableFilter<"TriTrackHandoff"> | number | null
    initiatedAt?: DateTimeFilter<"TriTrackHandoff"> | Date | string
    completedAt?: DateTimeNullableFilter<"TriTrackHandoff"> | Date | string | null
    latencyMs?: IntNullableFilter<"TriTrackHandoff"> | number | null
    exceededLimit?: BoolFilter<"TriTrackHandoff"> | boolean
    payload?: JsonFilter<"TriTrackHandoff">
    result?: JsonNullableFilter<"TriTrackHandoff">
    errorMessage?: StringNullableFilter<"TriTrackHandoff"> | string | null
    metadata?: JsonNullableFilter<"TriTrackHandoff">
  }

  export type TriTrackHandoffUpsertWithWhereUniqueWithoutToReceiptInput = {
    where: TriTrackHandoffWhereUniqueInput
    update: XOR<TriTrackHandoffUpdateWithoutToReceiptInput, TriTrackHandoffUncheckedUpdateWithoutToReceiptInput>
    create: XOR<TriTrackHandoffCreateWithoutToReceiptInput, TriTrackHandoffUncheckedCreateWithoutToReceiptInput>
  }

  export type TriTrackHandoffUpdateWithWhereUniqueWithoutToReceiptInput = {
    where: TriTrackHandoffWhereUniqueInput
    data: XOR<TriTrackHandoffUpdateWithoutToReceiptInput, TriTrackHandoffUncheckedUpdateWithoutToReceiptInput>
  }

  export type TriTrackHandoffUpdateManyWithWhereWithoutToReceiptInput = {
    where: TriTrackHandoffScalarWhereInput
    data: XOR<TriTrackHandoffUpdateManyMutationInput, TriTrackHandoffUncheckedUpdateManyWithoutToReceiptInput>
  }

  export type UserCreateWithoutBenSessionsInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBenSessionsInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBenSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBenSessionsInput, UserUncheckedCreateWithoutBenSessionsInput>
  }

  export type UserUpsertWithoutBenSessionsInput = {
    update: XOR<UserUpdateWithoutBenSessionsInput, UserUncheckedUpdateWithoutBenSessionsInput>
    create: XOR<UserCreateWithoutBenSessionsInput, UserUncheckedCreateWithoutBenSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBenSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBenSessionsInput, UserUncheckedUpdateWithoutBenSessionsInput>
  }

  export type UserUpdateWithoutBenSessionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBenSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BENReceiptCreateWithoutHandoffsFromInput = {
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp?: Date | string
    persona?: $Enums.BENPersona
    track?: $Enums.TrackType | null
    payload: JsonNullValueInput | InputJsonValue
    digest: string
    previousDigest?: string | null
    baselineDigest?: string | null
    witnessModel?: string | null
    witnessSignature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutBenReceiptsInput
    handoffsTo?: TriTrackHandoffCreateNestedManyWithoutToReceiptInput
  }

  export type BENReceiptUncheckedCreateWithoutHandoffsFromInput = {
    id?: number
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp?: Date | string
    userId?: number | null
    persona?: $Enums.BENPersona
    track?: $Enums.TrackType | null
    payload: JsonNullValueInput | InputJsonValue
    digest: string
    previousDigest?: string | null
    baselineDigest?: string | null
    witnessModel?: string | null
    witnessSignature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    handoffsTo?: TriTrackHandoffUncheckedCreateNestedManyWithoutToReceiptInput
  }

  export type BENReceiptCreateOrConnectWithoutHandoffsFromInput = {
    where: BENReceiptWhereUniqueInput
    create: XOR<BENReceiptCreateWithoutHandoffsFromInput, BENReceiptUncheckedCreateWithoutHandoffsFromInput>
  }

  export type BENReceiptCreateWithoutHandoffsToInput = {
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp?: Date | string
    persona?: $Enums.BENPersona
    track?: $Enums.TrackType | null
    payload: JsonNullValueInput | InputJsonValue
    digest: string
    previousDigest?: string | null
    baselineDigest?: string | null
    witnessModel?: string | null
    witnessSignature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutBenReceiptsInput
    handoffsFrom?: TriTrackHandoffCreateNestedManyWithoutFromReceiptInput
  }

  export type BENReceiptUncheckedCreateWithoutHandoffsToInput = {
    id?: number
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp?: Date | string
    userId?: number | null
    persona?: $Enums.BENPersona
    track?: $Enums.TrackType | null
    payload: JsonNullValueInput | InputJsonValue
    digest: string
    previousDigest?: string | null
    baselineDigest?: string | null
    witnessModel?: string | null
    witnessSignature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    handoffsFrom?: TriTrackHandoffUncheckedCreateNestedManyWithoutFromReceiptInput
  }

  export type BENReceiptCreateOrConnectWithoutHandoffsToInput = {
    where: BENReceiptWhereUniqueInput
    create: XOR<BENReceiptCreateWithoutHandoffsToInput, BENReceiptUncheckedCreateWithoutHandoffsToInput>
  }

  export type BENReceiptUpsertWithoutHandoffsFromInput = {
    update: XOR<BENReceiptUpdateWithoutHandoffsFromInput, BENReceiptUncheckedUpdateWithoutHandoffsFromInput>
    create: XOR<BENReceiptCreateWithoutHandoffsFromInput, BENReceiptUncheckedCreateWithoutHandoffsFromInput>
    where?: BENReceiptWhereInput
  }

  export type BENReceiptUpdateToOneWithWhereWithoutHandoffsFromInput = {
    where?: BENReceiptWhereInput
    data: XOR<BENReceiptUpdateWithoutHandoffsFromInput, BENReceiptUncheckedUpdateWithoutHandoffsFromInput>
  }

  export type BENReceiptUpdateWithoutHandoffsFromInput = {
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutBenReceiptsNestedInput
    handoffsTo?: TriTrackHandoffUpdateManyWithoutToReceiptNestedInput
  }

  export type BENReceiptUncheckedUpdateWithoutHandoffsFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handoffsTo?: TriTrackHandoffUncheckedUpdateManyWithoutToReceiptNestedInput
  }

  export type BENReceiptUpsertWithoutHandoffsToInput = {
    update: XOR<BENReceiptUpdateWithoutHandoffsToInput, BENReceiptUncheckedUpdateWithoutHandoffsToInput>
    create: XOR<BENReceiptCreateWithoutHandoffsToInput, BENReceiptUncheckedCreateWithoutHandoffsToInput>
    where?: BENReceiptWhereInput
  }

  export type BENReceiptUpdateToOneWithWhereWithoutHandoffsToInput = {
    where?: BENReceiptWhereInput
    data: XOR<BENReceiptUpdateWithoutHandoffsToInput, BENReceiptUncheckedUpdateWithoutHandoffsToInput>
  }

  export type BENReceiptUpdateWithoutHandoffsToInput = {
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutBenReceiptsNestedInput
    handoffsFrom?: TriTrackHandoffUpdateManyWithoutFromReceiptNestedInput
  }

  export type BENReceiptUncheckedUpdateWithoutHandoffsToInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handoffsFrom?: TriTrackHandoffUncheckedUpdateManyWithoutFromReceiptNestedInput
  }

  export type UserCreateWithoutZscansInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutZscansInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutZscansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutZscansInput, UserUncheckedCreateWithoutZscansInput>
  }

  export type UserUpsertWithoutZscansInput = {
    update: XOR<UserUpdateWithoutZscansInput, UserUncheckedUpdateWithoutZscansInput>
    create: XOR<UserCreateWithoutZscansInput, UserUncheckedCreateWithoutZscansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutZscansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutZscansInput, UserUncheckedUpdateWithoutZscansInput>
  }

  export type UserUpdateWithoutZscansInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutZscansInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SessionCreateManyUserInput = {
    id?: number
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type AuditRecordCreateManyUserInput = {
    id?: number
    action: string
    category: $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AuditStatus
    lamport: number
    hashPointer?: string | null
    createdAt?: Date | string
  }

  export type TeamMemberCreateManyUserInput = {
    id?: number
    teamId: number
    role?: $Enums.TeamRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCreateManyUserInput = {
    id?: number
    limit: number
    period?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegressionBaselineCreateManyUserInput = {
    id?: number
    modelName: string
    modelVersion?: string | null
    testType: string
    avgResponseTime: number
    avgCost: number
    avgQualityScore: number
    avgAccuracy: number
    successRate: number
    alertThreshold?: number
    sampleSize: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackCreateManyUserInput = {
    id?: number
    type: $Enums.FeedbackType
    category: $Enums.FeedbackCategory
    priority?: $Enums.FeedbackPriority
    subject: string
    message: string
    url?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachmentUrls?: FeedbackCreateattachmentUrlsInput | string[]
    status?: $Enums.FeedbackStatus
    assignedTo?: number | null
    response?: string | null
    respondedAt?: Date | string | null
    respondedBy?: number | null
    sentiment?: string | null
    sentimentScore?: number | null
    upvotes?: number
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type BENReceiptCreateManyUserInput = {
    id?: number
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp?: Date | string
    persona?: $Enums.BENPersona
    track?: $Enums.TrackType | null
    payload: JsonNullValueInput | InputJsonValue
    digest: string
    previousDigest?: string | null
    baselineDigest?: string | null
    witnessModel?: string | null
    witnessSignature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BENSessionCreateManyUserInput = {
    id?: number
    persona: $Enums.BENPersona
    priority: number
    locked?: boolean
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    startLamport: number
    endLamport?: number | null
    switchReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ZScanVerificationCreateManyUserInput = {
    id?: number
    totalRules: number
    passed: number
    warnings: number
    critical: number
    results: JsonNullValueInput | InputJsonValue
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditRecordUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    category?: EnumAuditCategoryFieldUpdateOperationsInput | $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    lamport?: IntFieldUpdateOperationsInput | number
    hashPointer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditRecordUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    category?: EnumAuditCategoryFieldUpdateOperationsInput | $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    lamport?: IntFieldUpdateOperationsInput | number
    hashPointer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditRecordUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    category?: EnumAuditCategoryFieldUpdateOperationsInput | $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    lamport?: IntFieldUpdateOperationsInput | number
    hashPointer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUpdateWithoutUserInput = {
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUpdateWithoutUserInput = {
    limit?: FloatFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    limit?: FloatFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    limit?: FloatFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegressionBaselineUpdateWithoutUserInput = {
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: StringFieldUpdateOperationsInput | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    avgQualityScore?: FloatFieldUpdateOperationsInput | number
    avgAccuracy?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegressionBaselineUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: StringFieldUpdateOperationsInput | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    avgQualityScore?: FloatFieldUpdateOperationsInput | number
    avgAccuracy?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegressionBaselineUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: StringFieldUpdateOperationsInput | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    avgQualityScore?: FloatFieldUpdateOperationsInput | number
    avgAccuracy?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUpdateWithoutUserInput = {
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachmentUrls?: FeedbackUpdateattachmentUrlsInput | string[]
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeedbackUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachmentUrls?: FeedbackUpdateattachmentUrlsInput | string[]
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeedbackUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    attachmentUrls?: FeedbackUpdateattachmentUrlsInput | string[]
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BENReceiptUpdateWithoutUserInput = {
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handoffsFrom?: TriTrackHandoffUpdateManyWithoutFromReceiptNestedInput
    handoffsTo?: TriTrackHandoffUpdateManyWithoutToReceiptNestedInput
  }

  export type BENReceiptUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handoffsFrom?: TriTrackHandoffUncheckedUpdateManyWithoutFromReceiptNestedInput
    handoffsTo?: TriTrackHandoffUncheckedUpdateManyWithoutToReceiptNestedInput
  }

  export type BENReceiptUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BENSessionUpdateWithoutUserInput = {
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    priority?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startLamport?: IntFieldUpdateOperationsInput | number
    endLamport?: NullableIntFieldUpdateOperationsInput | number | null
    switchReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BENSessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    priority?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startLamport?: IntFieldUpdateOperationsInput | number
    endLamport?: NullableIntFieldUpdateOperationsInput | number | null
    switchReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BENSessionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    priority?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startLamport?: IntFieldUpdateOperationsInput | number
    endLamport?: NullableIntFieldUpdateOperationsInput | number | null
    switchReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ZScanVerificationUpdateWithoutUserInput = {
    totalRules?: IntFieldUpdateOperationsInput | number
    passed?: IntFieldUpdateOperationsInput | number
    warnings?: IntFieldUpdateOperationsInput | number
    critical?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZScanVerificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalRules?: IntFieldUpdateOperationsInput | number
    passed?: IntFieldUpdateOperationsInput | number
    warnings?: IntFieldUpdateOperationsInput | number
    critical?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZScanVerificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalRules?: IntFieldUpdateOperationsInput | number
    passed?: IntFieldUpdateOperationsInput | number
    warnings?: IntFieldUpdateOperationsInput | number
    critical?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyOrganizationInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
  }

  export type TeamCreateManyOrganizationInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SSOConfigurationCreateManyOrganizationInput = {
    id?: number
    provider: $Enums.SSOProvider
    enabled?: boolean
    samlEntryPoint?: string | null
    samlIssuer?: string | null
    samlCert?: string | null
    samlCallbackUrl?: string | null
    samlLogoutUrl?: string | null
    oauthClientId?: string | null
    oauthClientSecret?: string | null
    oauthAuthUrl?: string | null
    oauthTokenUrl?: string | null
    oauthUserInfoUrl?: string | null
    oauthScopes?: SSOConfigurationCreateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationCreatedomainRestrictionInput | string[]
    jitProvisioning?: boolean
    defaultRole?: $Enums.Role
    defaultTier?: $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type UserUpdateWithoutOrganizationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TeamUpdateWithoutOrganizationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SSOConfigurationUpdateWithoutOrganizationInput = {
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    enabled?: BoolFieldUpdateOperationsInput | boolean
    samlEntryPoint?: NullableStringFieldUpdateOperationsInput | string | null
    samlIssuer?: NullableStringFieldUpdateOperationsInput | string | null
    samlCert?: NullableStringFieldUpdateOperationsInput | string | null
    samlCallbackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    samlLogoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthAuthUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthUserInfoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthScopes?: SSOConfigurationUpdateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationUpdatedomainRestrictionInput | string[]
    jitProvisioning?: BoolFieldUpdateOperationsInput | boolean
    defaultRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    defaultTier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SSOConfigurationUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    enabled?: BoolFieldUpdateOperationsInput | boolean
    samlEntryPoint?: NullableStringFieldUpdateOperationsInput | string | null
    samlIssuer?: NullableStringFieldUpdateOperationsInput | string | null
    samlCert?: NullableStringFieldUpdateOperationsInput | string | null
    samlCallbackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    samlLogoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthAuthUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthUserInfoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthScopes?: SSOConfigurationUpdateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationUpdatedomainRestrictionInput | string[]
    jitProvisioning?: BoolFieldUpdateOperationsInput | boolean
    defaultRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    defaultTier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SSOConfigurationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    enabled?: BoolFieldUpdateOperationsInput | boolean
    samlEntryPoint?: NullableStringFieldUpdateOperationsInput | string | null
    samlIssuer?: NullableStringFieldUpdateOperationsInput | string | null
    samlCert?: NullableStringFieldUpdateOperationsInput | string | null
    samlCallbackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    samlLogoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthAuthUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthUserInfoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthScopes?: SSOConfigurationUpdateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationUpdatedomainRestrictionInput | string[]
    jitProvisioning?: BoolFieldUpdateOperationsInput | boolean
    defaultRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    defaultTier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamMemberCreateManyTeamInput = {
    id?: number
    userId: number
    role?: $Enums.TeamRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUpdateWithoutTeamInput = {
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeamsNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TriTrackHandoffCreateManyFromReceiptInput = {
    id?: number
    fromTrack: $Enums.TrackType
    toTrack: $Enums.TrackType
    status?: $Enums.HandoffStatus
    toReceiptId?: number | null
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    latencyMs?: number | null
    exceededLimit?: boolean
    payload: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffCreateManyToReceiptInput = {
    id?: number
    fromTrack: $Enums.TrackType
    toTrack: $Enums.TrackType
    status?: $Enums.HandoffStatus
    fromReceiptId: number
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    latencyMs?: number | null
    exceededLimit?: boolean
    payload: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffUpdateWithoutFromReceiptInput = {
    fromTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    toTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    status?: EnumHandoffStatusFieldUpdateOperationsInput | $Enums.HandoffStatus
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    exceededLimit?: BoolFieldUpdateOperationsInput | boolean
    payload?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    toReceipt?: BENReceiptUpdateOneWithoutHandoffsToNestedInput
  }

  export type TriTrackHandoffUncheckedUpdateWithoutFromReceiptInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    toTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    status?: EnumHandoffStatusFieldUpdateOperationsInput | $Enums.HandoffStatus
    toReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    exceededLimit?: BoolFieldUpdateOperationsInput | boolean
    payload?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffUncheckedUpdateManyWithoutFromReceiptInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    toTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    status?: EnumHandoffStatusFieldUpdateOperationsInput | $Enums.HandoffStatus
    toReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    exceededLimit?: BoolFieldUpdateOperationsInput | boolean
    payload?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffUpdateWithoutToReceiptInput = {
    fromTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    toTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    status?: EnumHandoffStatusFieldUpdateOperationsInput | $Enums.HandoffStatus
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    exceededLimit?: BoolFieldUpdateOperationsInput | boolean
    payload?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    fromReceipt?: BENReceiptUpdateOneRequiredWithoutHandoffsFromNestedInput
  }

  export type TriTrackHandoffUncheckedUpdateWithoutToReceiptInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    toTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    status?: EnumHandoffStatusFieldUpdateOperationsInput | $Enums.HandoffStatus
    fromReceiptId?: IntFieldUpdateOperationsInput | number
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    exceededLimit?: BoolFieldUpdateOperationsInput | boolean
    payload?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffUncheckedUpdateManyWithoutToReceiptInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    toTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    status?: EnumHandoffStatusFieldUpdateOperationsInput | $Enums.HandoffStatus
    fromReceiptId?: IntFieldUpdateOperationsInput | number
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    exceededLimit?: BoolFieldUpdateOperationsInput | boolean
    payload?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}

/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model TeamMember
 * 
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>
/**
 * Model AuditRecord
 * 
 */
export type AuditRecord = $Result.DefaultSelection<Prisma.$AuditRecordPayload>
/**
 * Model Block
 * 
 */
export type Block = $Result.DefaultSelection<Prisma.$BlockPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Budget
 * 
 */
export type Budget = $Result.DefaultSelection<Prisma.$BudgetPayload>
/**
 * Model RegressionBaseline
 * 
 */
export type RegressionBaseline = $Result.DefaultSelection<Prisma.$RegressionBaselinePayload>
/**
 * Model Feedback
 * 
 */
export type Feedback = $Result.DefaultSelection<Prisma.$FeedbackPayload>
/**
 * Model BENReceipt
 * 
 */
export type BENReceipt = $Result.DefaultSelection<Prisma.$BENReceiptPayload>
/**
 * Model BENSession
 * 
 */
export type BENSession = $Result.DefaultSelection<Prisma.$BENSessionPayload>
/**
 * Model TriTrackHandoff
 * 
 */
export type TriTrackHandoff = $Result.DefaultSelection<Prisma.$TriTrackHandoffPayload>
/**
 * Model ZScanVerification
 * 
 */
export type ZScanVerification = $Result.DefaultSelection<Prisma.$ZScanVerificationPayload>
/**
 * Model SSOConfiguration
 * 
 */
export type SSOConfiguration = $Result.DefaultSelection<Prisma.$SSOConfigurationPayload>
/**
 * Model NotificationPreference
 * 
 */
export type NotificationPreference = $Result.DefaultSelection<Prisma.$NotificationPreferencePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  USER: 'USER',
  ADMIN: 'ADMIN',
  ARCHITECT: 'ARCHITECT',
  AUDITOR: 'AUDITOR',
  WITNESS: 'WITNESS'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Permission: {
  READ_LOGS: 'READ_LOGS',
  WRITE_LOGS: 'WRITE_LOGS',
  MANAGE_USERS: 'MANAGE_USERS',
  MANAGE_TEAMS: 'MANAGE_TEAMS',
  VERIFY_RECORDS: 'VERIFY_RECORDS',
  EXPORT_DATA: 'EXPORT_DATA',
  VIEW_ANALYTICS: 'VIEW_ANALYTICS',
  MANAGE_SETTINGS: 'MANAGE_SETTINGS'
};

export type Permission = (typeof Permission)[keyof typeof Permission]


export const TeamRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  MEMBER: 'MEMBER',
  VIEWER: 'VIEWER'
};

export type TeamRole = (typeof TeamRole)[keyof typeof TeamRole]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const UserTier: {
  FREE: 'FREE',
  PAID: 'PAID',
  ARCHITECT: 'ARCHITECT'
};

export type UserTier = (typeof UserTier)[keyof typeof UserTier]


export const OrgStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED',
  TRIAL: 'TRIAL'
};

export type OrgStatus = (typeof OrgStatus)[keyof typeof OrgStatus]


export const PlanType: {
  TRIAL: 'TRIAL',
  BASIC: 'BASIC',
  PRO: 'PRO',
  ENTERPRISE: 'ENTERPRISE'
};

export type PlanType = (typeof PlanType)[keyof typeof PlanType]


export const AuditCategory: {
  AUTH: 'AUTH',
  ACCESS: 'ACCESS',
  DATA: 'DATA',
  CONFIG: 'CONFIG',
  VERIFICATION: 'VERIFICATION',
  SYSTEM: 'SYSTEM'
};

export type AuditCategory = (typeof AuditCategory)[keyof typeof AuditCategory]


export const AuditStatus: {
  SUCCESS: 'SUCCESS',
  FAILURE: 'FAILURE',
  WARNING: 'WARNING',
  INFO: 'INFO'
};

export type AuditStatus = (typeof AuditStatus)[keyof typeof AuditStatus]


export const FeedbackType: {
  BUG: 'BUG',
  FEATURE: 'FEATURE',
  IMPROVEMENT: 'IMPROVEMENT',
  QUESTION: 'QUESTION',
  OTHER: 'OTHER'
};

export type FeedbackType = (typeof FeedbackType)[keyof typeof FeedbackType]


export const FeedbackCategory: {
  UI_UX: 'UI_UX',
  PERFORMANCE: 'PERFORMANCE',
  ACCURACY: 'ACCURACY',
  DOCUMENTATION: 'DOCUMENTATION',
  API: 'API',
  BILLING: 'BILLING',
  SECURITY: 'SECURITY',
  GENERAL: 'GENERAL'
};

export type FeedbackCategory = (typeof FeedbackCategory)[keyof typeof FeedbackCategory]


export const FeedbackPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type FeedbackPriority = (typeof FeedbackPriority)[keyof typeof FeedbackPriority]


export const FeedbackStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED',
  WONT_FIX: 'WONT_FIX'
};

export type FeedbackStatus = (typeof FeedbackStatus)[keyof typeof FeedbackStatus]


export const SSOProvider: {
  SAML: 'SAML',
  AZURE_AD: 'AZURE_AD',
  GOOGLE: 'GOOGLE',
  OKTA: 'OKTA',
  GENERIC_OAUTH: 'GENERIC_OAUTH'
};

export type SSOProvider = (typeof SSOProvider)[keyof typeof SSOProvider]


export const BENPersona: {
  USER: 'USER',
  VERIFIER: 'VERIFIER',
  ANALYST: 'ANALYST',
  GOVERNOR: 'GOVERNOR',
  ARCHITECT: 'ARCHITECT'
};

export type BENPersona = (typeof BENPersona)[keyof typeof BENPersona]


export const ReceiptType: {
  BOOT_CONFIRM: 'BOOT_CONFIRM',
  ANALYSIS: 'ANALYSIS',
  DIRECTIVE: 'DIRECTIVE',
  RESULT: 'RESULT',
  APPEND: 'APPEND',
  SYNC_POINT: 'SYNC_POINT'
};

export type ReceiptType = (typeof ReceiptType)[keyof typeof ReceiptType]


export const TrackType: {
  BEN_CORE: 'BEN_CORE',
  AUDITAAI: 'AUDITAAI',
  HUMAN: 'HUMAN'
};

export type TrackType = (typeof TrackType)[keyof typeof TrackType]


export const HandoffStatus: {
  INITIATED: 'INITIATED',
  IN_TRANSIT: 'IN_TRANSIT',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  TIMEOUT: 'TIMEOUT'
};

export type HandoffStatus = (typeof HandoffStatus)[keyof typeof HandoffStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Permission = $Enums.Permission

export const Permission: typeof $Enums.Permission

export type TeamRole = $Enums.TeamRole

export const TeamRole: typeof $Enums.TeamRole

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type UserTier = $Enums.UserTier

export const UserTier: typeof $Enums.UserTier

export type OrgStatus = $Enums.OrgStatus

export const OrgStatus: typeof $Enums.OrgStatus

export type PlanType = $Enums.PlanType

export const PlanType: typeof $Enums.PlanType

export type AuditCategory = $Enums.AuditCategory

export const AuditCategory: typeof $Enums.AuditCategory

export type AuditStatus = $Enums.AuditStatus

export const AuditStatus: typeof $Enums.AuditStatus

export type FeedbackType = $Enums.FeedbackType

export const FeedbackType: typeof $Enums.FeedbackType

export type FeedbackCategory = $Enums.FeedbackCategory

export const FeedbackCategory: typeof $Enums.FeedbackCategory

export type FeedbackPriority = $Enums.FeedbackPriority

export const FeedbackPriority: typeof $Enums.FeedbackPriority

export type FeedbackStatus = $Enums.FeedbackStatus

export const FeedbackStatus: typeof $Enums.FeedbackStatus

export type SSOProvider = $Enums.SSOProvider

export const SSOProvider: typeof $Enums.SSOProvider

export type BENPersona = $Enums.BENPersona

export const BENPersona: typeof $Enums.BENPersona

export type ReceiptType = $Enums.ReceiptType

export const ReceiptType: typeof $Enums.ReceiptType

export type TrackType = $Enums.TrackType

export const TrackType: typeof $Enums.TrackType

export type HandoffStatus = $Enums.HandoffStatus

export const HandoffStatus: typeof $Enums.HandoffStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditRecord`: Exposes CRUD operations for the **AuditRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditRecords
    * const auditRecords = await prisma.auditRecord.findMany()
    * ```
    */
  get auditRecord(): Prisma.AuditRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.block`: Exposes CRUD operations for the **Block** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blocks
    * const blocks = await prisma.block.findMany()
    * ```
    */
  get block(): Prisma.BlockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budget`: Exposes CRUD operations for the **Budget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Budgets
    * const budgets = await prisma.budget.findMany()
    * ```
    */
  get budget(): Prisma.BudgetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.regressionBaseline`: Exposes CRUD operations for the **RegressionBaseline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RegressionBaselines
    * const regressionBaselines = await prisma.regressionBaseline.findMany()
    * ```
    */
  get regressionBaseline(): Prisma.RegressionBaselineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **Feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.FeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bENReceipt`: Exposes CRUD operations for the **BENReceipt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BENReceipts
    * const bENReceipts = await prisma.bENReceipt.findMany()
    * ```
    */
  get bENReceipt(): Prisma.BENReceiptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bENSession`: Exposes CRUD operations for the **BENSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BENSessions
    * const bENSessions = await prisma.bENSession.findMany()
    * ```
    */
  get bENSession(): Prisma.BENSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.triTrackHandoff`: Exposes CRUD operations for the **TriTrackHandoff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TriTrackHandoffs
    * const triTrackHandoffs = await prisma.triTrackHandoff.findMany()
    * ```
    */
  get triTrackHandoff(): Prisma.TriTrackHandoffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zScanVerification`: Exposes CRUD operations for the **ZScanVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ZScanVerifications
    * const zScanVerifications = await prisma.zScanVerification.findMany()
    * ```
    */
  get zScanVerification(): Prisma.ZScanVerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sSOConfiguration`: Exposes CRUD operations for the **SSOConfiguration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SSOConfigurations
    * const sSOConfigurations = await prisma.sSOConfiguration.findMany()
    * ```
    */
  get sSOConfiguration(): Prisma.SSOConfigurationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPreference`: Exposes CRUD operations for the **NotificationPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPreferences
    * const notificationPreferences = await prisma.notificationPreference.findMany()
    * ```
    */
  get notificationPreference(): Prisma.NotificationPreferenceDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Organization: 'Organization',
    Team: 'Team',
    TeamMember: 'TeamMember',
    AuditRecord: 'AuditRecord',
    Block: 'Block',
    Session: 'Session',
    Budget: 'Budget',
    RegressionBaseline: 'RegressionBaseline',
    Feedback: 'Feedback',
    BENReceipt: 'BENReceipt',
    BENSession: 'BENSession',
    TriTrackHandoff: 'TriTrackHandoff',
    ZScanVerification: 'ZScanVerification',
    SSOConfiguration: 'SSOConfiguration',
    NotificationPreference: 'NotificationPreference'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "organization" | "team" | "teamMember" | "auditRecord" | "block" | "session" | "budget" | "regressionBaseline" | "feedback" | "bENReceipt" | "bENSession" | "triTrackHandoff" | "zScanVerification" | "sSOConfiguration" | "notificationPreference"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>
        fields: Prisma.TeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      AuditRecord: {
        payload: Prisma.$AuditRecordPayload<ExtArgs>
        fields: Prisma.AuditRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>
          }
          findFirst: {
            args: Prisma.AuditRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>
          }
          findMany: {
            args: Prisma.AuditRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>[]
          }
          create: {
            args: Prisma.AuditRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>
          }
          createMany: {
            args: Prisma.AuditRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>[]
          }
          delete: {
            args: Prisma.AuditRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>
          }
          update: {
            args: Prisma.AuditRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>
          }
          deleteMany: {
            args: Prisma.AuditRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>[]
          }
          upsert: {
            args: Prisma.AuditRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>
          }
          aggregate: {
            args: Prisma.AuditRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditRecord>
          }
          groupBy: {
            args: Prisma.AuditRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditRecordCountArgs<ExtArgs>
            result: $Utils.Optional<AuditRecordCountAggregateOutputType> | number
          }
        }
      }
      Block: {
        payload: Prisma.$BlockPayload<ExtArgs>
        fields: Prisma.BlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findFirst: {
            args: Prisma.BlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findMany: {
            args: Prisma.BlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          create: {
            args: Prisma.BlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          createMany: {
            args: Prisma.BlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          delete: {
            args: Prisma.BlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          update: {
            args: Prisma.BlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          deleteMany: {
            args: Prisma.BlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          upsert: {
            args: Prisma.BlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          aggregate: {
            args: Prisma.BlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlock>
          }
          groupBy: {
            args: Prisma.BlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockCountArgs<ExtArgs>
            result: $Utils.Optional<BlockCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Budget: {
        payload: Prisma.$BudgetPayload<ExtArgs>
        fields: Prisma.BudgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findFirst: {
            args: Prisma.BudgetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findMany: {
            args: Prisma.BudgetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          create: {
            args: Prisma.BudgetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          createMany: {
            args: Prisma.BudgetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          delete: {
            args: Prisma.BudgetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          update: {
            args: Prisma.BudgetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          deleteMany: {
            args: Prisma.BudgetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BudgetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          upsert: {
            args: Prisma.BudgetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          aggregate: {
            args: Prisma.BudgetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudget>
          }
          groupBy: {
            args: Prisma.BudgetGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetCountAggregateOutputType> | number
          }
        }
      }
      RegressionBaseline: {
        payload: Prisma.$RegressionBaselinePayload<ExtArgs>
        fields: Prisma.RegressionBaselineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegressionBaselineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegressionBaselineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload>
          }
          findFirst: {
            args: Prisma.RegressionBaselineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegressionBaselineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload>
          }
          findMany: {
            args: Prisma.RegressionBaselineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload>[]
          }
          create: {
            args: Prisma.RegressionBaselineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload>
          }
          createMany: {
            args: Prisma.RegressionBaselineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegressionBaselineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload>[]
          }
          delete: {
            args: Prisma.RegressionBaselineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload>
          }
          update: {
            args: Prisma.RegressionBaselineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload>
          }
          deleteMany: {
            args: Prisma.RegressionBaselineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegressionBaselineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RegressionBaselineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload>[]
          }
          upsert: {
            args: Prisma.RegressionBaselineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegressionBaselinePayload>
          }
          aggregate: {
            args: Prisma.RegressionBaselineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegressionBaseline>
          }
          groupBy: {
            args: Prisma.RegressionBaselineGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegressionBaselineGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegressionBaselineCountArgs<ExtArgs>
            result: $Utils.Optional<RegressionBaselineCountAggregateOutputType> | number
          }
        }
      }
      Feedback: {
        payload: Prisma.$FeedbackPayload<ExtArgs>
        fields: Prisma.FeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findFirst: {
            args: Prisma.FeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findMany: {
            args: Prisma.FeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          create: {
            args: Prisma.FeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          createMany: {
            args: Prisma.FeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          delete: {
            args: Prisma.FeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          update: {
            args: Prisma.FeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeedbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          upsert: {
            args: Prisma.FeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.FeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
      BENReceipt: {
        payload: Prisma.$BENReceiptPayload<ExtArgs>
        fields: Prisma.BENReceiptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BENReceiptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BENReceiptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload>
          }
          findFirst: {
            args: Prisma.BENReceiptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BENReceiptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload>
          }
          findMany: {
            args: Prisma.BENReceiptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload>[]
          }
          create: {
            args: Prisma.BENReceiptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload>
          }
          createMany: {
            args: Prisma.BENReceiptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BENReceiptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload>[]
          }
          delete: {
            args: Prisma.BENReceiptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload>
          }
          update: {
            args: Prisma.BENReceiptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload>
          }
          deleteMany: {
            args: Prisma.BENReceiptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BENReceiptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BENReceiptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload>[]
          }
          upsert: {
            args: Prisma.BENReceiptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENReceiptPayload>
          }
          aggregate: {
            args: Prisma.BENReceiptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBENReceipt>
          }
          groupBy: {
            args: Prisma.BENReceiptGroupByArgs<ExtArgs>
            result: $Utils.Optional<BENReceiptGroupByOutputType>[]
          }
          count: {
            args: Prisma.BENReceiptCountArgs<ExtArgs>
            result: $Utils.Optional<BENReceiptCountAggregateOutputType> | number
          }
        }
      }
      BENSession: {
        payload: Prisma.$BENSessionPayload<ExtArgs>
        fields: Prisma.BENSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BENSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BENSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload>
          }
          findFirst: {
            args: Prisma.BENSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BENSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload>
          }
          findMany: {
            args: Prisma.BENSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload>[]
          }
          create: {
            args: Prisma.BENSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload>
          }
          createMany: {
            args: Prisma.BENSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BENSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload>[]
          }
          delete: {
            args: Prisma.BENSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload>
          }
          update: {
            args: Prisma.BENSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload>
          }
          deleteMany: {
            args: Prisma.BENSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BENSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BENSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload>[]
          }
          upsert: {
            args: Prisma.BENSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BENSessionPayload>
          }
          aggregate: {
            args: Prisma.BENSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBENSession>
          }
          groupBy: {
            args: Prisma.BENSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BENSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BENSessionCountArgs<ExtArgs>
            result: $Utils.Optional<BENSessionCountAggregateOutputType> | number
          }
        }
      }
      TriTrackHandoff: {
        payload: Prisma.$TriTrackHandoffPayload<ExtArgs>
        fields: Prisma.TriTrackHandoffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TriTrackHandoffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TriTrackHandoffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload>
          }
          findFirst: {
            args: Prisma.TriTrackHandoffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TriTrackHandoffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload>
          }
          findMany: {
            args: Prisma.TriTrackHandoffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload>[]
          }
          create: {
            args: Prisma.TriTrackHandoffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload>
          }
          createMany: {
            args: Prisma.TriTrackHandoffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TriTrackHandoffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload>[]
          }
          delete: {
            args: Prisma.TriTrackHandoffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload>
          }
          update: {
            args: Prisma.TriTrackHandoffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload>
          }
          deleteMany: {
            args: Prisma.TriTrackHandoffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TriTrackHandoffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TriTrackHandoffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload>[]
          }
          upsert: {
            args: Prisma.TriTrackHandoffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriTrackHandoffPayload>
          }
          aggregate: {
            args: Prisma.TriTrackHandoffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTriTrackHandoff>
          }
          groupBy: {
            args: Prisma.TriTrackHandoffGroupByArgs<ExtArgs>
            result: $Utils.Optional<TriTrackHandoffGroupByOutputType>[]
          }
          count: {
            args: Prisma.TriTrackHandoffCountArgs<ExtArgs>
            result: $Utils.Optional<TriTrackHandoffCountAggregateOutputType> | number
          }
        }
      }
      ZScanVerification: {
        payload: Prisma.$ZScanVerificationPayload<ExtArgs>
        fields: Prisma.ZScanVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZScanVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZScanVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload>
          }
          findFirst: {
            args: Prisma.ZScanVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZScanVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload>
          }
          findMany: {
            args: Prisma.ZScanVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload>[]
          }
          create: {
            args: Prisma.ZScanVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload>
          }
          createMany: {
            args: Prisma.ZScanVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZScanVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload>[]
          }
          delete: {
            args: Prisma.ZScanVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload>
          }
          update: {
            args: Prisma.ZScanVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload>
          }
          deleteMany: {
            args: Prisma.ZScanVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZScanVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ZScanVerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload>[]
          }
          upsert: {
            args: Prisma.ZScanVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZScanVerificationPayload>
          }
          aggregate: {
            args: Prisma.ZScanVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZScanVerification>
          }
          groupBy: {
            args: Prisma.ZScanVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZScanVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZScanVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<ZScanVerificationCountAggregateOutputType> | number
          }
        }
      }
      SSOConfiguration: {
        payload: Prisma.$SSOConfigurationPayload<ExtArgs>
        fields: Prisma.SSOConfigurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SSOConfigurationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SSOConfigurationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload>
          }
          findFirst: {
            args: Prisma.SSOConfigurationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SSOConfigurationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload>
          }
          findMany: {
            args: Prisma.SSOConfigurationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload>[]
          }
          create: {
            args: Prisma.SSOConfigurationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload>
          }
          createMany: {
            args: Prisma.SSOConfigurationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SSOConfigurationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload>[]
          }
          delete: {
            args: Prisma.SSOConfigurationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload>
          }
          update: {
            args: Prisma.SSOConfigurationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload>
          }
          deleteMany: {
            args: Prisma.SSOConfigurationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SSOConfigurationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SSOConfigurationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload>[]
          }
          upsert: {
            args: Prisma.SSOConfigurationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SSOConfigurationPayload>
          }
          aggregate: {
            args: Prisma.SSOConfigurationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSSOConfiguration>
          }
          groupBy: {
            args: Prisma.SSOConfigurationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SSOConfigurationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SSOConfigurationCountArgs<ExtArgs>
            result: $Utils.Optional<SSOConfigurationCountAggregateOutputType> | number
          }
        }
      }
      NotificationPreference: {
        payload: Prisma.$NotificationPreferencePayload<ExtArgs>
        fields: Prisma.NotificationPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findFirst: {
            args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findMany: {
            args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          create: {
            args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          createMany: {
            args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          delete: {
            args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          update: {
            args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          deleteMany: {
            args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          upsert: {
            args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          aggregate: {
            args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPreference>
          }
          groupBy: {
            args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    organization?: OrganizationOmit
    team?: TeamOmit
    teamMember?: TeamMemberOmit
    auditRecord?: AuditRecordOmit
    block?: BlockOmit
    session?: SessionOmit
    budget?: BudgetOmit
    regressionBaseline?: RegressionBaselineOmit
    feedback?: FeedbackOmit
    bENReceipt?: BENReceiptOmit
    bENSession?: BENSessionOmit
    triTrackHandoff?: TriTrackHandoffOmit
    zScanVerification?: ZScanVerificationOmit
    sSOConfiguration?: SSOConfigurationOmit
    notificationPreference?: NotificationPreferenceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    audits: number
    teams: number
    budgets: number
    regressionBaselines: number
    feedbacks: number
    benReceipts: number
    benSessions: number
    zscans: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    audits?: boolean | UserCountOutputTypeCountAuditsArgs
    teams?: boolean | UserCountOutputTypeCountTeamsArgs
    budgets?: boolean | UserCountOutputTypeCountBudgetsArgs
    regressionBaselines?: boolean | UserCountOutputTypeCountRegressionBaselinesArgs
    feedbacks?: boolean | UserCountOutputTypeCountFeedbacksArgs
    benReceipts?: boolean | UserCountOutputTypeCountBenReceiptsArgs
    benSessions?: boolean | UserCountOutputTypeCountBenSessionsArgs
    zscans?: boolean | UserCountOutputTypeCountZscansArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBudgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRegressionBaselinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegressionBaselineWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBenReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BENReceiptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBenSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BENSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountZscansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZScanVerificationWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    users: number
    teams: number
    ssoConfigs: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | OrganizationCountOutputTypeCountUsersArgs
    teams?: boolean | OrganizationCountOutputTypeCountTeamsArgs
    ssoConfigs?: boolean | OrganizationCountOutputTypeCountSsoConfigsArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountSsoConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SSOConfigurationWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    members: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | TeamCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }


  /**
   * Count Type BENReceiptCountOutputType
   */

  export type BENReceiptCountOutputType = {
    handoffsFrom: number
    handoffsTo: number
  }

  export type BENReceiptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    handoffsFrom?: boolean | BENReceiptCountOutputTypeCountHandoffsFromArgs
    handoffsTo?: boolean | BENReceiptCountOutputTypeCountHandoffsToArgs
  }

  // Custom InputTypes
  /**
   * BENReceiptCountOutputType without action
   */
  export type BENReceiptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceiptCountOutputType
     */
    select?: BENReceiptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BENReceiptCountOutputType without action
   */
  export type BENReceiptCountOutputTypeCountHandoffsFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TriTrackHandoffWhereInput
  }

  /**
   * BENReceiptCountOutputType without action
   */
  export type BENReceiptCountOutputTypeCountHandoffsToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TriTrackHandoffWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    orgId: number | null
    failedLoginAttempts: number | null
    lamportCounter: number | null
    lastReceiptId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    orgId: number | null
    failedLoginAttempts: number | null
    lamportCounter: number | null
    lastReceiptId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.Role | null
    tier: $Enums.UserTier | null
    orgId: number | null
    status: $Enums.UserStatus | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    failedLoginAttempts: number | null
    lockedUntil: Date | null
    passwordChangedAt: Date | null
    ssoProvider: string | null
    ssoId: string | null
    currentPersona: $Enums.BENPersona | null
    personaLocked: boolean | null
    lamportCounter: number | null
    lastReceiptId: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.Role | null
    tier: $Enums.UserTier | null
    orgId: number | null
    status: $Enums.UserStatus | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    failedLoginAttempts: number | null
    lockedUntil: Date | null
    passwordChangedAt: Date | null
    ssoProvider: string | null
    ssoId: string | null
    currentPersona: $Enums.BENPersona | null
    personaLocked: boolean | null
    lamportCounter: number | null
    lastReceiptId: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    role: number
    tier: number
    permissions: number
    orgId: number
    status: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    twoFactorEnabled: number
    twoFactorSecret: number
    backupCodes: number
    failedLoginAttempts: number
    lockedUntil: number
    passwordChangedAt: number
    ssoProvider: number
    ssoId: number
    ssoMetadata: number
    currentPersona: number
    personaLocked: number
    lamportCounter: number
    lastReceiptId: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    orgId?: true
    failedLoginAttempts?: true
    lamportCounter?: true
    lastReceiptId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    orgId?: true
    failedLoginAttempts?: true
    lamportCounter?: true
    lastReceiptId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    tier?: true
    orgId?: true
    status?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    passwordChangedAt?: true
    ssoProvider?: true
    ssoId?: true
    currentPersona?: true
    personaLocked?: true
    lamportCounter?: true
    lastReceiptId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    tier?: true
    orgId?: true
    status?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    passwordChangedAt?: true
    ssoProvider?: true
    ssoId?: true
    currentPersona?: true
    personaLocked?: true
    lamportCounter?: true
    lastReceiptId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    tier?: true
    permissions?: true
    orgId?: true
    status?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    backupCodes?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    passwordChangedAt?: true
    ssoProvider?: true
    ssoId?: true
    ssoMetadata?: true
    currentPersona?: true
    personaLocked?: true
    lamportCounter?: true
    lastReceiptId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    name: string | null
    role: $Enums.Role
    tier: $Enums.UserTier
    permissions: $Enums.Permission[]
    orgId: number | null
    status: $Enums.UserStatus
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    twoFactorEnabled: boolean
    twoFactorSecret: string | null
    backupCodes: string[]
    failedLoginAttempts: number
    lockedUntil: Date | null
    passwordChangedAt: Date | null
    ssoProvider: string | null
    ssoId: string | null
    ssoMetadata: JsonValue | null
    currentPersona: $Enums.BENPersona
    personaLocked: boolean
    lamportCounter: number
    lastReceiptId: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    tier?: boolean
    permissions?: boolean
    orgId?: boolean
    status?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    backupCodes?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    passwordChangedAt?: boolean
    ssoProvider?: boolean
    ssoId?: boolean
    ssoMetadata?: boolean
    currentPersona?: boolean
    personaLocked?: boolean
    lamportCounter?: boolean
    lastReceiptId?: boolean
    organization?: boolean | User$organizationArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    audits?: boolean | User$auditsArgs<ExtArgs>
    teams?: boolean | User$teamsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    budgets?: boolean | User$budgetsArgs<ExtArgs>
    regressionBaselines?: boolean | User$regressionBaselinesArgs<ExtArgs>
    feedbacks?: boolean | User$feedbacksArgs<ExtArgs>
    benReceipts?: boolean | User$benReceiptsArgs<ExtArgs>
    benSessions?: boolean | User$benSessionsArgs<ExtArgs>
    zscans?: boolean | User$zscansArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    tier?: boolean
    permissions?: boolean
    orgId?: boolean
    status?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    backupCodes?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    passwordChangedAt?: boolean
    ssoProvider?: boolean
    ssoId?: boolean
    ssoMetadata?: boolean
    currentPersona?: boolean
    personaLocked?: boolean
    lamportCounter?: boolean
    lastReceiptId?: boolean
    organization?: boolean | User$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    tier?: boolean
    permissions?: boolean
    orgId?: boolean
    status?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    backupCodes?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    passwordChangedAt?: boolean
    ssoProvider?: boolean
    ssoId?: boolean
    ssoMetadata?: boolean
    currentPersona?: boolean
    personaLocked?: boolean
    lamportCounter?: boolean
    lastReceiptId?: boolean
    organization?: boolean | User$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    tier?: boolean
    permissions?: boolean
    orgId?: boolean
    status?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    backupCodes?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    passwordChangedAt?: boolean
    ssoProvider?: boolean
    ssoId?: boolean
    ssoMetadata?: boolean
    currentPersona?: boolean
    personaLocked?: boolean
    lamportCounter?: boolean
    lastReceiptId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "role" | "tier" | "permissions" | "orgId" | "status" | "lastLoginAt" | "createdAt" | "updatedAt" | "twoFactorEnabled" | "twoFactorSecret" | "backupCodes" | "failedLoginAttempts" | "lockedUntil" | "passwordChangedAt" | "ssoProvider" | "ssoId" | "ssoMetadata" | "currentPersona" | "personaLocked" | "lamportCounter" | "lastReceiptId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | User$organizationArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    audits?: boolean | User$auditsArgs<ExtArgs>
    teams?: boolean | User$teamsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    budgets?: boolean | User$budgetsArgs<ExtArgs>
    regressionBaselines?: boolean | User$regressionBaselinesArgs<ExtArgs>
    feedbacks?: boolean | User$feedbacksArgs<ExtArgs>
    benReceipts?: boolean | User$benReceiptsArgs<ExtArgs>
    benSessions?: boolean | User$benSessionsArgs<ExtArgs>
    zscans?: boolean | User$zscansArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | User$organizationArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | User$organizationArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      audits: Prisma.$AuditRecordPayload<ExtArgs>[]
      teams: Prisma.$TeamMemberPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPreferencePayload<ExtArgs> | null
      budgets: Prisma.$BudgetPayload<ExtArgs>[]
      regressionBaselines: Prisma.$RegressionBaselinePayload<ExtArgs>[]
      feedbacks: Prisma.$FeedbackPayload<ExtArgs>[]
      benReceipts: Prisma.$BENReceiptPayload<ExtArgs>[]
      benSessions: Prisma.$BENSessionPayload<ExtArgs>[]
      zscans: Prisma.$ZScanVerificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      name: string | null
      role: $Enums.Role
      tier: $Enums.UserTier
      permissions: $Enums.Permission[]
      orgId: number | null
      status: $Enums.UserStatus
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
      twoFactorEnabled: boolean
      twoFactorSecret: string | null
      backupCodes: string[]
      failedLoginAttempts: number
      lockedUntil: Date | null
      passwordChangedAt: Date | null
      ssoProvider: string | null
      ssoId: string | null
      ssoMetadata: Prisma.JsonValue | null
      currentPersona: $Enums.BENPersona
      personaLocked: boolean
      lamportCounter: number
      lastReceiptId: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends User$organizationArgs<ExtArgs> = {}>(args?: Subset<T, User$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    audits<T extends User$auditsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teams<T extends User$teamsArgs<ExtArgs> = {}>(args?: Subset<T, User$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    budgets<T extends User$budgetsArgs<ExtArgs> = {}>(args?: Subset<T, User$budgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    regressionBaselines<T extends User$regressionBaselinesArgs<ExtArgs> = {}>(args?: Subset<T, User$regressionBaselinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbacks<T extends User$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, User$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    benReceipts<T extends User$benReceiptsArgs<ExtArgs> = {}>(args?: Subset<T, User$benReceiptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    benSessions<T extends User$benSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$benSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zscans<T extends User$zscansArgs<ExtArgs> = {}>(args?: Subset<T, User$zscansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly tier: FieldRef<"User", 'UserTier'>
    readonly permissions: FieldRef<"User", 'Permission[]'>
    readonly orgId: FieldRef<"User", 'Int'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly backupCodes: FieldRef<"User", 'String[]'>
    readonly failedLoginAttempts: FieldRef<"User", 'Int'>
    readonly lockedUntil: FieldRef<"User", 'DateTime'>
    readonly passwordChangedAt: FieldRef<"User", 'DateTime'>
    readonly ssoProvider: FieldRef<"User", 'String'>
    readonly ssoId: FieldRef<"User", 'String'>
    readonly ssoMetadata: FieldRef<"User", 'Json'>
    readonly currentPersona: FieldRef<"User", 'BENPersona'>
    readonly personaLocked: FieldRef<"User", 'Boolean'>
    readonly lamportCounter: FieldRef<"User", 'Int'>
    readonly lastReceiptId: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.organization
   */
  export type User$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.audits
   */
  export type User$auditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    where?: AuditRecordWhereInput
    orderBy?: AuditRecordOrderByWithRelationInput | AuditRecordOrderByWithRelationInput[]
    cursor?: AuditRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditRecordScalarFieldEnum | AuditRecordScalarFieldEnum[]
  }

  /**
   * User.teams
   */
  export type User$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    where?: NotificationPreferenceWhereInput
  }

  /**
   * User.budgets
   */
  export type User$budgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    cursor?: BudgetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * User.regressionBaselines
   */
  export type User$regressionBaselinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
    where?: RegressionBaselineWhereInput
    orderBy?: RegressionBaselineOrderByWithRelationInput | RegressionBaselineOrderByWithRelationInput[]
    cursor?: RegressionBaselineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegressionBaselineScalarFieldEnum | RegressionBaselineScalarFieldEnum[]
  }

  /**
   * User.feedbacks
   */
  export type User$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * User.benReceipts
   */
  export type User$benReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    where?: BENReceiptWhereInput
    orderBy?: BENReceiptOrderByWithRelationInput | BENReceiptOrderByWithRelationInput[]
    cursor?: BENReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BENReceiptScalarFieldEnum | BENReceiptScalarFieldEnum[]
  }

  /**
   * User.benSessions
   */
  export type User$benSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
    where?: BENSessionWhereInput
    orderBy?: BENSessionOrderByWithRelationInput | BENSessionOrderByWithRelationInput[]
    cursor?: BENSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BENSessionScalarFieldEnum | BENSessionScalarFieldEnum[]
  }

  /**
   * User.zscans
   */
  export type User$zscansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
    where?: ZScanVerificationWhereInput
    orderBy?: ZScanVerificationOrderByWithRelationInput | ZScanVerificationOrderByWithRelationInput[]
    cursor?: ZScanVerificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZScanVerificationScalarFieldEnum | ZScanVerificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationAvgAggregateOutputType = {
    id: number | null
  }

  export type OrganizationSumAggregateOutputType = {
    id: number | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: number | null
    name: string | null
    plan: $Enums.PlanType | null
    status: $Enums.OrgStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: number | null
    name: string | null
    plan: $Enums.PlanType | null
    status: $Enums.OrgStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    plan: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationAvgAggregateInputType = {
    id?: true
  }

  export type OrganizationSumAggregateInputType = {
    id?: true
  }

  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    plan?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    plan?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    plan?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _avg?: OrganizationAvgAggregateInputType
    _sum?: OrganizationSumAggregateInputType
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: number
    name: string
    plan: $Enums.PlanType
    status: $Enums.OrgStatus
    createdAt: Date
    updatedAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    plan?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Organization$usersArgs<ExtArgs>
    teams?: boolean | Organization$teamsArgs<ExtArgs>
    ssoConfigs?: boolean | Organization$ssoConfigsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    plan?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    plan?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    plan?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "plan" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Organization$usersArgs<ExtArgs>
    teams?: boolean | Organization$teamsArgs<ExtArgs>
    ssoConfigs?: boolean | Organization$ssoConfigsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      teams: Prisma.$TeamPayload<ExtArgs>[]
      ssoConfigs: Prisma.$SSOConfigurationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      plan: $Enums.PlanType
      status: $Enums.OrgStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Organization$usersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teams<T extends Organization$teamsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ssoConfigs<T extends Organization$ssoConfigsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$ssoConfigsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'Int'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly plan: FieldRef<"Organization", 'PlanType'>
    readonly status: FieldRef<"Organization", 'OrgStatus'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization.users
   */
  export type Organization$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Organization.teams
   */
  export type Organization$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Organization.ssoConfigs
   */
  export type Organization$ssoConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
    where?: SSOConfigurationWhereInput
    orderBy?: SSOConfigurationOrderByWithRelationInput | SSOConfigurationOrderByWithRelationInput[]
    cursor?: SSOConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SSOConfigurationScalarFieldEnum | SSOConfigurationScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    id: number | null
    orgId: number | null
  }

  export type TeamSumAggregateOutputType = {
    id: number | null
    orgId: number | null
  }

  export type TeamMinAggregateOutputType = {
    id: number | null
    name: string | null
    orgId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: number | null
    name: string | null
    orgId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    orgId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    id?: true
    orgId?: true
  }

  export type TeamSumAggregateInputType = {
    id?: true
    orgId?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    orgId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    orgId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    orgId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: number
    name: string
    orgId: number
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "orgId" | "createdAt" | "updatedAt", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      members: Prisma.$TeamMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      orgId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends Team$membersArgs<ExtArgs> = {}>(args?: Subset<T, Team$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'Int'>
    readonly name: FieldRef<"Team", 'String'>
    readonly orgId: FieldRef<"Team", 'Int'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.members
   */
  export type Team$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _avg: TeamMemberAvgAggregateOutputType | null
    _sum: TeamMemberSumAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberAvgAggregateOutputType = {
    id: number | null
    teamId: number | null
    userId: number | null
  }

  export type TeamMemberSumAggregateOutputType = {
    id: number | null
    teamId: number | null
    userId: number | null
  }

  export type TeamMemberMinAggregateOutputType = {
    id: number | null
    teamId: number | null
    userId: number | null
    role: $Enums.TeamRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    id: number | null
    teamId: number | null
    userId: number | null
    role: $Enums.TeamRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMemberCountAggregateOutputType = {
    id: number
    teamId: number
    userId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamMemberAvgAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
  }

  export type TeamMemberSumAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
  }

  export type TeamMemberMinAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMemberCountAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[]
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _avg?: TeamMemberAvgAggregateInputType
    _sum?: TeamMemberSumAggregateInputType
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }

  export type TeamMemberGroupByOutputType = {
    id: number
    teamId: number
    userId: number
    role: $Enums.TeamRole
    createdAt: Date
    updatedAt: Date
    _count: TeamMemberCountAggregateOutputType | null
    _avg: TeamMemberAvgAggregateOutputType | null
    _sum: TeamMemberSumAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectScalar = {
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "userId" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["teamMember"]>
  export type TeamMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMember"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teamId: number
      userId: number
      role: $Enums.TeamRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teamMember"]>
    composites: {}
  }

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> = $Result.GetResult<Prisma.$TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamMemberFindManyArgs>(args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
     */
    create<T extends TeamMemberCreateArgs>(args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMemberCreateManyArgs>(args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamMembers and returns the data saved in the database.
     * @param {TeamMemberCreateManyAndReturnArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
     */
    delete<T extends TeamMemberDeleteArgs>(args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMemberUpdateArgs>(args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers and returns the data updated in the database.
     * @param {TeamMemberUpdateManyAndReturnArgs} args - Arguments to update many TeamMembers.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMember model
   */
  readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMember model
   */
  interface TeamMemberFieldRefs {
    readonly id: FieldRef<"TeamMember", 'Int'>
    readonly teamId: FieldRef<"TeamMember", 'Int'>
    readonly userId: FieldRef<"TeamMember", 'Int'>
    readonly role: FieldRef<"TeamMember", 'TeamRole'>
    readonly createdAt: FieldRef<"TeamMember", 'DateTime'>
    readonly updatedAt: FieldRef<"TeamMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamMember createManyAndReturn
   */
  export type TeamMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
  }

  /**
   * TeamMember updateManyAndReturn
   */
  export type TeamMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to delete.
     */
    limit?: number
  }

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
  }


  /**
   * Model AuditRecord
   */

  export type AggregateAuditRecord = {
    _count: AuditRecordCountAggregateOutputType | null
    _avg: AuditRecordAvgAggregateOutputType | null
    _sum: AuditRecordSumAggregateOutputType | null
    _min: AuditRecordMinAggregateOutputType | null
    _max: AuditRecordMaxAggregateOutputType | null
  }

  export type AuditRecordAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    lamport: number | null
    organizationId: number | null
  }

  export type AuditRecordSumAggregateOutputType = {
    id: number | null
    userId: number | null
    lamport: number | null
    organizationId: number | null
  }

  export type AuditRecordMinAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    category: $Enums.AuditCategory | null
    status: $Enums.AuditStatus | null
    lamport: number | null
    hashPointer: string | null
    organizationId: number | null
    blockHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditRecordMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    category: $Enums.AuditCategory | null
    status: $Enums.AuditStatus | null
    lamport: number | null
    hashPointer: string | null
    organizationId: number | null
    blockHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditRecordCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    category: number
    details: number
    metadata: number
    status: number
    lamport: number
    hashPointer: number
    organizationId: number
    blockHash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuditRecordAvgAggregateInputType = {
    id?: true
    userId?: true
    lamport?: true
    organizationId?: true
  }

  export type AuditRecordSumAggregateInputType = {
    id?: true
    userId?: true
    lamport?: true
    organizationId?: true
  }

  export type AuditRecordMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    category?: true
    status?: true
    lamport?: true
    hashPointer?: true
    organizationId?: true
    blockHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditRecordMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    category?: true
    status?: true
    lamport?: true
    hashPointer?: true
    organizationId?: true
    blockHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditRecordCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    category?: true
    details?: true
    metadata?: true
    status?: true
    lamport?: true
    hashPointer?: true
    organizationId?: true
    blockHash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuditRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditRecord to aggregate.
     */
    where?: AuditRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditRecords to fetch.
     */
    orderBy?: AuditRecordOrderByWithRelationInput | AuditRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditRecords
    **/
    _count?: true | AuditRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditRecordMaxAggregateInputType
  }

  export type GetAuditRecordAggregateType<T extends AuditRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditRecord[P]>
      : GetScalarType<T[P], AggregateAuditRecord[P]>
  }




  export type AuditRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditRecordWhereInput
    orderBy?: AuditRecordOrderByWithAggregationInput | AuditRecordOrderByWithAggregationInput[]
    by: AuditRecordScalarFieldEnum[] | AuditRecordScalarFieldEnum
    having?: AuditRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditRecordCountAggregateInputType | true
    _avg?: AuditRecordAvgAggregateInputType
    _sum?: AuditRecordSumAggregateInputType
    _min?: AuditRecordMinAggregateInputType
    _max?: AuditRecordMaxAggregateInputType
  }

  export type AuditRecordGroupByOutputType = {
    id: number
    userId: number
    action: string
    category: $Enums.AuditCategory
    details: JsonValue | null
    metadata: JsonValue | null
    status: $Enums.AuditStatus
    lamport: number
    hashPointer: string | null
    organizationId: number | null
    blockHash: string | null
    createdAt: Date
    updatedAt: Date
    _count: AuditRecordCountAggregateOutputType | null
    _avg: AuditRecordAvgAggregateOutputType | null
    _sum: AuditRecordSumAggregateOutputType | null
    _min: AuditRecordMinAggregateOutputType | null
    _max: AuditRecordMaxAggregateOutputType | null
  }

  type GetAuditRecordGroupByPayload<T extends AuditRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditRecordGroupByOutputType[P]>
            : GetScalarType<T[P], AuditRecordGroupByOutputType[P]>
        }
      >
    >


  export type AuditRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    category?: boolean
    details?: boolean
    metadata?: boolean
    status?: boolean
    lamport?: boolean
    hashPointer?: boolean
    organizationId?: boolean
    blockHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditRecord"]>

  export type AuditRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    category?: boolean
    details?: boolean
    metadata?: boolean
    status?: boolean
    lamport?: boolean
    hashPointer?: boolean
    organizationId?: boolean
    blockHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditRecord"]>

  export type AuditRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    category?: boolean
    details?: boolean
    metadata?: boolean
    status?: boolean
    lamport?: boolean
    hashPointer?: boolean
    organizationId?: boolean
    blockHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditRecord"]>

  export type AuditRecordSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    category?: boolean
    details?: boolean
    metadata?: boolean
    status?: boolean
    lamport?: boolean
    hashPointer?: boolean
    organizationId?: boolean
    blockHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuditRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "category" | "details" | "metadata" | "status" | "lamport" | "hashPointer" | "organizationId" | "blockHash" | "createdAt" | "updatedAt", ExtArgs["result"]["auditRecord"]>
  export type AuditRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditRecord"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      action: string
      category: $Enums.AuditCategory
      details: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      status: $Enums.AuditStatus
      lamport: number
      hashPointer: string | null
      organizationId: number | null
      blockHash: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["auditRecord"]>
    composites: {}
  }

  type AuditRecordGetPayload<S extends boolean | null | undefined | AuditRecordDefaultArgs> = $Result.GetResult<Prisma.$AuditRecordPayload, S>

  type AuditRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditRecordCountAggregateInputType | true
    }

  export interface AuditRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditRecord'], meta: { name: 'AuditRecord' } }
    /**
     * Find zero or one AuditRecord that matches the filter.
     * @param {AuditRecordFindUniqueArgs} args - Arguments to find a AuditRecord
     * @example
     * // Get one AuditRecord
     * const auditRecord = await prisma.auditRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditRecordFindUniqueArgs>(args: SelectSubset<T, AuditRecordFindUniqueArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditRecordFindUniqueOrThrowArgs} args - Arguments to find a AuditRecord
     * @example
     * // Get one AuditRecord
     * const auditRecord = await prisma.auditRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditRecordFindFirstArgs} args - Arguments to find a AuditRecord
     * @example
     * // Get one AuditRecord
     * const auditRecord = await prisma.auditRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditRecordFindFirstArgs>(args?: SelectSubset<T, AuditRecordFindFirstArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditRecordFindFirstOrThrowArgs} args - Arguments to find a AuditRecord
     * @example
     * // Get one AuditRecord
     * const auditRecord = await prisma.auditRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditRecords
     * const auditRecords = await prisma.auditRecord.findMany()
     * 
     * // Get first 10 AuditRecords
     * const auditRecords = await prisma.auditRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditRecordWithIdOnly = await prisma.auditRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditRecordFindManyArgs>(args?: SelectSubset<T, AuditRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditRecord.
     * @param {AuditRecordCreateArgs} args - Arguments to create a AuditRecord.
     * @example
     * // Create one AuditRecord
     * const AuditRecord = await prisma.auditRecord.create({
     *   data: {
     *     // ... data to create a AuditRecord
     *   }
     * })
     * 
     */
    create<T extends AuditRecordCreateArgs>(args: SelectSubset<T, AuditRecordCreateArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditRecords.
     * @param {AuditRecordCreateManyArgs} args - Arguments to create many AuditRecords.
     * @example
     * // Create many AuditRecords
     * const auditRecord = await prisma.auditRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditRecordCreateManyArgs>(args?: SelectSubset<T, AuditRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditRecords and returns the data saved in the database.
     * @param {AuditRecordCreateManyAndReturnArgs} args - Arguments to create many AuditRecords.
     * @example
     * // Create many AuditRecords
     * const auditRecord = await prisma.auditRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditRecords and only return the `id`
     * const auditRecordWithIdOnly = await prisma.auditRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditRecord.
     * @param {AuditRecordDeleteArgs} args - Arguments to delete one AuditRecord.
     * @example
     * // Delete one AuditRecord
     * const AuditRecord = await prisma.auditRecord.delete({
     *   where: {
     *     // ... filter to delete one AuditRecord
     *   }
     * })
     * 
     */
    delete<T extends AuditRecordDeleteArgs>(args: SelectSubset<T, AuditRecordDeleteArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditRecord.
     * @param {AuditRecordUpdateArgs} args - Arguments to update one AuditRecord.
     * @example
     * // Update one AuditRecord
     * const auditRecord = await prisma.auditRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditRecordUpdateArgs>(args: SelectSubset<T, AuditRecordUpdateArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditRecords.
     * @param {AuditRecordDeleteManyArgs} args - Arguments to filter AuditRecords to delete.
     * @example
     * // Delete a few AuditRecords
     * const { count } = await prisma.auditRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditRecordDeleteManyArgs>(args?: SelectSubset<T, AuditRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditRecords
     * const auditRecord = await prisma.auditRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditRecordUpdateManyArgs>(args: SelectSubset<T, AuditRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditRecords and returns the data updated in the database.
     * @param {AuditRecordUpdateManyAndReturnArgs} args - Arguments to update many AuditRecords.
     * @example
     * // Update many AuditRecords
     * const auditRecord = await prisma.auditRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditRecords and only return the `id`
     * const auditRecordWithIdOnly = await prisma.auditRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditRecord.
     * @param {AuditRecordUpsertArgs} args - Arguments to update or create a AuditRecord.
     * @example
     * // Update or create a AuditRecord
     * const auditRecord = await prisma.auditRecord.upsert({
     *   create: {
     *     // ... data to create a AuditRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditRecord we want to update
     *   }
     * })
     */
    upsert<T extends AuditRecordUpsertArgs>(args: SelectSubset<T, AuditRecordUpsertArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditRecordCountArgs} args - Arguments to filter AuditRecords to count.
     * @example
     * // Count the number of AuditRecords
     * const count = await prisma.auditRecord.count({
     *   where: {
     *     // ... the filter for the AuditRecords we want to count
     *   }
     * })
    **/
    count<T extends AuditRecordCountArgs>(
      args?: Subset<T, AuditRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditRecordAggregateArgs>(args: Subset<T, AuditRecordAggregateArgs>): Prisma.PrismaPromise<GetAuditRecordAggregateType<T>>

    /**
     * Group by AuditRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditRecordGroupByArgs['orderBy'] }
        : { orderBy?: AuditRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditRecord model
   */
  readonly fields: AuditRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditRecord model
   */
  interface AuditRecordFieldRefs {
    readonly id: FieldRef<"AuditRecord", 'Int'>
    readonly userId: FieldRef<"AuditRecord", 'Int'>
    readonly action: FieldRef<"AuditRecord", 'String'>
    readonly category: FieldRef<"AuditRecord", 'AuditCategory'>
    readonly details: FieldRef<"AuditRecord", 'Json'>
    readonly metadata: FieldRef<"AuditRecord", 'Json'>
    readonly status: FieldRef<"AuditRecord", 'AuditStatus'>
    readonly lamport: FieldRef<"AuditRecord", 'Int'>
    readonly hashPointer: FieldRef<"AuditRecord", 'String'>
    readonly organizationId: FieldRef<"AuditRecord", 'Int'>
    readonly blockHash: FieldRef<"AuditRecord", 'String'>
    readonly createdAt: FieldRef<"AuditRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"AuditRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditRecord findUnique
   */
  export type AuditRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * Filter, which AuditRecord to fetch.
     */
    where: AuditRecordWhereUniqueInput
  }

  /**
   * AuditRecord findUniqueOrThrow
   */
  export type AuditRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * Filter, which AuditRecord to fetch.
     */
    where: AuditRecordWhereUniqueInput
  }

  /**
   * AuditRecord findFirst
   */
  export type AuditRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * Filter, which AuditRecord to fetch.
     */
    where?: AuditRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditRecords to fetch.
     */
    orderBy?: AuditRecordOrderByWithRelationInput | AuditRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditRecords.
     */
    cursor?: AuditRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditRecords.
     */
    distinct?: AuditRecordScalarFieldEnum | AuditRecordScalarFieldEnum[]
  }

  /**
   * AuditRecord findFirstOrThrow
   */
  export type AuditRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * Filter, which AuditRecord to fetch.
     */
    where?: AuditRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditRecords to fetch.
     */
    orderBy?: AuditRecordOrderByWithRelationInput | AuditRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditRecords.
     */
    cursor?: AuditRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditRecords.
     */
    distinct?: AuditRecordScalarFieldEnum | AuditRecordScalarFieldEnum[]
  }

  /**
   * AuditRecord findMany
   */
  export type AuditRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * Filter, which AuditRecords to fetch.
     */
    where?: AuditRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditRecords to fetch.
     */
    orderBy?: AuditRecordOrderByWithRelationInput | AuditRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditRecords.
     */
    cursor?: AuditRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditRecords.
     */
    skip?: number
    distinct?: AuditRecordScalarFieldEnum | AuditRecordScalarFieldEnum[]
  }

  /**
   * AuditRecord create
   */
  export type AuditRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditRecord.
     */
    data: XOR<AuditRecordCreateInput, AuditRecordUncheckedCreateInput>
  }

  /**
   * AuditRecord createMany
   */
  export type AuditRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditRecords.
     */
    data: AuditRecordCreateManyInput | AuditRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditRecord createManyAndReturn
   */
  export type AuditRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * The data used to create many AuditRecords.
     */
    data: AuditRecordCreateManyInput | AuditRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditRecord update
   */
  export type AuditRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditRecord.
     */
    data: XOR<AuditRecordUpdateInput, AuditRecordUncheckedUpdateInput>
    /**
     * Choose, which AuditRecord to update.
     */
    where: AuditRecordWhereUniqueInput
  }

  /**
   * AuditRecord updateMany
   */
  export type AuditRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditRecords.
     */
    data: XOR<AuditRecordUpdateManyMutationInput, AuditRecordUncheckedUpdateManyInput>
    /**
     * Filter which AuditRecords to update
     */
    where?: AuditRecordWhereInput
    /**
     * Limit how many AuditRecords to update.
     */
    limit?: number
  }

  /**
   * AuditRecord updateManyAndReturn
   */
  export type AuditRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * The data used to update AuditRecords.
     */
    data: XOR<AuditRecordUpdateManyMutationInput, AuditRecordUncheckedUpdateManyInput>
    /**
     * Filter which AuditRecords to update
     */
    where?: AuditRecordWhereInput
    /**
     * Limit how many AuditRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditRecord upsert
   */
  export type AuditRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditRecord to update in case it exists.
     */
    where: AuditRecordWhereUniqueInput
    /**
     * In case the AuditRecord found by the `where` argument doesn't exist, create a new AuditRecord with this data.
     */
    create: XOR<AuditRecordCreateInput, AuditRecordUncheckedCreateInput>
    /**
     * In case the AuditRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditRecordUpdateInput, AuditRecordUncheckedUpdateInput>
  }

  /**
   * AuditRecord delete
   */
  export type AuditRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * Filter which AuditRecord to delete.
     */
    where: AuditRecordWhereUniqueInput
  }

  /**
   * AuditRecord deleteMany
   */
  export type AuditRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditRecords to delete
     */
    where?: AuditRecordWhereInput
    /**
     * Limit how many AuditRecords to delete.
     */
    limit?: number
  }

  /**
   * AuditRecord without action
   */
  export type AuditRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditRecord
     */
    omit?: AuditRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
  }


  /**
   * Model Block
   */

  export type AggregateBlock = {
    _count: BlockCountAggregateOutputType | null
    _avg: BlockAvgAggregateOutputType | null
    _sum: BlockSumAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  export type BlockAvgAggregateOutputType = {
    id: number | null
    organizationId: number | null
    lamportClock: number | null
  }

  export type BlockSumAggregateOutputType = {
    id: number | null
    organizationId: number | null
    lamportClock: number | null
  }

  export type BlockMinAggregateOutputType = {
    id: number | null
    hash: string | null
    previousHash: string | null
    organizationId: number | null
    lamportClock: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlockMaxAggregateOutputType = {
    id: number | null
    hash: string | null
    previousHash: string | null
    organizationId: number | null
    lamportClock: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlockCountAggregateOutputType = {
    id: number
    hash: number
    previousHash: number
    organizationId: number
    lamportClock: number
    metricsData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlockAvgAggregateInputType = {
    id?: true
    organizationId?: true
    lamportClock?: true
  }

  export type BlockSumAggregateInputType = {
    id?: true
    organizationId?: true
    lamportClock?: true
  }

  export type BlockMinAggregateInputType = {
    id?: true
    hash?: true
    previousHash?: true
    organizationId?: true
    lamportClock?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlockMaxAggregateInputType = {
    id?: true
    hash?: true
    previousHash?: true
    organizationId?: true
    lamportClock?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlockCountAggregateInputType = {
    id?: true
    hash?: true
    previousHash?: true
    organizationId?: true
    lamportClock?: true
    metricsData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Block to aggregate.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blocks
    **/
    _count?: true | BlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockMaxAggregateInputType
  }

  export type GetBlockAggregateType<T extends BlockAggregateArgs> = {
        [P in keyof T & keyof AggregateBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlock[P]>
      : GetScalarType<T[P], AggregateBlock[P]>
  }




  export type BlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithAggregationInput | BlockOrderByWithAggregationInput[]
    by: BlockScalarFieldEnum[] | BlockScalarFieldEnum
    having?: BlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockCountAggregateInputType | true
    _avg?: BlockAvgAggregateInputType
    _sum?: BlockSumAggregateInputType
    _min?: BlockMinAggregateInputType
    _max?: BlockMaxAggregateInputType
  }

  export type BlockGroupByOutputType = {
    id: number
    hash: string
    previousHash: string
    organizationId: number | null
    lamportClock: number
    metricsData: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: BlockCountAggregateOutputType | null
    _avg: BlockAvgAggregateOutputType | null
    _sum: BlockSumAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  type GetBlockGroupByPayload<T extends BlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockGroupByOutputType[P]>
            : GetScalarType<T[P], BlockGroupByOutputType[P]>
        }
      >
    >


  export type BlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash?: boolean
    previousHash?: boolean
    organizationId?: boolean
    lamportClock?: boolean
    metricsData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["block"]>

  export type BlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash?: boolean
    previousHash?: boolean
    organizationId?: boolean
    lamportClock?: boolean
    metricsData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["block"]>

  export type BlockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash?: boolean
    previousHash?: boolean
    organizationId?: boolean
    lamportClock?: boolean
    metricsData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["block"]>

  export type BlockSelectScalar = {
    id?: boolean
    hash?: boolean
    previousHash?: boolean
    organizationId?: boolean
    lamportClock?: boolean
    metricsData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hash" | "previousHash" | "organizationId" | "lamportClock" | "metricsData" | "createdAt" | "updatedAt", ExtArgs["result"]["block"]>

  export type $BlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Block"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hash: string
      previousHash: string
      organizationId: number | null
      lamportClock: number
      metricsData: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["block"]>
    composites: {}
  }

  type BlockGetPayload<S extends boolean | null | undefined | BlockDefaultArgs> = $Result.GetResult<Prisma.$BlockPayload, S>

  type BlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlockCountAggregateInputType | true
    }

  export interface BlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Block'], meta: { name: 'Block' } }
    /**
     * Find zero or one Block that matches the filter.
     * @param {BlockFindUniqueArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockFindUniqueArgs>(args: SelectSubset<T, BlockFindUniqueArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Block that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlockFindUniqueOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Block that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockFindFirstArgs>(args?: SelectSubset<T, BlockFindFirstArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Block that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blocks
     * const blocks = await prisma.block.findMany()
     * 
     * // Get first 10 Blocks
     * const blocks = await prisma.block.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockWithIdOnly = await prisma.block.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockFindManyArgs>(args?: SelectSubset<T, BlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Block.
     * @param {BlockCreateArgs} args - Arguments to create a Block.
     * @example
     * // Create one Block
     * const Block = await prisma.block.create({
     *   data: {
     *     // ... data to create a Block
     *   }
     * })
     * 
     */
    create<T extends BlockCreateArgs>(args: SelectSubset<T, BlockCreateArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blocks.
     * @param {BlockCreateManyArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const block = await prisma.block.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockCreateManyArgs>(args?: SelectSubset<T, BlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blocks and returns the data saved in the database.
     * @param {BlockCreateManyAndReturnArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const block = await prisma.block.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blocks and only return the `id`
     * const blockWithIdOnly = await prisma.block.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Block.
     * @param {BlockDeleteArgs} args - Arguments to delete one Block.
     * @example
     * // Delete one Block
     * const Block = await prisma.block.delete({
     *   where: {
     *     // ... filter to delete one Block
     *   }
     * })
     * 
     */
    delete<T extends BlockDeleteArgs>(args: SelectSubset<T, BlockDeleteArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Block.
     * @param {BlockUpdateArgs} args - Arguments to update one Block.
     * @example
     * // Update one Block
     * const block = await prisma.block.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockUpdateArgs>(args: SelectSubset<T, BlockUpdateArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blocks.
     * @param {BlockDeleteManyArgs} args - Arguments to filter Blocks to delete.
     * @example
     * // Delete a few Blocks
     * const { count } = await prisma.block.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockDeleteManyArgs>(args?: SelectSubset<T, BlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blocks
     * const block = await prisma.block.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockUpdateManyArgs>(args: SelectSubset<T, BlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks and returns the data updated in the database.
     * @param {BlockUpdateManyAndReturnArgs} args - Arguments to update many Blocks.
     * @example
     * // Update many Blocks
     * const block = await prisma.block.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Blocks and only return the `id`
     * const blockWithIdOnly = await prisma.block.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlockUpdateManyAndReturnArgs>(args: SelectSubset<T, BlockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Block.
     * @param {BlockUpsertArgs} args - Arguments to update or create a Block.
     * @example
     * // Update or create a Block
     * const block = await prisma.block.upsert({
     *   create: {
     *     // ... data to create a Block
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Block we want to update
     *   }
     * })
     */
    upsert<T extends BlockUpsertArgs>(args: SelectSubset<T, BlockUpsertArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockCountArgs} args - Arguments to filter Blocks to count.
     * @example
     * // Count the number of Blocks
     * const count = await prisma.block.count({
     *   where: {
     *     // ... the filter for the Blocks we want to count
     *   }
     * })
    **/
    count<T extends BlockCountArgs>(
      args?: Subset<T, BlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockAggregateArgs>(args: Subset<T, BlockAggregateArgs>): Prisma.PrismaPromise<GetBlockAggregateType<T>>

    /**
     * Group by Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockGroupByArgs['orderBy'] }
        : { orderBy?: BlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Block model
   */
  readonly fields: BlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Block.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Block model
   */
  interface BlockFieldRefs {
    readonly id: FieldRef<"Block", 'Int'>
    readonly hash: FieldRef<"Block", 'String'>
    readonly previousHash: FieldRef<"Block", 'String'>
    readonly organizationId: FieldRef<"Block", 'Int'>
    readonly lamportClock: FieldRef<"Block", 'Int'>
    readonly metricsData: FieldRef<"Block", 'Json'>
    readonly createdAt: FieldRef<"Block", 'DateTime'>
    readonly updatedAt: FieldRef<"Block", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Block findUnique
   */
  export type BlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block findUniqueOrThrow
   */
  export type BlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block findFirst
   */
  export type BlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block findFirstOrThrow
   */
  export type BlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block findMany
   */
  export type BlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Filter, which Blocks to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block create
   */
  export type BlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * The data needed to create a Block.
     */
    data: XOR<BlockCreateInput, BlockUncheckedCreateInput>
  }

  /**
   * Block createMany
   */
  export type BlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blocks.
     */
    data: BlockCreateManyInput | BlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Block createManyAndReturn
   */
  export type BlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * The data used to create many Blocks.
     */
    data: BlockCreateManyInput | BlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Block update
   */
  export type BlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * The data needed to update a Block.
     */
    data: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
    /**
     * Choose, which Block to update.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block updateMany
   */
  export type BlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blocks.
     */
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyInput>
    /**
     * Filter which Blocks to update
     */
    where?: BlockWhereInput
    /**
     * Limit how many Blocks to update.
     */
    limit?: number
  }

  /**
   * Block updateManyAndReturn
   */
  export type BlockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * The data used to update Blocks.
     */
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyInput>
    /**
     * Filter which Blocks to update
     */
    where?: BlockWhereInput
    /**
     * Limit how many Blocks to update.
     */
    limit?: number
  }

  /**
   * Block upsert
   */
  export type BlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * The filter to search for the Block to update in case it exists.
     */
    where: BlockWhereUniqueInput
    /**
     * In case the Block found by the `where` argument doesn't exist, create a new Block with this data.
     */
    create: XOR<BlockCreateInput, BlockUncheckedCreateInput>
    /**
     * In case the Block was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
  }

  /**
   * Block delete
   */
  export type BlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Filter which Block to delete.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block deleteMany
   */
  export type BlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blocks to delete
     */
    where?: BlockWhereInput
    /**
     * Limit how many Blocks to delete.
     */
    limit?: number
  }

  /**
   * Block without action
   */
  export type BlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    expiresAt: Date | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date | null
    lastUsedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    expiresAt: Date | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date | null
    lastUsedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    expiresAt: number
    userAgent: number
    ipAddress: number
    createdAt: number
    lastUsedAt: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SessionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    expiresAt?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
    lastUsedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    expiresAt?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
    lastUsedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    expiresAt?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
    lastUsedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: number
    userId: number
    expiresAt: Date
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date
    lastUsedAt: Date
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "expiresAt" | "userAgent" | "ipAddress" | "createdAt" | "lastUsedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      expiresAt: Date
      userAgent: string | null
      ipAddress: string | null
      createdAt: Date
      lastUsedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'Int'>
    readonly userId: FieldRef<"Session", 'Int'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly lastUsedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Budget
   */

  export type AggregateBudget = {
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  export type BudgetAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    limit: number | null
  }

  export type BudgetSumAggregateOutputType = {
    id: number | null
    userId: number | null
    limit: number | null
  }

  export type BudgetMinAggregateOutputType = {
    id: number | null
    userId: number | null
    limit: number | null
    period: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudgetMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    limit: number | null
    period: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudgetCountAggregateOutputType = {
    id: number
    userId: number
    limit: number
    period: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BudgetAvgAggregateInputType = {
    id?: true
    userId?: true
    limit?: true
  }

  export type BudgetSumAggregateInputType = {
    id?: true
    userId?: true
    limit?: true
  }

  export type BudgetMinAggregateInputType = {
    id?: true
    userId?: true
    limit?: true
    period?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudgetMaxAggregateInputType = {
    id?: true
    userId?: true
    limit?: true
    period?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudgetCountAggregateInputType = {
    id?: true
    userId?: true
    limit?: true
    period?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BudgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budget to aggregate.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Budgets
    **/
    _count?: true | BudgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetMaxAggregateInputType
  }

  export type GetBudgetAggregateType<T extends BudgetAggregateArgs> = {
        [P in keyof T & keyof AggregateBudget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudget[P]>
      : GetScalarType<T[P], AggregateBudget[P]>
  }




  export type BudgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithAggregationInput | BudgetOrderByWithAggregationInput[]
    by: BudgetScalarFieldEnum[] | BudgetScalarFieldEnum
    having?: BudgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetCountAggregateInputType | true
    _avg?: BudgetAvgAggregateInputType
    _sum?: BudgetSumAggregateInputType
    _min?: BudgetMinAggregateInputType
    _max?: BudgetMaxAggregateInputType
  }

  export type BudgetGroupByOutputType = {
    id: number
    userId: number
    limit: number
    period: string
    createdAt: Date
    updatedAt: Date
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  type GetBudgetGroupByPayload<T extends BudgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetGroupByOutputType[P]>
        }
      >
    >


  export type BudgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    limit?: boolean
    period?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    limit?: boolean
    period?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    limit?: boolean
    period?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectScalar = {
    id?: boolean
    userId?: boolean
    limit?: boolean
    period?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BudgetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "limit" | "period" | "createdAt" | "updatedAt", ExtArgs["result"]["budget"]>
  export type BudgetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BudgetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BudgetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BudgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Budget"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      limit: number
      period: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["budget"]>
    composites: {}
  }

  type BudgetGetPayload<S extends boolean | null | undefined | BudgetDefaultArgs> = $Result.GetResult<Prisma.$BudgetPayload, S>

  type BudgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BudgetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BudgetCountAggregateInputType | true
    }

  export interface BudgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Budget'], meta: { name: 'Budget' } }
    /**
     * Find zero or one Budget that matches the filter.
     * @param {BudgetFindUniqueArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetFindUniqueArgs>(args: SelectSubset<T, BudgetFindUniqueArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Budget that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BudgetFindUniqueOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetFindFirstArgs>(args?: SelectSubset<T, BudgetFindFirstArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Budgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Budgets
     * const budgets = await prisma.budget.findMany()
     * 
     * // Get first 10 Budgets
     * const budgets = await prisma.budget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetWithIdOnly = await prisma.budget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetFindManyArgs>(args?: SelectSubset<T, BudgetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Budget.
     * @param {BudgetCreateArgs} args - Arguments to create a Budget.
     * @example
     * // Create one Budget
     * const Budget = await prisma.budget.create({
     *   data: {
     *     // ... data to create a Budget
     *   }
     * })
     * 
     */
    create<T extends BudgetCreateArgs>(args: SelectSubset<T, BudgetCreateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Budgets.
     * @param {BudgetCreateManyArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetCreateManyArgs>(args?: SelectSubset<T, BudgetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Budgets and returns the data saved in the database.
     * @param {BudgetCreateManyAndReturnArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Budget.
     * @param {BudgetDeleteArgs} args - Arguments to delete one Budget.
     * @example
     * // Delete one Budget
     * const Budget = await prisma.budget.delete({
     *   where: {
     *     // ... filter to delete one Budget
     *   }
     * })
     * 
     */
    delete<T extends BudgetDeleteArgs>(args: SelectSubset<T, BudgetDeleteArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Budget.
     * @param {BudgetUpdateArgs} args - Arguments to update one Budget.
     * @example
     * // Update one Budget
     * const budget = await prisma.budget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetUpdateArgs>(args: SelectSubset<T, BudgetUpdateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Budgets.
     * @param {BudgetDeleteManyArgs} args - Arguments to filter Budgets to delete.
     * @example
     * // Delete a few Budgets
     * const { count } = await prisma.budget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetDeleteManyArgs>(args?: SelectSubset<T, BudgetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetUpdateManyArgs>(args: SelectSubset<T, BudgetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets and returns the data updated in the database.
     * @param {BudgetUpdateManyAndReturnArgs} args - Arguments to update many Budgets.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BudgetUpdateManyAndReturnArgs>(args: SelectSubset<T, BudgetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Budget.
     * @param {BudgetUpsertArgs} args - Arguments to update or create a Budget.
     * @example
     * // Update or create a Budget
     * const budget = await prisma.budget.upsert({
     *   create: {
     *     // ... data to create a Budget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Budget we want to update
     *   }
     * })
     */
    upsert<T extends BudgetUpsertArgs>(args: SelectSubset<T, BudgetUpsertArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCountArgs} args - Arguments to filter Budgets to count.
     * @example
     * // Count the number of Budgets
     * const count = await prisma.budget.count({
     *   where: {
     *     // ... the filter for the Budgets we want to count
     *   }
     * })
    **/
    count<T extends BudgetCountArgs>(
      args?: Subset<T, BudgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetAggregateArgs>(args: Subset<T, BudgetAggregateArgs>): Prisma.PrismaPromise<GetBudgetAggregateType<T>>

    /**
     * Group by Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetGroupByArgs['orderBy'] }
        : { orderBy?: BudgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Budget model
   */
  readonly fields: BudgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Budget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Budget model
   */
  interface BudgetFieldRefs {
    readonly id: FieldRef<"Budget", 'Int'>
    readonly userId: FieldRef<"Budget", 'Int'>
    readonly limit: FieldRef<"Budget", 'Float'>
    readonly period: FieldRef<"Budget", 'String'>
    readonly createdAt: FieldRef<"Budget", 'DateTime'>
    readonly updatedAt: FieldRef<"Budget", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Budget findUnique
   */
  export type BudgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findUniqueOrThrow
   */
  export type BudgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findFirst
   */
  export type BudgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findFirstOrThrow
   */
  export type BudgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findMany
   */
  export type BudgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budgets to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget create
   */
  export type BudgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to create a Budget.
     */
    data: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
  }

  /**
   * Budget createMany
   */
  export type BudgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Budget createManyAndReturn
   */
  export type BudgetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Budget update
   */
  export type BudgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to update a Budget.
     */
    data: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
    /**
     * Choose, which Budget to update.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget updateMany
   */
  export type BudgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to update.
     */
    limit?: number
  }

  /**
   * Budget updateManyAndReturn
   */
  export type BudgetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Budget upsert
   */
  export type BudgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The filter to search for the Budget to update in case it exists.
     */
    where: BudgetWhereUniqueInput
    /**
     * In case the Budget found by the `where` argument doesn't exist, create a new Budget with this data.
     */
    create: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
    /**
     * In case the Budget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
  }

  /**
   * Budget delete
   */
  export type BudgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter which Budget to delete.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget deleteMany
   */
  export type BudgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budgets to delete
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to delete.
     */
    limit?: number
  }

  /**
   * Budget without action
   */
  export type BudgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
  }


  /**
   * Model RegressionBaseline
   */

  export type AggregateRegressionBaseline = {
    _count: RegressionBaselineCountAggregateOutputType | null
    _avg: RegressionBaselineAvgAggregateOutputType | null
    _sum: RegressionBaselineSumAggregateOutputType | null
    _min: RegressionBaselineMinAggregateOutputType | null
    _max: RegressionBaselineMaxAggregateOutputType | null
  }

  export type RegressionBaselineAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    avgResponseTime: number | null
    avgCost: number | null
    avgQualityScore: number | null
    avgAccuracy: number | null
    successRate: number | null
    alertThreshold: number | null
    sampleSize: number | null
  }

  export type RegressionBaselineSumAggregateOutputType = {
    id: number | null
    userId: number | null
    avgResponseTime: number | null
    avgCost: number | null
    avgQualityScore: number | null
    avgAccuracy: number | null
    successRate: number | null
    alertThreshold: number | null
    sampleSize: number | null
  }

  export type RegressionBaselineMinAggregateOutputType = {
    id: number | null
    userId: number | null
    modelName: string | null
    modelVersion: string | null
    testType: string | null
    avgResponseTime: number | null
    avgCost: number | null
    avgQualityScore: number | null
    avgAccuracy: number | null
    successRate: number | null
    alertThreshold: number | null
    sampleSize: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RegressionBaselineMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    modelName: string | null
    modelVersion: string | null
    testType: string | null
    avgResponseTime: number | null
    avgCost: number | null
    avgQualityScore: number | null
    avgAccuracy: number | null
    successRate: number | null
    alertThreshold: number | null
    sampleSize: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RegressionBaselineCountAggregateOutputType = {
    id: number
    userId: number
    modelName: number
    modelVersion: number
    testType: number
    avgResponseTime: number
    avgCost: number
    avgQualityScore: number
    avgAccuracy: number
    successRate: number
    alertThreshold: number
    sampleSize: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RegressionBaselineAvgAggregateInputType = {
    id?: true
    userId?: true
    avgResponseTime?: true
    avgCost?: true
    avgQualityScore?: true
    avgAccuracy?: true
    successRate?: true
    alertThreshold?: true
    sampleSize?: true
  }

  export type RegressionBaselineSumAggregateInputType = {
    id?: true
    userId?: true
    avgResponseTime?: true
    avgCost?: true
    avgQualityScore?: true
    avgAccuracy?: true
    successRate?: true
    alertThreshold?: true
    sampleSize?: true
  }

  export type RegressionBaselineMinAggregateInputType = {
    id?: true
    userId?: true
    modelName?: true
    modelVersion?: true
    testType?: true
    avgResponseTime?: true
    avgCost?: true
    avgQualityScore?: true
    avgAccuracy?: true
    successRate?: true
    alertThreshold?: true
    sampleSize?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RegressionBaselineMaxAggregateInputType = {
    id?: true
    userId?: true
    modelName?: true
    modelVersion?: true
    testType?: true
    avgResponseTime?: true
    avgCost?: true
    avgQualityScore?: true
    avgAccuracy?: true
    successRate?: true
    alertThreshold?: true
    sampleSize?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RegressionBaselineCountAggregateInputType = {
    id?: true
    userId?: true
    modelName?: true
    modelVersion?: true
    testType?: true
    avgResponseTime?: true
    avgCost?: true
    avgQualityScore?: true
    avgAccuracy?: true
    successRate?: true
    alertThreshold?: true
    sampleSize?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RegressionBaselineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegressionBaseline to aggregate.
     */
    where?: RegressionBaselineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegressionBaselines to fetch.
     */
    orderBy?: RegressionBaselineOrderByWithRelationInput | RegressionBaselineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegressionBaselineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegressionBaselines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegressionBaselines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RegressionBaselines
    **/
    _count?: true | RegressionBaselineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegressionBaselineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegressionBaselineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegressionBaselineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegressionBaselineMaxAggregateInputType
  }

  export type GetRegressionBaselineAggregateType<T extends RegressionBaselineAggregateArgs> = {
        [P in keyof T & keyof AggregateRegressionBaseline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegressionBaseline[P]>
      : GetScalarType<T[P], AggregateRegressionBaseline[P]>
  }




  export type RegressionBaselineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegressionBaselineWhereInput
    orderBy?: RegressionBaselineOrderByWithAggregationInput | RegressionBaselineOrderByWithAggregationInput[]
    by: RegressionBaselineScalarFieldEnum[] | RegressionBaselineScalarFieldEnum
    having?: RegressionBaselineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegressionBaselineCountAggregateInputType | true
    _avg?: RegressionBaselineAvgAggregateInputType
    _sum?: RegressionBaselineSumAggregateInputType
    _min?: RegressionBaselineMinAggregateInputType
    _max?: RegressionBaselineMaxAggregateInputType
  }

  export type RegressionBaselineGroupByOutputType = {
    id: number
    userId: number
    modelName: string
    modelVersion: string | null
    testType: string
    avgResponseTime: number
    avgCost: number
    avgQualityScore: number
    avgAccuracy: number
    successRate: number
    alertThreshold: number
    sampleSize: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: RegressionBaselineCountAggregateOutputType | null
    _avg: RegressionBaselineAvgAggregateOutputType | null
    _sum: RegressionBaselineSumAggregateOutputType | null
    _min: RegressionBaselineMinAggregateOutputType | null
    _max: RegressionBaselineMaxAggregateOutputType | null
  }

  type GetRegressionBaselineGroupByPayload<T extends RegressionBaselineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegressionBaselineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegressionBaselineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegressionBaselineGroupByOutputType[P]>
            : GetScalarType<T[P], RegressionBaselineGroupByOutputType[P]>
        }
      >
    >


  export type RegressionBaselineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    modelName?: boolean
    modelVersion?: boolean
    testType?: boolean
    avgResponseTime?: boolean
    avgCost?: boolean
    avgQualityScore?: boolean
    avgAccuracy?: boolean
    successRate?: boolean
    alertThreshold?: boolean
    sampleSize?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["regressionBaseline"]>

  export type RegressionBaselineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    modelName?: boolean
    modelVersion?: boolean
    testType?: boolean
    avgResponseTime?: boolean
    avgCost?: boolean
    avgQualityScore?: boolean
    avgAccuracy?: boolean
    successRate?: boolean
    alertThreshold?: boolean
    sampleSize?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["regressionBaseline"]>

  export type RegressionBaselineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    modelName?: boolean
    modelVersion?: boolean
    testType?: boolean
    avgResponseTime?: boolean
    avgCost?: boolean
    avgQualityScore?: boolean
    avgAccuracy?: boolean
    successRate?: boolean
    alertThreshold?: boolean
    sampleSize?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["regressionBaseline"]>

  export type RegressionBaselineSelectScalar = {
    id?: boolean
    userId?: boolean
    modelName?: boolean
    modelVersion?: boolean
    testType?: boolean
    avgResponseTime?: boolean
    avgCost?: boolean
    avgQualityScore?: boolean
    avgAccuracy?: boolean
    successRate?: boolean
    alertThreshold?: boolean
    sampleSize?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RegressionBaselineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "modelName" | "modelVersion" | "testType" | "avgResponseTime" | "avgCost" | "avgQualityScore" | "avgAccuracy" | "successRate" | "alertThreshold" | "sampleSize" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["regressionBaseline"]>
  export type RegressionBaselineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RegressionBaselineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RegressionBaselineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RegressionBaselinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RegressionBaseline"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      modelName: string
      modelVersion: string | null
      testType: string
      avgResponseTime: number
      avgCost: number
      avgQualityScore: number
      avgAccuracy: number
      successRate: number
      alertThreshold: number
      sampleSize: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["regressionBaseline"]>
    composites: {}
  }

  type RegressionBaselineGetPayload<S extends boolean | null | undefined | RegressionBaselineDefaultArgs> = $Result.GetResult<Prisma.$RegressionBaselinePayload, S>

  type RegressionBaselineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegressionBaselineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegressionBaselineCountAggregateInputType | true
    }

  export interface RegressionBaselineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RegressionBaseline'], meta: { name: 'RegressionBaseline' } }
    /**
     * Find zero or one RegressionBaseline that matches the filter.
     * @param {RegressionBaselineFindUniqueArgs} args - Arguments to find a RegressionBaseline
     * @example
     * // Get one RegressionBaseline
     * const regressionBaseline = await prisma.regressionBaseline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegressionBaselineFindUniqueArgs>(args: SelectSubset<T, RegressionBaselineFindUniqueArgs<ExtArgs>>): Prisma__RegressionBaselineClient<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RegressionBaseline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegressionBaselineFindUniqueOrThrowArgs} args - Arguments to find a RegressionBaseline
     * @example
     * // Get one RegressionBaseline
     * const regressionBaseline = await prisma.regressionBaseline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegressionBaselineFindUniqueOrThrowArgs>(args: SelectSubset<T, RegressionBaselineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegressionBaselineClient<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegressionBaseline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegressionBaselineFindFirstArgs} args - Arguments to find a RegressionBaseline
     * @example
     * // Get one RegressionBaseline
     * const regressionBaseline = await prisma.regressionBaseline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegressionBaselineFindFirstArgs>(args?: SelectSubset<T, RegressionBaselineFindFirstArgs<ExtArgs>>): Prisma__RegressionBaselineClient<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegressionBaseline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegressionBaselineFindFirstOrThrowArgs} args - Arguments to find a RegressionBaseline
     * @example
     * // Get one RegressionBaseline
     * const regressionBaseline = await prisma.regressionBaseline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegressionBaselineFindFirstOrThrowArgs>(args?: SelectSubset<T, RegressionBaselineFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegressionBaselineClient<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RegressionBaselines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegressionBaselineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RegressionBaselines
     * const regressionBaselines = await prisma.regressionBaseline.findMany()
     * 
     * // Get first 10 RegressionBaselines
     * const regressionBaselines = await prisma.regressionBaseline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regressionBaselineWithIdOnly = await prisma.regressionBaseline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegressionBaselineFindManyArgs>(args?: SelectSubset<T, RegressionBaselineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RegressionBaseline.
     * @param {RegressionBaselineCreateArgs} args - Arguments to create a RegressionBaseline.
     * @example
     * // Create one RegressionBaseline
     * const RegressionBaseline = await prisma.regressionBaseline.create({
     *   data: {
     *     // ... data to create a RegressionBaseline
     *   }
     * })
     * 
     */
    create<T extends RegressionBaselineCreateArgs>(args: SelectSubset<T, RegressionBaselineCreateArgs<ExtArgs>>): Prisma__RegressionBaselineClient<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RegressionBaselines.
     * @param {RegressionBaselineCreateManyArgs} args - Arguments to create many RegressionBaselines.
     * @example
     * // Create many RegressionBaselines
     * const regressionBaseline = await prisma.regressionBaseline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegressionBaselineCreateManyArgs>(args?: SelectSubset<T, RegressionBaselineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RegressionBaselines and returns the data saved in the database.
     * @param {RegressionBaselineCreateManyAndReturnArgs} args - Arguments to create many RegressionBaselines.
     * @example
     * // Create many RegressionBaselines
     * const regressionBaseline = await prisma.regressionBaseline.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RegressionBaselines and only return the `id`
     * const regressionBaselineWithIdOnly = await prisma.regressionBaseline.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegressionBaselineCreateManyAndReturnArgs>(args?: SelectSubset<T, RegressionBaselineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RegressionBaseline.
     * @param {RegressionBaselineDeleteArgs} args - Arguments to delete one RegressionBaseline.
     * @example
     * // Delete one RegressionBaseline
     * const RegressionBaseline = await prisma.regressionBaseline.delete({
     *   where: {
     *     // ... filter to delete one RegressionBaseline
     *   }
     * })
     * 
     */
    delete<T extends RegressionBaselineDeleteArgs>(args: SelectSubset<T, RegressionBaselineDeleteArgs<ExtArgs>>): Prisma__RegressionBaselineClient<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RegressionBaseline.
     * @param {RegressionBaselineUpdateArgs} args - Arguments to update one RegressionBaseline.
     * @example
     * // Update one RegressionBaseline
     * const regressionBaseline = await prisma.regressionBaseline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegressionBaselineUpdateArgs>(args: SelectSubset<T, RegressionBaselineUpdateArgs<ExtArgs>>): Prisma__RegressionBaselineClient<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RegressionBaselines.
     * @param {RegressionBaselineDeleteManyArgs} args - Arguments to filter RegressionBaselines to delete.
     * @example
     * // Delete a few RegressionBaselines
     * const { count } = await prisma.regressionBaseline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegressionBaselineDeleteManyArgs>(args?: SelectSubset<T, RegressionBaselineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegressionBaselines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegressionBaselineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RegressionBaselines
     * const regressionBaseline = await prisma.regressionBaseline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegressionBaselineUpdateManyArgs>(args: SelectSubset<T, RegressionBaselineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegressionBaselines and returns the data updated in the database.
     * @param {RegressionBaselineUpdateManyAndReturnArgs} args - Arguments to update many RegressionBaselines.
     * @example
     * // Update many RegressionBaselines
     * const regressionBaseline = await prisma.regressionBaseline.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RegressionBaselines and only return the `id`
     * const regressionBaselineWithIdOnly = await prisma.regressionBaseline.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RegressionBaselineUpdateManyAndReturnArgs>(args: SelectSubset<T, RegressionBaselineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RegressionBaseline.
     * @param {RegressionBaselineUpsertArgs} args - Arguments to update or create a RegressionBaseline.
     * @example
     * // Update or create a RegressionBaseline
     * const regressionBaseline = await prisma.regressionBaseline.upsert({
     *   create: {
     *     // ... data to create a RegressionBaseline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RegressionBaseline we want to update
     *   }
     * })
     */
    upsert<T extends RegressionBaselineUpsertArgs>(args: SelectSubset<T, RegressionBaselineUpsertArgs<ExtArgs>>): Prisma__RegressionBaselineClient<$Result.GetResult<Prisma.$RegressionBaselinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RegressionBaselines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegressionBaselineCountArgs} args - Arguments to filter RegressionBaselines to count.
     * @example
     * // Count the number of RegressionBaselines
     * const count = await prisma.regressionBaseline.count({
     *   where: {
     *     // ... the filter for the RegressionBaselines we want to count
     *   }
     * })
    **/
    count<T extends RegressionBaselineCountArgs>(
      args?: Subset<T, RegressionBaselineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegressionBaselineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RegressionBaseline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegressionBaselineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegressionBaselineAggregateArgs>(args: Subset<T, RegressionBaselineAggregateArgs>): Prisma.PrismaPromise<GetRegressionBaselineAggregateType<T>>

    /**
     * Group by RegressionBaseline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegressionBaselineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegressionBaselineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegressionBaselineGroupByArgs['orderBy'] }
        : { orderBy?: RegressionBaselineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegressionBaselineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegressionBaselineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RegressionBaseline model
   */
  readonly fields: RegressionBaselineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RegressionBaseline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegressionBaselineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RegressionBaseline model
   */
  interface RegressionBaselineFieldRefs {
    readonly id: FieldRef<"RegressionBaseline", 'Int'>
    readonly userId: FieldRef<"RegressionBaseline", 'Int'>
    readonly modelName: FieldRef<"RegressionBaseline", 'String'>
    readonly modelVersion: FieldRef<"RegressionBaseline", 'String'>
    readonly testType: FieldRef<"RegressionBaseline", 'String'>
    readonly avgResponseTime: FieldRef<"RegressionBaseline", 'Float'>
    readonly avgCost: FieldRef<"RegressionBaseline", 'Float'>
    readonly avgQualityScore: FieldRef<"RegressionBaseline", 'Float'>
    readonly avgAccuracy: FieldRef<"RegressionBaseline", 'Float'>
    readonly successRate: FieldRef<"RegressionBaseline", 'Float'>
    readonly alertThreshold: FieldRef<"RegressionBaseline", 'Float'>
    readonly sampleSize: FieldRef<"RegressionBaseline", 'Int'>
    readonly isActive: FieldRef<"RegressionBaseline", 'Boolean'>
    readonly createdAt: FieldRef<"RegressionBaseline", 'DateTime'>
    readonly updatedAt: FieldRef<"RegressionBaseline", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RegressionBaseline findUnique
   */
  export type RegressionBaselineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
    /**
     * Filter, which RegressionBaseline to fetch.
     */
    where: RegressionBaselineWhereUniqueInput
  }

  /**
   * RegressionBaseline findUniqueOrThrow
   */
  export type RegressionBaselineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
    /**
     * Filter, which RegressionBaseline to fetch.
     */
    where: RegressionBaselineWhereUniqueInput
  }

  /**
   * RegressionBaseline findFirst
   */
  export type RegressionBaselineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
    /**
     * Filter, which RegressionBaseline to fetch.
     */
    where?: RegressionBaselineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegressionBaselines to fetch.
     */
    orderBy?: RegressionBaselineOrderByWithRelationInput | RegressionBaselineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegressionBaselines.
     */
    cursor?: RegressionBaselineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegressionBaselines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegressionBaselines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegressionBaselines.
     */
    distinct?: RegressionBaselineScalarFieldEnum | RegressionBaselineScalarFieldEnum[]
  }

  /**
   * RegressionBaseline findFirstOrThrow
   */
  export type RegressionBaselineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
    /**
     * Filter, which RegressionBaseline to fetch.
     */
    where?: RegressionBaselineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegressionBaselines to fetch.
     */
    orderBy?: RegressionBaselineOrderByWithRelationInput | RegressionBaselineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegressionBaselines.
     */
    cursor?: RegressionBaselineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegressionBaselines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegressionBaselines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegressionBaselines.
     */
    distinct?: RegressionBaselineScalarFieldEnum | RegressionBaselineScalarFieldEnum[]
  }

  /**
   * RegressionBaseline findMany
   */
  export type RegressionBaselineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
    /**
     * Filter, which RegressionBaselines to fetch.
     */
    where?: RegressionBaselineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegressionBaselines to fetch.
     */
    orderBy?: RegressionBaselineOrderByWithRelationInput | RegressionBaselineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RegressionBaselines.
     */
    cursor?: RegressionBaselineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegressionBaselines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegressionBaselines.
     */
    skip?: number
    distinct?: RegressionBaselineScalarFieldEnum | RegressionBaselineScalarFieldEnum[]
  }

  /**
   * RegressionBaseline create
   */
  export type RegressionBaselineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
    /**
     * The data needed to create a RegressionBaseline.
     */
    data: XOR<RegressionBaselineCreateInput, RegressionBaselineUncheckedCreateInput>
  }

  /**
   * RegressionBaseline createMany
   */
  export type RegressionBaselineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RegressionBaselines.
     */
    data: RegressionBaselineCreateManyInput | RegressionBaselineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RegressionBaseline createManyAndReturn
   */
  export type RegressionBaselineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * The data used to create many RegressionBaselines.
     */
    data: RegressionBaselineCreateManyInput | RegressionBaselineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RegressionBaseline update
   */
  export type RegressionBaselineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
    /**
     * The data needed to update a RegressionBaseline.
     */
    data: XOR<RegressionBaselineUpdateInput, RegressionBaselineUncheckedUpdateInput>
    /**
     * Choose, which RegressionBaseline to update.
     */
    where: RegressionBaselineWhereUniqueInput
  }

  /**
   * RegressionBaseline updateMany
   */
  export type RegressionBaselineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RegressionBaselines.
     */
    data: XOR<RegressionBaselineUpdateManyMutationInput, RegressionBaselineUncheckedUpdateManyInput>
    /**
     * Filter which RegressionBaselines to update
     */
    where?: RegressionBaselineWhereInput
    /**
     * Limit how many RegressionBaselines to update.
     */
    limit?: number
  }

  /**
   * RegressionBaseline updateManyAndReturn
   */
  export type RegressionBaselineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * The data used to update RegressionBaselines.
     */
    data: XOR<RegressionBaselineUpdateManyMutationInput, RegressionBaselineUncheckedUpdateManyInput>
    /**
     * Filter which RegressionBaselines to update
     */
    where?: RegressionBaselineWhereInput
    /**
     * Limit how many RegressionBaselines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RegressionBaseline upsert
   */
  export type RegressionBaselineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
    /**
     * The filter to search for the RegressionBaseline to update in case it exists.
     */
    where: RegressionBaselineWhereUniqueInput
    /**
     * In case the RegressionBaseline found by the `where` argument doesn't exist, create a new RegressionBaseline with this data.
     */
    create: XOR<RegressionBaselineCreateInput, RegressionBaselineUncheckedCreateInput>
    /**
     * In case the RegressionBaseline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegressionBaselineUpdateInput, RegressionBaselineUncheckedUpdateInput>
  }

  /**
   * RegressionBaseline delete
   */
  export type RegressionBaselineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
    /**
     * Filter which RegressionBaseline to delete.
     */
    where: RegressionBaselineWhereUniqueInput
  }

  /**
   * RegressionBaseline deleteMany
   */
  export type RegressionBaselineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegressionBaselines to delete
     */
    where?: RegressionBaselineWhereInput
    /**
     * Limit how many RegressionBaselines to delete.
     */
    limit?: number
  }

  /**
   * RegressionBaseline without action
   */
  export type RegressionBaselineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegressionBaseline
     */
    select?: RegressionBaselineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegressionBaseline
     */
    omit?: RegressionBaselineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegressionBaselineInclude<ExtArgs> | null
  }


  /**
   * Model Feedback
   */

  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    assignedTo: number | null
    respondedBy: number | null
    sentimentScore: number | null
    upvotes: number | null
  }

  export type FeedbackSumAggregateOutputType = {
    id: number | null
    userId: number | null
    assignedTo: number | null
    respondedBy: number | null
    sentimentScore: number | null
    upvotes: number | null
  }

  export type FeedbackMinAggregateOutputType = {
    id: number | null
    userId: number | null
    type: $Enums.FeedbackType | null
    category: $Enums.FeedbackCategory | null
    priority: $Enums.FeedbackPriority | null
    subject: string | null
    message: string | null
    url: string | null
    userAgent: string | null
    status: $Enums.FeedbackStatus | null
    assignedTo: number | null
    response: string | null
    respondedAt: Date | null
    respondedBy: number | null
    sentiment: string | null
    sentimentScore: number | null
    upvotes: number | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    resolvedAt: Date | null
  }

  export type FeedbackMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    type: $Enums.FeedbackType | null
    category: $Enums.FeedbackCategory | null
    priority: $Enums.FeedbackPriority | null
    subject: string | null
    message: string | null
    url: string | null
    userAgent: string | null
    status: $Enums.FeedbackStatus | null
    assignedTo: number | null
    response: string | null
    respondedAt: Date | null
    respondedBy: number | null
    sentiment: string | null
    sentimentScore: number | null
    upvotes: number | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    resolvedAt: Date | null
  }

  export type FeedbackCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    category: number
    priority: number
    subject: number
    message: number
    url: number
    userAgent: number
    status: number
    assignedTo: number
    response: number
    respondedAt: number
    respondedBy: number
    sentiment: number
    sentimentScore: number
    upvotes: number
    isPublic: number
    createdAt: number
    updatedAt: number
    resolvedAt: number
    _all: number
  }


  export type FeedbackAvgAggregateInputType = {
    id?: true
    userId?: true
    assignedTo?: true
    respondedBy?: true
    sentimentScore?: true
    upvotes?: true
  }

  export type FeedbackSumAggregateInputType = {
    id?: true
    userId?: true
    assignedTo?: true
    respondedBy?: true
    sentimentScore?: true
    upvotes?: true
  }

  export type FeedbackMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    category?: true
    priority?: true
    subject?: true
    message?: true
    url?: true
    userAgent?: true
    status?: true
    assignedTo?: true
    response?: true
    respondedAt?: true
    respondedBy?: true
    sentiment?: true
    sentimentScore?: true
    upvotes?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
  }

  export type FeedbackMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    category?: true
    priority?: true
    subject?: true
    message?: true
    url?: true
    userAgent?: true
    status?: true
    assignedTo?: true
    response?: true
    respondedAt?: true
    respondedBy?: true
    sentiment?: true
    sentimentScore?: true
    upvotes?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
  }

  export type FeedbackCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    category?: true
    priority?: true
    subject?: true
    message?: true
    url?: true
    userAgent?: true
    status?: true
    assignedTo?: true
    response?: true
    respondedAt?: true
    respondedBy?: true
    sentiment?: true
    sentimentScore?: true
    upvotes?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedback to aggregate.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type FeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithAggregationInput | FeedbackOrderByWithAggregationInput[]
    by: FeedbackScalarFieldEnum[] | FeedbackScalarFieldEnum
    having?: FeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _avg?: FeedbackAvgAggregateInputType
    _sum?: FeedbackSumAggregateInputType
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }

  export type FeedbackGroupByOutputType = {
    id: number
    userId: number
    type: $Enums.FeedbackType
    category: $Enums.FeedbackCategory
    priority: $Enums.FeedbackPriority
    subject: string
    message: string
    url: string | null
    userAgent: string | null
    status: $Enums.FeedbackStatus
    assignedTo: number | null
    response: string | null
    respondedAt: Date | null
    respondedBy: number | null
    sentiment: string | null
    sentimentScore: number | null
    upvotes: number
    isPublic: boolean
    createdAt: Date
    updatedAt: Date
    resolvedAt: Date | null
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    category?: boolean
    priority?: boolean
    subject?: boolean
    message?: boolean
    url?: boolean
    userAgent?: boolean
    status?: boolean
    assignedTo?: boolean
    response?: boolean
    respondedAt?: boolean
    respondedBy?: boolean
    sentiment?: boolean
    sentimentScore?: boolean
    upvotes?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    category?: boolean
    priority?: boolean
    subject?: boolean
    message?: boolean
    url?: boolean
    userAgent?: boolean
    status?: boolean
    assignedTo?: boolean
    response?: boolean
    respondedAt?: boolean
    respondedBy?: boolean
    sentiment?: boolean
    sentimentScore?: boolean
    upvotes?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    category?: boolean
    priority?: boolean
    subject?: boolean
    message?: boolean
    url?: boolean
    userAgent?: boolean
    status?: boolean
    assignedTo?: boolean
    response?: boolean
    respondedAt?: boolean
    respondedBy?: boolean
    sentiment?: boolean
    sentimentScore?: boolean
    upvotes?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    category?: boolean
    priority?: boolean
    subject?: boolean
    message?: boolean
    url?: boolean
    userAgent?: boolean
    status?: boolean
    assignedTo?: boolean
    response?: boolean
    respondedAt?: boolean
    respondedBy?: boolean
    sentiment?: boolean
    sentimentScore?: boolean
    upvotes?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
  }

  export type FeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "category" | "priority" | "subject" | "message" | "url" | "userAgent" | "status" | "assignedTo" | "response" | "respondedAt" | "respondedBy" | "sentiment" | "sentimentScore" | "upvotes" | "isPublic" | "createdAt" | "updatedAt" | "resolvedAt", ExtArgs["result"]["feedback"]>
  export type FeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeedbackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feedback"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      type: $Enums.FeedbackType
      category: $Enums.FeedbackCategory
      priority: $Enums.FeedbackPriority
      subject: string
      message: string
      url: string | null
      userAgent: string | null
      status: $Enums.FeedbackStatus
      assignedTo: number | null
      response: string | null
      respondedAt: Date | null
      respondedBy: number | null
      sentiment: string | null
      sentimentScore: number | null
      upvotes: number
      isPublic: boolean
      createdAt: Date
      updatedAt: Date
      resolvedAt: Date | null
    }, ExtArgs["result"]["feedback"]>
    composites: {}
  }

  type FeedbackGetPayload<S extends boolean | null | undefined | FeedbackDefaultArgs> = $Result.GetResult<Prisma.$FeedbackPayload, S>

  type FeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface FeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feedback'], meta: { name: 'Feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {FeedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedbackFindUniqueArgs>(args: SelectSubset<T, FeedbackFindUniqueArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedbackFindFirstArgs>(args?: SelectSubset<T, FeedbackFindFirstArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackWithIdOnly = await prisma.feedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedbackFindManyArgs>(args?: SelectSubset<T, FeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feedback.
     * @param {FeedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
     */
    create<T extends FeedbackCreateArgs>(args: SelectSubset<T, FeedbackCreateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Feedbacks.
     * @param {FeedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedbackCreateManyArgs>(args?: SelectSubset<T, FeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feedbacks and returns the data saved in the database.
     * @param {FeedbackCreateManyAndReturnArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feedbacks and only return the `id`
     * const feedbackWithIdOnly = await prisma.feedback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Feedback.
     * @param {FeedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
     */
    delete<T extends FeedbackDeleteArgs>(args: SelectSubset<T, FeedbackDeleteArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feedback.
     * @param {FeedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedbackUpdateArgs>(args: SelectSubset<T, FeedbackUpdateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedbackDeleteManyArgs>(args?: SelectSubset<T, FeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedbackUpdateManyArgs>(args: SelectSubset<T, FeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks and returns the data updated in the database.
     * @param {FeedbackUpdateManyAndReturnArgs} args - Arguments to update many Feedbacks.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Feedbacks and only return the `id`
     * const feedbackWithIdOnly = await prisma.feedback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeedbackUpdateManyAndReturnArgs>(args: SelectSubset<T, FeedbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Feedback.
     * @param {FeedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
     */
    upsert<T extends FeedbackUpsertArgs>(args: SelectSubset<T, FeedbackUpsertArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbackCountArgs>(
      args?: Subset<T, FeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feedback model
   */
  readonly fields: FeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feedback model
   */
  interface FeedbackFieldRefs {
    readonly id: FieldRef<"Feedback", 'Int'>
    readonly userId: FieldRef<"Feedback", 'Int'>
    readonly type: FieldRef<"Feedback", 'FeedbackType'>
    readonly category: FieldRef<"Feedback", 'FeedbackCategory'>
    readonly priority: FieldRef<"Feedback", 'FeedbackPriority'>
    readonly subject: FieldRef<"Feedback", 'String'>
    readonly message: FieldRef<"Feedback", 'String'>
    readonly url: FieldRef<"Feedback", 'String'>
    readonly userAgent: FieldRef<"Feedback", 'String'>
    readonly status: FieldRef<"Feedback", 'FeedbackStatus'>
    readonly assignedTo: FieldRef<"Feedback", 'Int'>
    readonly response: FieldRef<"Feedback", 'String'>
    readonly respondedAt: FieldRef<"Feedback", 'DateTime'>
    readonly respondedBy: FieldRef<"Feedback", 'Int'>
    readonly sentiment: FieldRef<"Feedback", 'String'>
    readonly sentimentScore: FieldRef<"Feedback", 'Float'>
    readonly upvotes: FieldRef<"Feedback", 'Int'>
    readonly isPublic: FieldRef<"Feedback", 'Boolean'>
    readonly createdAt: FieldRef<"Feedback", 'DateTime'>
    readonly updatedAt: FieldRef<"Feedback", 'DateTime'>
    readonly resolvedAt: FieldRef<"Feedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Feedback findUnique
   */
  export type FeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findUniqueOrThrow
   */
  export type FeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findFirst
   */
  export type FeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findFirstOrThrow
   */
  export type FeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findMany
   */
  export type FeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedbacks to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback create
   */
  export type FeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a Feedback.
     */
    data: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
  }

  /**
   * Feedback createMany
   */
  export type FeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feedback createManyAndReturn
   */
  export type FeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feedback update
   */
  export type FeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a Feedback.
     */
    data: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
    /**
     * Choose, which Feedback to update.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback updateMany
   */
  export type FeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to update.
     */
    limit?: number
  }

  /**
   * Feedback updateManyAndReturn
   */
  export type FeedbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feedback upsert
   */
  export type FeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the Feedback to update in case it exists.
     */
    where: FeedbackWhereUniqueInput
    /**
     * In case the Feedback found by the `where` argument doesn't exist, create a new Feedback with this data.
     */
    create: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
    /**
     * In case the Feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
  }

  /**
   * Feedback delete
   */
  export type FeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter which Feedback to delete.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback deleteMany
   */
  export type FeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedbacks to delete
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to delete.
     */
    limit?: number
  }

  /**
   * Feedback without action
   */
  export type FeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
  }


  /**
   * Model BENReceipt
   */

  export type AggregateBENReceipt = {
    _count: BENReceiptCountAggregateOutputType | null
    _avg: BENReceiptAvgAggregateOutputType | null
    _sum: BENReceiptSumAggregateOutputType | null
    _min: BENReceiptMinAggregateOutputType | null
    _max: BENReceiptMaxAggregateOutputType | null
  }

  export type BENReceiptAvgAggregateOutputType = {
    id: number | null
    lamportClock: number | null
    userId: number | null
  }

  export type BENReceiptSumAggregateOutputType = {
    id: number | null
    lamportClock: number | null
    userId: number | null
  }

  export type BENReceiptMinAggregateOutputType = {
    id: number | null
    receiptType: $Enums.ReceiptType | null
    lamportClock: number | null
    realTimestamp: Date | null
    userId: number | null
    persona: $Enums.BENPersona | null
    track: $Enums.TrackType | null
    digest: string | null
    previousDigest: string | null
    baselineDigest: string | null
    witnessModel: string | null
    witnessSignature: string | null
    createdAt: Date | null
  }

  export type BENReceiptMaxAggregateOutputType = {
    id: number | null
    receiptType: $Enums.ReceiptType | null
    lamportClock: number | null
    realTimestamp: Date | null
    userId: number | null
    persona: $Enums.BENPersona | null
    track: $Enums.TrackType | null
    digest: string | null
    previousDigest: string | null
    baselineDigest: string | null
    witnessModel: string | null
    witnessSignature: string | null
    createdAt: Date | null
  }

  export type BENReceiptCountAggregateOutputType = {
    id: number
    receiptType: number
    lamportClock: number
    realTimestamp: number
    userId: number
    persona: number
    track: number
    payload: number
    digest: number
    previousDigest: number
    baselineDigest: number
    witnessModel: number
    witnessSignature: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type BENReceiptAvgAggregateInputType = {
    id?: true
    lamportClock?: true
    userId?: true
  }

  export type BENReceiptSumAggregateInputType = {
    id?: true
    lamportClock?: true
    userId?: true
  }

  export type BENReceiptMinAggregateInputType = {
    id?: true
    receiptType?: true
    lamportClock?: true
    realTimestamp?: true
    userId?: true
    persona?: true
    track?: true
    digest?: true
    previousDigest?: true
    baselineDigest?: true
    witnessModel?: true
    witnessSignature?: true
    createdAt?: true
  }

  export type BENReceiptMaxAggregateInputType = {
    id?: true
    receiptType?: true
    lamportClock?: true
    realTimestamp?: true
    userId?: true
    persona?: true
    track?: true
    digest?: true
    previousDigest?: true
    baselineDigest?: true
    witnessModel?: true
    witnessSignature?: true
    createdAt?: true
  }

  export type BENReceiptCountAggregateInputType = {
    id?: true
    receiptType?: true
    lamportClock?: true
    realTimestamp?: true
    userId?: true
    persona?: true
    track?: true
    payload?: true
    digest?: true
    previousDigest?: true
    baselineDigest?: true
    witnessModel?: true
    witnessSignature?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type BENReceiptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BENReceipt to aggregate.
     */
    where?: BENReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BENReceipts to fetch.
     */
    orderBy?: BENReceiptOrderByWithRelationInput | BENReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BENReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BENReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BENReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BENReceipts
    **/
    _count?: true | BENReceiptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BENReceiptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BENReceiptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BENReceiptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BENReceiptMaxAggregateInputType
  }

  export type GetBENReceiptAggregateType<T extends BENReceiptAggregateArgs> = {
        [P in keyof T & keyof AggregateBENReceipt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBENReceipt[P]>
      : GetScalarType<T[P], AggregateBENReceipt[P]>
  }




  export type BENReceiptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BENReceiptWhereInput
    orderBy?: BENReceiptOrderByWithAggregationInput | BENReceiptOrderByWithAggregationInput[]
    by: BENReceiptScalarFieldEnum[] | BENReceiptScalarFieldEnum
    having?: BENReceiptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BENReceiptCountAggregateInputType | true
    _avg?: BENReceiptAvgAggregateInputType
    _sum?: BENReceiptSumAggregateInputType
    _min?: BENReceiptMinAggregateInputType
    _max?: BENReceiptMaxAggregateInputType
  }

  export type BENReceiptGroupByOutputType = {
    id: number
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp: Date
    userId: number | null
    persona: $Enums.BENPersona
    track: $Enums.TrackType | null
    payload: JsonValue
    digest: string
    previousDigest: string | null
    baselineDigest: string | null
    witnessModel: string | null
    witnessSignature: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: BENReceiptCountAggregateOutputType | null
    _avg: BENReceiptAvgAggregateOutputType | null
    _sum: BENReceiptSumAggregateOutputType | null
    _min: BENReceiptMinAggregateOutputType | null
    _max: BENReceiptMaxAggregateOutputType | null
  }

  type GetBENReceiptGroupByPayload<T extends BENReceiptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BENReceiptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BENReceiptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BENReceiptGroupByOutputType[P]>
            : GetScalarType<T[P], BENReceiptGroupByOutputType[P]>
        }
      >
    >


  export type BENReceiptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptType?: boolean
    lamportClock?: boolean
    realTimestamp?: boolean
    userId?: boolean
    persona?: boolean
    track?: boolean
    payload?: boolean
    digest?: boolean
    previousDigest?: boolean
    baselineDigest?: boolean
    witnessModel?: boolean
    witnessSignature?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | BENReceipt$userArgs<ExtArgs>
    handoffsFrom?: boolean | BENReceipt$handoffsFromArgs<ExtArgs>
    handoffsTo?: boolean | BENReceipt$handoffsToArgs<ExtArgs>
    _count?: boolean | BENReceiptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bENReceipt"]>

  export type BENReceiptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptType?: boolean
    lamportClock?: boolean
    realTimestamp?: boolean
    userId?: boolean
    persona?: boolean
    track?: boolean
    payload?: boolean
    digest?: boolean
    previousDigest?: boolean
    baselineDigest?: boolean
    witnessModel?: boolean
    witnessSignature?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | BENReceipt$userArgs<ExtArgs>
  }, ExtArgs["result"]["bENReceipt"]>

  export type BENReceiptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptType?: boolean
    lamportClock?: boolean
    realTimestamp?: boolean
    userId?: boolean
    persona?: boolean
    track?: boolean
    payload?: boolean
    digest?: boolean
    previousDigest?: boolean
    baselineDigest?: boolean
    witnessModel?: boolean
    witnessSignature?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | BENReceipt$userArgs<ExtArgs>
  }, ExtArgs["result"]["bENReceipt"]>

  export type BENReceiptSelectScalar = {
    id?: boolean
    receiptType?: boolean
    lamportClock?: boolean
    realTimestamp?: boolean
    userId?: boolean
    persona?: boolean
    track?: boolean
    payload?: boolean
    digest?: boolean
    previousDigest?: boolean
    baselineDigest?: boolean
    witnessModel?: boolean
    witnessSignature?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type BENReceiptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "receiptType" | "lamportClock" | "realTimestamp" | "userId" | "persona" | "track" | "payload" | "digest" | "previousDigest" | "baselineDigest" | "witnessModel" | "witnessSignature" | "metadata" | "createdAt", ExtArgs["result"]["bENReceipt"]>
  export type BENReceiptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BENReceipt$userArgs<ExtArgs>
    handoffsFrom?: boolean | BENReceipt$handoffsFromArgs<ExtArgs>
    handoffsTo?: boolean | BENReceipt$handoffsToArgs<ExtArgs>
    _count?: boolean | BENReceiptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BENReceiptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BENReceipt$userArgs<ExtArgs>
  }
  export type BENReceiptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BENReceipt$userArgs<ExtArgs>
  }

  export type $BENReceiptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BENReceipt"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      handoffsFrom: Prisma.$TriTrackHandoffPayload<ExtArgs>[]
      handoffsTo: Prisma.$TriTrackHandoffPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      receiptType: $Enums.ReceiptType
      lamportClock: number
      realTimestamp: Date
      userId: number | null
      persona: $Enums.BENPersona
      track: $Enums.TrackType | null
      payload: Prisma.JsonValue
      digest: string
      previousDigest: string | null
      baselineDigest: string | null
      witnessModel: string | null
      witnessSignature: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["bENReceipt"]>
    composites: {}
  }

  type BENReceiptGetPayload<S extends boolean | null | undefined | BENReceiptDefaultArgs> = $Result.GetResult<Prisma.$BENReceiptPayload, S>

  type BENReceiptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BENReceiptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BENReceiptCountAggregateInputType | true
    }

  export interface BENReceiptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BENReceipt'], meta: { name: 'BENReceipt' } }
    /**
     * Find zero or one BENReceipt that matches the filter.
     * @param {BENReceiptFindUniqueArgs} args - Arguments to find a BENReceipt
     * @example
     * // Get one BENReceipt
     * const bENReceipt = await prisma.bENReceipt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BENReceiptFindUniqueArgs>(args: SelectSubset<T, BENReceiptFindUniqueArgs<ExtArgs>>): Prisma__BENReceiptClient<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BENReceipt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BENReceiptFindUniqueOrThrowArgs} args - Arguments to find a BENReceipt
     * @example
     * // Get one BENReceipt
     * const bENReceipt = await prisma.bENReceipt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BENReceiptFindUniqueOrThrowArgs>(args: SelectSubset<T, BENReceiptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BENReceiptClient<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BENReceipt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENReceiptFindFirstArgs} args - Arguments to find a BENReceipt
     * @example
     * // Get one BENReceipt
     * const bENReceipt = await prisma.bENReceipt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BENReceiptFindFirstArgs>(args?: SelectSubset<T, BENReceiptFindFirstArgs<ExtArgs>>): Prisma__BENReceiptClient<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BENReceipt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENReceiptFindFirstOrThrowArgs} args - Arguments to find a BENReceipt
     * @example
     * // Get one BENReceipt
     * const bENReceipt = await prisma.bENReceipt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BENReceiptFindFirstOrThrowArgs>(args?: SelectSubset<T, BENReceiptFindFirstOrThrowArgs<ExtArgs>>): Prisma__BENReceiptClient<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BENReceipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENReceiptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BENReceipts
     * const bENReceipts = await prisma.bENReceipt.findMany()
     * 
     * // Get first 10 BENReceipts
     * const bENReceipts = await prisma.bENReceipt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bENReceiptWithIdOnly = await prisma.bENReceipt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BENReceiptFindManyArgs>(args?: SelectSubset<T, BENReceiptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BENReceipt.
     * @param {BENReceiptCreateArgs} args - Arguments to create a BENReceipt.
     * @example
     * // Create one BENReceipt
     * const BENReceipt = await prisma.bENReceipt.create({
     *   data: {
     *     // ... data to create a BENReceipt
     *   }
     * })
     * 
     */
    create<T extends BENReceiptCreateArgs>(args: SelectSubset<T, BENReceiptCreateArgs<ExtArgs>>): Prisma__BENReceiptClient<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BENReceipts.
     * @param {BENReceiptCreateManyArgs} args - Arguments to create many BENReceipts.
     * @example
     * // Create many BENReceipts
     * const bENReceipt = await prisma.bENReceipt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BENReceiptCreateManyArgs>(args?: SelectSubset<T, BENReceiptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BENReceipts and returns the data saved in the database.
     * @param {BENReceiptCreateManyAndReturnArgs} args - Arguments to create many BENReceipts.
     * @example
     * // Create many BENReceipts
     * const bENReceipt = await prisma.bENReceipt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BENReceipts and only return the `id`
     * const bENReceiptWithIdOnly = await prisma.bENReceipt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BENReceiptCreateManyAndReturnArgs>(args?: SelectSubset<T, BENReceiptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BENReceipt.
     * @param {BENReceiptDeleteArgs} args - Arguments to delete one BENReceipt.
     * @example
     * // Delete one BENReceipt
     * const BENReceipt = await prisma.bENReceipt.delete({
     *   where: {
     *     // ... filter to delete one BENReceipt
     *   }
     * })
     * 
     */
    delete<T extends BENReceiptDeleteArgs>(args: SelectSubset<T, BENReceiptDeleteArgs<ExtArgs>>): Prisma__BENReceiptClient<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BENReceipt.
     * @param {BENReceiptUpdateArgs} args - Arguments to update one BENReceipt.
     * @example
     * // Update one BENReceipt
     * const bENReceipt = await prisma.bENReceipt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BENReceiptUpdateArgs>(args: SelectSubset<T, BENReceiptUpdateArgs<ExtArgs>>): Prisma__BENReceiptClient<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BENReceipts.
     * @param {BENReceiptDeleteManyArgs} args - Arguments to filter BENReceipts to delete.
     * @example
     * // Delete a few BENReceipts
     * const { count } = await prisma.bENReceipt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BENReceiptDeleteManyArgs>(args?: SelectSubset<T, BENReceiptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BENReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENReceiptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BENReceipts
     * const bENReceipt = await prisma.bENReceipt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BENReceiptUpdateManyArgs>(args: SelectSubset<T, BENReceiptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BENReceipts and returns the data updated in the database.
     * @param {BENReceiptUpdateManyAndReturnArgs} args - Arguments to update many BENReceipts.
     * @example
     * // Update many BENReceipts
     * const bENReceipt = await prisma.bENReceipt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BENReceipts and only return the `id`
     * const bENReceiptWithIdOnly = await prisma.bENReceipt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BENReceiptUpdateManyAndReturnArgs>(args: SelectSubset<T, BENReceiptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BENReceipt.
     * @param {BENReceiptUpsertArgs} args - Arguments to update or create a BENReceipt.
     * @example
     * // Update or create a BENReceipt
     * const bENReceipt = await prisma.bENReceipt.upsert({
     *   create: {
     *     // ... data to create a BENReceipt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BENReceipt we want to update
     *   }
     * })
     */
    upsert<T extends BENReceiptUpsertArgs>(args: SelectSubset<T, BENReceiptUpsertArgs<ExtArgs>>): Prisma__BENReceiptClient<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BENReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENReceiptCountArgs} args - Arguments to filter BENReceipts to count.
     * @example
     * // Count the number of BENReceipts
     * const count = await prisma.bENReceipt.count({
     *   where: {
     *     // ... the filter for the BENReceipts we want to count
     *   }
     * })
    **/
    count<T extends BENReceiptCountArgs>(
      args?: Subset<T, BENReceiptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BENReceiptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BENReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENReceiptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BENReceiptAggregateArgs>(args: Subset<T, BENReceiptAggregateArgs>): Prisma.PrismaPromise<GetBENReceiptAggregateType<T>>

    /**
     * Group by BENReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENReceiptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BENReceiptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BENReceiptGroupByArgs['orderBy'] }
        : { orderBy?: BENReceiptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BENReceiptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBENReceiptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BENReceipt model
   */
  readonly fields: BENReceiptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BENReceipt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BENReceiptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends BENReceipt$userArgs<ExtArgs> = {}>(args?: Subset<T, BENReceipt$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    handoffsFrom<T extends BENReceipt$handoffsFromArgs<ExtArgs> = {}>(args?: Subset<T, BENReceipt$handoffsFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    handoffsTo<T extends BENReceipt$handoffsToArgs<ExtArgs> = {}>(args?: Subset<T, BENReceipt$handoffsToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BENReceipt model
   */
  interface BENReceiptFieldRefs {
    readonly id: FieldRef<"BENReceipt", 'Int'>
    readonly receiptType: FieldRef<"BENReceipt", 'ReceiptType'>
    readonly lamportClock: FieldRef<"BENReceipt", 'Int'>
    readonly realTimestamp: FieldRef<"BENReceipt", 'DateTime'>
    readonly userId: FieldRef<"BENReceipt", 'Int'>
    readonly persona: FieldRef<"BENReceipt", 'BENPersona'>
    readonly track: FieldRef<"BENReceipt", 'TrackType'>
    readonly payload: FieldRef<"BENReceipt", 'Json'>
    readonly digest: FieldRef<"BENReceipt", 'String'>
    readonly previousDigest: FieldRef<"BENReceipt", 'String'>
    readonly baselineDigest: FieldRef<"BENReceipt", 'String'>
    readonly witnessModel: FieldRef<"BENReceipt", 'String'>
    readonly witnessSignature: FieldRef<"BENReceipt", 'String'>
    readonly metadata: FieldRef<"BENReceipt", 'Json'>
    readonly createdAt: FieldRef<"BENReceipt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BENReceipt findUnique
   */
  export type BENReceiptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    /**
     * Filter, which BENReceipt to fetch.
     */
    where: BENReceiptWhereUniqueInput
  }

  /**
   * BENReceipt findUniqueOrThrow
   */
  export type BENReceiptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    /**
     * Filter, which BENReceipt to fetch.
     */
    where: BENReceiptWhereUniqueInput
  }

  /**
   * BENReceipt findFirst
   */
  export type BENReceiptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    /**
     * Filter, which BENReceipt to fetch.
     */
    where?: BENReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BENReceipts to fetch.
     */
    orderBy?: BENReceiptOrderByWithRelationInput | BENReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BENReceipts.
     */
    cursor?: BENReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BENReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BENReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BENReceipts.
     */
    distinct?: BENReceiptScalarFieldEnum | BENReceiptScalarFieldEnum[]
  }

  /**
   * BENReceipt findFirstOrThrow
   */
  export type BENReceiptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    /**
     * Filter, which BENReceipt to fetch.
     */
    where?: BENReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BENReceipts to fetch.
     */
    orderBy?: BENReceiptOrderByWithRelationInput | BENReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BENReceipts.
     */
    cursor?: BENReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BENReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BENReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BENReceipts.
     */
    distinct?: BENReceiptScalarFieldEnum | BENReceiptScalarFieldEnum[]
  }

  /**
   * BENReceipt findMany
   */
  export type BENReceiptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    /**
     * Filter, which BENReceipts to fetch.
     */
    where?: BENReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BENReceipts to fetch.
     */
    orderBy?: BENReceiptOrderByWithRelationInput | BENReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BENReceipts.
     */
    cursor?: BENReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BENReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BENReceipts.
     */
    skip?: number
    distinct?: BENReceiptScalarFieldEnum | BENReceiptScalarFieldEnum[]
  }

  /**
   * BENReceipt create
   */
  export type BENReceiptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    /**
     * The data needed to create a BENReceipt.
     */
    data: XOR<BENReceiptCreateInput, BENReceiptUncheckedCreateInput>
  }

  /**
   * BENReceipt createMany
   */
  export type BENReceiptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BENReceipts.
     */
    data: BENReceiptCreateManyInput | BENReceiptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BENReceipt createManyAndReturn
   */
  export type BENReceiptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * The data used to create many BENReceipts.
     */
    data: BENReceiptCreateManyInput | BENReceiptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BENReceipt update
   */
  export type BENReceiptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    /**
     * The data needed to update a BENReceipt.
     */
    data: XOR<BENReceiptUpdateInput, BENReceiptUncheckedUpdateInput>
    /**
     * Choose, which BENReceipt to update.
     */
    where: BENReceiptWhereUniqueInput
  }

  /**
   * BENReceipt updateMany
   */
  export type BENReceiptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BENReceipts.
     */
    data: XOR<BENReceiptUpdateManyMutationInput, BENReceiptUncheckedUpdateManyInput>
    /**
     * Filter which BENReceipts to update
     */
    where?: BENReceiptWhereInput
    /**
     * Limit how many BENReceipts to update.
     */
    limit?: number
  }

  /**
   * BENReceipt updateManyAndReturn
   */
  export type BENReceiptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * The data used to update BENReceipts.
     */
    data: XOR<BENReceiptUpdateManyMutationInput, BENReceiptUncheckedUpdateManyInput>
    /**
     * Filter which BENReceipts to update
     */
    where?: BENReceiptWhereInput
    /**
     * Limit how many BENReceipts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BENReceipt upsert
   */
  export type BENReceiptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    /**
     * The filter to search for the BENReceipt to update in case it exists.
     */
    where: BENReceiptWhereUniqueInput
    /**
     * In case the BENReceipt found by the `where` argument doesn't exist, create a new BENReceipt with this data.
     */
    create: XOR<BENReceiptCreateInput, BENReceiptUncheckedCreateInput>
    /**
     * In case the BENReceipt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BENReceiptUpdateInput, BENReceiptUncheckedUpdateInput>
  }

  /**
   * BENReceipt delete
   */
  export type BENReceiptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    /**
     * Filter which BENReceipt to delete.
     */
    where: BENReceiptWhereUniqueInput
  }

  /**
   * BENReceipt deleteMany
   */
  export type BENReceiptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BENReceipts to delete
     */
    where?: BENReceiptWhereInput
    /**
     * Limit how many BENReceipts to delete.
     */
    limit?: number
  }

  /**
   * BENReceipt.user
   */
  export type BENReceipt$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * BENReceipt.handoffsFrom
   */
  export type BENReceipt$handoffsFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    where?: TriTrackHandoffWhereInput
    orderBy?: TriTrackHandoffOrderByWithRelationInput | TriTrackHandoffOrderByWithRelationInput[]
    cursor?: TriTrackHandoffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TriTrackHandoffScalarFieldEnum | TriTrackHandoffScalarFieldEnum[]
  }

  /**
   * BENReceipt.handoffsTo
   */
  export type BENReceipt$handoffsToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    where?: TriTrackHandoffWhereInput
    orderBy?: TriTrackHandoffOrderByWithRelationInput | TriTrackHandoffOrderByWithRelationInput[]
    cursor?: TriTrackHandoffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TriTrackHandoffScalarFieldEnum | TriTrackHandoffScalarFieldEnum[]
  }

  /**
   * BENReceipt without action
   */
  export type BENReceiptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
  }


  /**
   * Model BENSession
   */

  export type AggregateBENSession = {
    _count: BENSessionCountAggregateOutputType | null
    _avg: BENSessionAvgAggregateOutputType | null
    _sum: BENSessionSumAggregateOutputType | null
    _min: BENSessionMinAggregateOutputType | null
    _max: BENSessionMaxAggregateOutputType | null
  }

  export type BENSessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    priority: number | null
    duration: number | null
    startLamport: number | null
    endLamport: number | null
  }

  export type BENSessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
    priority: number | null
    duration: number | null
    startLamport: number | null
    endLamport: number | null
  }

  export type BENSessionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    persona: $Enums.BENPersona | null
    priority: number | null
    locked: boolean | null
    startedAt: Date | null
    endedAt: Date | null
    duration: number | null
    startLamport: number | null
    endLamport: number | null
    switchReason: string | null
  }

  export type BENSessionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    persona: $Enums.BENPersona | null
    priority: number | null
    locked: boolean | null
    startedAt: Date | null
    endedAt: Date | null
    duration: number | null
    startLamport: number | null
    endLamport: number | null
    switchReason: string | null
  }

  export type BENSessionCountAggregateOutputType = {
    id: number
    userId: number
    persona: number
    priority: number
    locked: number
    startedAt: number
    endedAt: number
    duration: number
    startLamport: number
    endLamport: number
    switchReason: number
    metadata: number
    _all: number
  }


  export type BENSessionAvgAggregateInputType = {
    id?: true
    userId?: true
    priority?: true
    duration?: true
    startLamport?: true
    endLamport?: true
  }

  export type BENSessionSumAggregateInputType = {
    id?: true
    userId?: true
    priority?: true
    duration?: true
    startLamport?: true
    endLamport?: true
  }

  export type BENSessionMinAggregateInputType = {
    id?: true
    userId?: true
    persona?: true
    priority?: true
    locked?: true
    startedAt?: true
    endedAt?: true
    duration?: true
    startLamport?: true
    endLamport?: true
    switchReason?: true
  }

  export type BENSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    persona?: true
    priority?: true
    locked?: true
    startedAt?: true
    endedAt?: true
    duration?: true
    startLamport?: true
    endLamport?: true
    switchReason?: true
  }

  export type BENSessionCountAggregateInputType = {
    id?: true
    userId?: true
    persona?: true
    priority?: true
    locked?: true
    startedAt?: true
    endedAt?: true
    duration?: true
    startLamport?: true
    endLamport?: true
    switchReason?: true
    metadata?: true
    _all?: true
  }

  export type BENSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BENSession to aggregate.
     */
    where?: BENSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BENSessions to fetch.
     */
    orderBy?: BENSessionOrderByWithRelationInput | BENSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BENSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BENSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BENSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BENSessions
    **/
    _count?: true | BENSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BENSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BENSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BENSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BENSessionMaxAggregateInputType
  }

  export type GetBENSessionAggregateType<T extends BENSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateBENSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBENSession[P]>
      : GetScalarType<T[P], AggregateBENSession[P]>
  }




  export type BENSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BENSessionWhereInput
    orderBy?: BENSessionOrderByWithAggregationInput | BENSessionOrderByWithAggregationInput[]
    by: BENSessionScalarFieldEnum[] | BENSessionScalarFieldEnum
    having?: BENSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BENSessionCountAggregateInputType | true
    _avg?: BENSessionAvgAggregateInputType
    _sum?: BENSessionSumAggregateInputType
    _min?: BENSessionMinAggregateInputType
    _max?: BENSessionMaxAggregateInputType
  }

  export type BENSessionGroupByOutputType = {
    id: number
    userId: number
    persona: $Enums.BENPersona
    priority: number
    locked: boolean
    startedAt: Date
    endedAt: Date | null
    duration: number | null
    startLamport: number
    endLamport: number | null
    switchReason: string | null
    metadata: JsonValue | null
    _count: BENSessionCountAggregateOutputType | null
    _avg: BENSessionAvgAggregateOutputType | null
    _sum: BENSessionSumAggregateOutputType | null
    _min: BENSessionMinAggregateOutputType | null
    _max: BENSessionMaxAggregateOutputType | null
  }

  type GetBENSessionGroupByPayload<T extends BENSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BENSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BENSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BENSessionGroupByOutputType[P]>
            : GetScalarType<T[P], BENSessionGroupByOutputType[P]>
        }
      >
    >


  export type BENSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    persona?: boolean
    priority?: boolean
    locked?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    startLamport?: boolean
    endLamport?: boolean
    switchReason?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bENSession"]>

  export type BENSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    persona?: boolean
    priority?: boolean
    locked?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    startLamport?: boolean
    endLamport?: boolean
    switchReason?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bENSession"]>

  export type BENSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    persona?: boolean
    priority?: boolean
    locked?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    startLamport?: boolean
    endLamport?: boolean
    switchReason?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bENSession"]>

  export type BENSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    persona?: boolean
    priority?: boolean
    locked?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    startLamport?: boolean
    endLamport?: boolean
    switchReason?: boolean
    metadata?: boolean
  }

  export type BENSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "persona" | "priority" | "locked" | "startedAt" | "endedAt" | "duration" | "startLamport" | "endLamport" | "switchReason" | "metadata", ExtArgs["result"]["bENSession"]>
  export type BENSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BENSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BENSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BENSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BENSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      persona: $Enums.BENPersona
      priority: number
      locked: boolean
      startedAt: Date
      endedAt: Date | null
      duration: number | null
      startLamport: number
      endLamport: number | null
      switchReason: string | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["bENSession"]>
    composites: {}
  }

  type BENSessionGetPayload<S extends boolean | null | undefined | BENSessionDefaultArgs> = $Result.GetResult<Prisma.$BENSessionPayload, S>

  type BENSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BENSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BENSessionCountAggregateInputType | true
    }

  export interface BENSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BENSession'], meta: { name: 'BENSession' } }
    /**
     * Find zero or one BENSession that matches the filter.
     * @param {BENSessionFindUniqueArgs} args - Arguments to find a BENSession
     * @example
     * // Get one BENSession
     * const bENSession = await prisma.bENSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BENSessionFindUniqueArgs>(args: SelectSubset<T, BENSessionFindUniqueArgs<ExtArgs>>): Prisma__BENSessionClient<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BENSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BENSessionFindUniqueOrThrowArgs} args - Arguments to find a BENSession
     * @example
     * // Get one BENSession
     * const bENSession = await prisma.bENSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BENSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, BENSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BENSessionClient<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BENSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENSessionFindFirstArgs} args - Arguments to find a BENSession
     * @example
     * // Get one BENSession
     * const bENSession = await prisma.bENSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BENSessionFindFirstArgs>(args?: SelectSubset<T, BENSessionFindFirstArgs<ExtArgs>>): Prisma__BENSessionClient<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BENSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENSessionFindFirstOrThrowArgs} args - Arguments to find a BENSession
     * @example
     * // Get one BENSession
     * const bENSession = await prisma.bENSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BENSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, BENSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BENSessionClient<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BENSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BENSessions
     * const bENSessions = await prisma.bENSession.findMany()
     * 
     * // Get first 10 BENSessions
     * const bENSessions = await prisma.bENSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bENSessionWithIdOnly = await prisma.bENSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BENSessionFindManyArgs>(args?: SelectSubset<T, BENSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BENSession.
     * @param {BENSessionCreateArgs} args - Arguments to create a BENSession.
     * @example
     * // Create one BENSession
     * const BENSession = await prisma.bENSession.create({
     *   data: {
     *     // ... data to create a BENSession
     *   }
     * })
     * 
     */
    create<T extends BENSessionCreateArgs>(args: SelectSubset<T, BENSessionCreateArgs<ExtArgs>>): Prisma__BENSessionClient<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BENSessions.
     * @param {BENSessionCreateManyArgs} args - Arguments to create many BENSessions.
     * @example
     * // Create many BENSessions
     * const bENSession = await prisma.bENSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BENSessionCreateManyArgs>(args?: SelectSubset<T, BENSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BENSessions and returns the data saved in the database.
     * @param {BENSessionCreateManyAndReturnArgs} args - Arguments to create many BENSessions.
     * @example
     * // Create many BENSessions
     * const bENSession = await prisma.bENSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BENSessions and only return the `id`
     * const bENSessionWithIdOnly = await prisma.bENSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BENSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, BENSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BENSession.
     * @param {BENSessionDeleteArgs} args - Arguments to delete one BENSession.
     * @example
     * // Delete one BENSession
     * const BENSession = await prisma.bENSession.delete({
     *   where: {
     *     // ... filter to delete one BENSession
     *   }
     * })
     * 
     */
    delete<T extends BENSessionDeleteArgs>(args: SelectSubset<T, BENSessionDeleteArgs<ExtArgs>>): Prisma__BENSessionClient<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BENSession.
     * @param {BENSessionUpdateArgs} args - Arguments to update one BENSession.
     * @example
     * // Update one BENSession
     * const bENSession = await prisma.bENSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BENSessionUpdateArgs>(args: SelectSubset<T, BENSessionUpdateArgs<ExtArgs>>): Prisma__BENSessionClient<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BENSessions.
     * @param {BENSessionDeleteManyArgs} args - Arguments to filter BENSessions to delete.
     * @example
     * // Delete a few BENSessions
     * const { count } = await prisma.bENSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BENSessionDeleteManyArgs>(args?: SelectSubset<T, BENSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BENSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BENSessions
     * const bENSession = await prisma.bENSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BENSessionUpdateManyArgs>(args: SelectSubset<T, BENSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BENSessions and returns the data updated in the database.
     * @param {BENSessionUpdateManyAndReturnArgs} args - Arguments to update many BENSessions.
     * @example
     * // Update many BENSessions
     * const bENSession = await prisma.bENSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BENSessions and only return the `id`
     * const bENSessionWithIdOnly = await prisma.bENSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BENSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, BENSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BENSession.
     * @param {BENSessionUpsertArgs} args - Arguments to update or create a BENSession.
     * @example
     * // Update or create a BENSession
     * const bENSession = await prisma.bENSession.upsert({
     *   create: {
     *     // ... data to create a BENSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BENSession we want to update
     *   }
     * })
     */
    upsert<T extends BENSessionUpsertArgs>(args: SelectSubset<T, BENSessionUpsertArgs<ExtArgs>>): Prisma__BENSessionClient<$Result.GetResult<Prisma.$BENSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BENSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENSessionCountArgs} args - Arguments to filter BENSessions to count.
     * @example
     * // Count the number of BENSessions
     * const count = await prisma.bENSession.count({
     *   where: {
     *     // ... the filter for the BENSessions we want to count
     *   }
     * })
    **/
    count<T extends BENSessionCountArgs>(
      args?: Subset<T, BENSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BENSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BENSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BENSessionAggregateArgs>(args: Subset<T, BENSessionAggregateArgs>): Prisma.PrismaPromise<GetBENSessionAggregateType<T>>

    /**
     * Group by BENSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BENSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BENSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BENSessionGroupByArgs['orderBy'] }
        : { orderBy?: BENSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BENSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBENSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BENSession model
   */
  readonly fields: BENSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BENSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BENSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BENSession model
   */
  interface BENSessionFieldRefs {
    readonly id: FieldRef<"BENSession", 'Int'>
    readonly userId: FieldRef<"BENSession", 'Int'>
    readonly persona: FieldRef<"BENSession", 'BENPersona'>
    readonly priority: FieldRef<"BENSession", 'Int'>
    readonly locked: FieldRef<"BENSession", 'Boolean'>
    readonly startedAt: FieldRef<"BENSession", 'DateTime'>
    readonly endedAt: FieldRef<"BENSession", 'DateTime'>
    readonly duration: FieldRef<"BENSession", 'Int'>
    readonly startLamport: FieldRef<"BENSession", 'Int'>
    readonly endLamport: FieldRef<"BENSession", 'Int'>
    readonly switchReason: FieldRef<"BENSession", 'String'>
    readonly metadata: FieldRef<"BENSession", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * BENSession findUnique
   */
  export type BENSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
    /**
     * Filter, which BENSession to fetch.
     */
    where: BENSessionWhereUniqueInput
  }

  /**
   * BENSession findUniqueOrThrow
   */
  export type BENSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
    /**
     * Filter, which BENSession to fetch.
     */
    where: BENSessionWhereUniqueInput
  }

  /**
   * BENSession findFirst
   */
  export type BENSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
    /**
     * Filter, which BENSession to fetch.
     */
    where?: BENSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BENSessions to fetch.
     */
    orderBy?: BENSessionOrderByWithRelationInput | BENSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BENSessions.
     */
    cursor?: BENSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BENSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BENSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BENSessions.
     */
    distinct?: BENSessionScalarFieldEnum | BENSessionScalarFieldEnum[]
  }

  /**
   * BENSession findFirstOrThrow
   */
  export type BENSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
    /**
     * Filter, which BENSession to fetch.
     */
    where?: BENSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BENSessions to fetch.
     */
    orderBy?: BENSessionOrderByWithRelationInput | BENSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BENSessions.
     */
    cursor?: BENSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BENSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BENSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BENSessions.
     */
    distinct?: BENSessionScalarFieldEnum | BENSessionScalarFieldEnum[]
  }

  /**
   * BENSession findMany
   */
  export type BENSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
    /**
     * Filter, which BENSessions to fetch.
     */
    where?: BENSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BENSessions to fetch.
     */
    orderBy?: BENSessionOrderByWithRelationInput | BENSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BENSessions.
     */
    cursor?: BENSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BENSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BENSessions.
     */
    skip?: number
    distinct?: BENSessionScalarFieldEnum | BENSessionScalarFieldEnum[]
  }

  /**
   * BENSession create
   */
  export type BENSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a BENSession.
     */
    data: XOR<BENSessionCreateInput, BENSessionUncheckedCreateInput>
  }

  /**
   * BENSession createMany
   */
  export type BENSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BENSessions.
     */
    data: BENSessionCreateManyInput | BENSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BENSession createManyAndReturn
   */
  export type BENSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * The data used to create many BENSessions.
     */
    data: BENSessionCreateManyInput | BENSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BENSession update
   */
  export type BENSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a BENSession.
     */
    data: XOR<BENSessionUpdateInput, BENSessionUncheckedUpdateInput>
    /**
     * Choose, which BENSession to update.
     */
    where: BENSessionWhereUniqueInput
  }

  /**
   * BENSession updateMany
   */
  export type BENSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BENSessions.
     */
    data: XOR<BENSessionUpdateManyMutationInput, BENSessionUncheckedUpdateManyInput>
    /**
     * Filter which BENSessions to update
     */
    where?: BENSessionWhereInput
    /**
     * Limit how many BENSessions to update.
     */
    limit?: number
  }

  /**
   * BENSession updateManyAndReturn
   */
  export type BENSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * The data used to update BENSessions.
     */
    data: XOR<BENSessionUpdateManyMutationInput, BENSessionUncheckedUpdateManyInput>
    /**
     * Filter which BENSessions to update
     */
    where?: BENSessionWhereInput
    /**
     * Limit how many BENSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BENSession upsert
   */
  export type BENSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the BENSession to update in case it exists.
     */
    where: BENSessionWhereUniqueInput
    /**
     * In case the BENSession found by the `where` argument doesn't exist, create a new BENSession with this data.
     */
    create: XOR<BENSessionCreateInput, BENSessionUncheckedCreateInput>
    /**
     * In case the BENSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BENSessionUpdateInput, BENSessionUncheckedUpdateInput>
  }

  /**
   * BENSession delete
   */
  export type BENSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
    /**
     * Filter which BENSession to delete.
     */
    where: BENSessionWhereUniqueInput
  }

  /**
   * BENSession deleteMany
   */
  export type BENSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BENSessions to delete
     */
    where?: BENSessionWhereInput
    /**
     * Limit how many BENSessions to delete.
     */
    limit?: number
  }

  /**
   * BENSession without action
   */
  export type BENSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENSession
     */
    select?: BENSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENSession
     */
    omit?: BENSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENSessionInclude<ExtArgs> | null
  }


  /**
   * Model TriTrackHandoff
   */

  export type AggregateTriTrackHandoff = {
    _count: TriTrackHandoffCountAggregateOutputType | null
    _avg: TriTrackHandoffAvgAggregateOutputType | null
    _sum: TriTrackHandoffSumAggregateOutputType | null
    _min: TriTrackHandoffMinAggregateOutputType | null
    _max: TriTrackHandoffMaxAggregateOutputType | null
  }

  export type TriTrackHandoffAvgAggregateOutputType = {
    id: number | null
    fromReceiptId: number | null
    toReceiptId: number | null
    latencyMs: number | null
  }

  export type TriTrackHandoffSumAggregateOutputType = {
    id: number | null
    fromReceiptId: number | null
    toReceiptId: number | null
    latencyMs: number | null
  }

  export type TriTrackHandoffMinAggregateOutputType = {
    id: number | null
    fromTrack: $Enums.TrackType | null
    toTrack: $Enums.TrackType | null
    status: $Enums.HandoffStatus | null
    fromReceiptId: number | null
    toReceiptId: number | null
    initiatedAt: Date | null
    completedAt: Date | null
    latencyMs: number | null
    exceededLimit: boolean | null
    errorMessage: string | null
  }

  export type TriTrackHandoffMaxAggregateOutputType = {
    id: number | null
    fromTrack: $Enums.TrackType | null
    toTrack: $Enums.TrackType | null
    status: $Enums.HandoffStatus | null
    fromReceiptId: number | null
    toReceiptId: number | null
    initiatedAt: Date | null
    completedAt: Date | null
    latencyMs: number | null
    exceededLimit: boolean | null
    errorMessage: string | null
  }

  export type TriTrackHandoffCountAggregateOutputType = {
    id: number
    fromTrack: number
    toTrack: number
    status: number
    fromReceiptId: number
    toReceiptId: number
    initiatedAt: number
    completedAt: number
    latencyMs: number
    exceededLimit: number
    payload: number
    result: number
    errorMessage: number
    metadata: number
    _all: number
  }


  export type TriTrackHandoffAvgAggregateInputType = {
    id?: true
    fromReceiptId?: true
    toReceiptId?: true
    latencyMs?: true
  }

  export type TriTrackHandoffSumAggregateInputType = {
    id?: true
    fromReceiptId?: true
    toReceiptId?: true
    latencyMs?: true
  }

  export type TriTrackHandoffMinAggregateInputType = {
    id?: true
    fromTrack?: true
    toTrack?: true
    status?: true
    fromReceiptId?: true
    toReceiptId?: true
    initiatedAt?: true
    completedAt?: true
    latencyMs?: true
    exceededLimit?: true
    errorMessage?: true
  }

  export type TriTrackHandoffMaxAggregateInputType = {
    id?: true
    fromTrack?: true
    toTrack?: true
    status?: true
    fromReceiptId?: true
    toReceiptId?: true
    initiatedAt?: true
    completedAt?: true
    latencyMs?: true
    exceededLimit?: true
    errorMessage?: true
  }

  export type TriTrackHandoffCountAggregateInputType = {
    id?: true
    fromTrack?: true
    toTrack?: true
    status?: true
    fromReceiptId?: true
    toReceiptId?: true
    initiatedAt?: true
    completedAt?: true
    latencyMs?: true
    exceededLimit?: true
    payload?: true
    result?: true
    errorMessage?: true
    metadata?: true
    _all?: true
  }

  export type TriTrackHandoffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TriTrackHandoff to aggregate.
     */
    where?: TriTrackHandoffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriTrackHandoffs to fetch.
     */
    orderBy?: TriTrackHandoffOrderByWithRelationInput | TriTrackHandoffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TriTrackHandoffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriTrackHandoffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriTrackHandoffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TriTrackHandoffs
    **/
    _count?: true | TriTrackHandoffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TriTrackHandoffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TriTrackHandoffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TriTrackHandoffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TriTrackHandoffMaxAggregateInputType
  }

  export type GetTriTrackHandoffAggregateType<T extends TriTrackHandoffAggregateArgs> = {
        [P in keyof T & keyof AggregateTriTrackHandoff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTriTrackHandoff[P]>
      : GetScalarType<T[P], AggregateTriTrackHandoff[P]>
  }




  export type TriTrackHandoffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TriTrackHandoffWhereInput
    orderBy?: TriTrackHandoffOrderByWithAggregationInput | TriTrackHandoffOrderByWithAggregationInput[]
    by: TriTrackHandoffScalarFieldEnum[] | TriTrackHandoffScalarFieldEnum
    having?: TriTrackHandoffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TriTrackHandoffCountAggregateInputType | true
    _avg?: TriTrackHandoffAvgAggregateInputType
    _sum?: TriTrackHandoffSumAggregateInputType
    _min?: TriTrackHandoffMinAggregateInputType
    _max?: TriTrackHandoffMaxAggregateInputType
  }

  export type TriTrackHandoffGroupByOutputType = {
    id: number
    fromTrack: $Enums.TrackType
    toTrack: $Enums.TrackType
    status: $Enums.HandoffStatus
    fromReceiptId: number
    toReceiptId: number | null
    initiatedAt: Date
    completedAt: Date | null
    latencyMs: number | null
    exceededLimit: boolean
    payload: JsonValue
    result: JsonValue | null
    errorMessage: string | null
    metadata: JsonValue | null
    _count: TriTrackHandoffCountAggregateOutputType | null
    _avg: TriTrackHandoffAvgAggregateOutputType | null
    _sum: TriTrackHandoffSumAggregateOutputType | null
    _min: TriTrackHandoffMinAggregateOutputType | null
    _max: TriTrackHandoffMaxAggregateOutputType | null
  }

  type GetTriTrackHandoffGroupByPayload<T extends TriTrackHandoffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TriTrackHandoffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TriTrackHandoffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TriTrackHandoffGroupByOutputType[P]>
            : GetScalarType<T[P], TriTrackHandoffGroupByOutputType[P]>
        }
      >
    >


  export type TriTrackHandoffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromTrack?: boolean
    toTrack?: boolean
    status?: boolean
    fromReceiptId?: boolean
    toReceiptId?: boolean
    initiatedAt?: boolean
    completedAt?: boolean
    latencyMs?: boolean
    exceededLimit?: boolean
    payload?: boolean
    result?: boolean
    errorMessage?: boolean
    metadata?: boolean
    fromReceipt?: boolean | BENReceiptDefaultArgs<ExtArgs>
    toReceipt?: boolean | TriTrackHandoff$toReceiptArgs<ExtArgs>
  }, ExtArgs["result"]["triTrackHandoff"]>

  export type TriTrackHandoffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromTrack?: boolean
    toTrack?: boolean
    status?: boolean
    fromReceiptId?: boolean
    toReceiptId?: boolean
    initiatedAt?: boolean
    completedAt?: boolean
    latencyMs?: boolean
    exceededLimit?: boolean
    payload?: boolean
    result?: boolean
    errorMessage?: boolean
    metadata?: boolean
    fromReceipt?: boolean | BENReceiptDefaultArgs<ExtArgs>
    toReceipt?: boolean | TriTrackHandoff$toReceiptArgs<ExtArgs>
  }, ExtArgs["result"]["triTrackHandoff"]>

  export type TriTrackHandoffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromTrack?: boolean
    toTrack?: boolean
    status?: boolean
    fromReceiptId?: boolean
    toReceiptId?: boolean
    initiatedAt?: boolean
    completedAt?: boolean
    latencyMs?: boolean
    exceededLimit?: boolean
    payload?: boolean
    result?: boolean
    errorMessage?: boolean
    metadata?: boolean
    fromReceipt?: boolean | BENReceiptDefaultArgs<ExtArgs>
    toReceipt?: boolean | TriTrackHandoff$toReceiptArgs<ExtArgs>
  }, ExtArgs["result"]["triTrackHandoff"]>

  export type TriTrackHandoffSelectScalar = {
    id?: boolean
    fromTrack?: boolean
    toTrack?: boolean
    status?: boolean
    fromReceiptId?: boolean
    toReceiptId?: boolean
    initiatedAt?: boolean
    completedAt?: boolean
    latencyMs?: boolean
    exceededLimit?: boolean
    payload?: boolean
    result?: boolean
    errorMessage?: boolean
    metadata?: boolean
  }

  export type TriTrackHandoffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fromTrack" | "toTrack" | "status" | "fromReceiptId" | "toReceiptId" | "initiatedAt" | "completedAt" | "latencyMs" | "exceededLimit" | "payload" | "result" | "errorMessage" | "metadata", ExtArgs["result"]["triTrackHandoff"]>
  export type TriTrackHandoffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromReceipt?: boolean | BENReceiptDefaultArgs<ExtArgs>
    toReceipt?: boolean | TriTrackHandoff$toReceiptArgs<ExtArgs>
  }
  export type TriTrackHandoffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromReceipt?: boolean | BENReceiptDefaultArgs<ExtArgs>
    toReceipt?: boolean | TriTrackHandoff$toReceiptArgs<ExtArgs>
  }
  export type TriTrackHandoffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromReceipt?: boolean | BENReceiptDefaultArgs<ExtArgs>
    toReceipt?: boolean | TriTrackHandoff$toReceiptArgs<ExtArgs>
  }

  export type $TriTrackHandoffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TriTrackHandoff"
    objects: {
      fromReceipt: Prisma.$BENReceiptPayload<ExtArgs>
      toReceipt: Prisma.$BENReceiptPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fromTrack: $Enums.TrackType
      toTrack: $Enums.TrackType
      status: $Enums.HandoffStatus
      fromReceiptId: number
      toReceiptId: number | null
      initiatedAt: Date
      completedAt: Date | null
      latencyMs: number | null
      exceededLimit: boolean
      payload: Prisma.JsonValue
      result: Prisma.JsonValue | null
      errorMessage: string | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["triTrackHandoff"]>
    composites: {}
  }

  type TriTrackHandoffGetPayload<S extends boolean | null | undefined | TriTrackHandoffDefaultArgs> = $Result.GetResult<Prisma.$TriTrackHandoffPayload, S>

  type TriTrackHandoffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TriTrackHandoffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TriTrackHandoffCountAggregateInputType | true
    }

  export interface TriTrackHandoffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TriTrackHandoff'], meta: { name: 'TriTrackHandoff' } }
    /**
     * Find zero or one TriTrackHandoff that matches the filter.
     * @param {TriTrackHandoffFindUniqueArgs} args - Arguments to find a TriTrackHandoff
     * @example
     * // Get one TriTrackHandoff
     * const triTrackHandoff = await prisma.triTrackHandoff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TriTrackHandoffFindUniqueArgs>(args: SelectSubset<T, TriTrackHandoffFindUniqueArgs<ExtArgs>>): Prisma__TriTrackHandoffClient<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TriTrackHandoff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TriTrackHandoffFindUniqueOrThrowArgs} args - Arguments to find a TriTrackHandoff
     * @example
     * // Get one TriTrackHandoff
     * const triTrackHandoff = await prisma.triTrackHandoff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TriTrackHandoffFindUniqueOrThrowArgs>(args: SelectSubset<T, TriTrackHandoffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TriTrackHandoffClient<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TriTrackHandoff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriTrackHandoffFindFirstArgs} args - Arguments to find a TriTrackHandoff
     * @example
     * // Get one TriTrackHandoff
     * const triTrackHandoff = await prisma.triTrackHandoff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TriTrackHandoffFindFirstArgs>(args?: SelectSubset<T, TriTrackHandoffFindFirstArgs<ExtArgs>>): Prisma__TriTrackHandoffClient<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TriTrackHandoff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriTrackHandoffFindFirstOrThrowArgs} args - Arguments to find a TriTrackHandoff
     * @example
     * // Get one TriTrackHandoff
     * const triTrackHandoff = await prisma.triTrackHandoff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TriTrackHandoffFindFirstOrThrowArgs>(args?: SelectSubset<T, TriTrackHandoffFindFirstOrThrowArgs<ExtArgs>>): Prisma__TriTrackHandoffClient<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TriTrackHandoffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriTrackHandoffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TriTrackHandoffs
     * const triTrackHandoffs = await prisma.triTrackHandoff.findMany()
     * 
     * // Get first 10 TriTrackHandoffs
     * const triTrackHandoffs = await prisma.triTrackHandoff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const triTrackHandoffWithIdOnly = await prisma.triTrackHandoff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TriTrackHandoffFindManyArgs>(args?: SelectSubset<T, TriTrackHandoffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TriTrackHandoff.
     * @param {TriTrackHandoffCreateArgs} args - Arguments to create a TriTrackHandoff.
     * @example
     * // Create one TriTrackHandoff
     * const TriTrackHandoff = await prisma.triTrackHandoff.create({
     *   data: {
     *     // ... data to create a TriTrackHandoff
     *   }
     * })
     * 
     */
    create<T extends TriTrackHandoffCreateArgs>(args: SelectSubset<T, TriTrackHandoffCreateArgs<ExtArgs>>): Prisma__TriTrackHandoffClient<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TriTrackHandoffs.
     * @param {TriTrackHandoffCreateManyArgs} args - Arguments to create many TriTrackHandoffs.
     * @example
     * // Create many TriTrackHandoffs
     * const triTrackHandoff = await prisma.triTrackHandoff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TriTrackHandoffCreateManyArgs>(args?: SelectSubset<T, TriTrackHandoffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TriTrackHandoffs and returns the data saved in the database.
     * @param {TriTrackHandoffCreateManyAndReturnArgs} args - Arguments to create many TriTrackHandoffs.
     * @example
     * // Create many TriTrackHandoffs
     * const triTrackHandoff = await prisma.triTrackHandoff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TriTrackHandoffs and only return the `id`
     * const triTrackHandoffWithIdOnly = await prisma.triTrackHandoff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TriTrackHandoffCreateManyAndReturnArgs>(args?: SelectSubset<T, TriTrackHandoffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TriTrackHandoff.
     * @param {TriTrackHandoffDeleteArgs} args - Arguments to delete one TriTrackHandoff.
     * @example
     * // Delete one TriTrackHandoff
     * const TriTrackHandoff = await prisma.triTrackHandoff.delete({
     *   where: {
     *     // ... filter to delete one TriTrackHandoff
     *   }
     * })
     * 
     */
    delete<T extends TriTrackHandoffDeleteArgs>(args: SelectSubset<T, TriTrackHandoffDeleteArgs<ExtArgs>>): Prisma__TriTrackHandoffClient<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TriTrackHandoff.
     * @param {TriTrackHandoffUpdateArgs} args - Arguments to update one TriTrackHandoff.
     * @example
     * // Update one TriTrackHandoff
     * const triTrackHandoff = await prisma.triTrackHandoff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TriTrackHandoffUpdateArgs>(args: SelectSubset<T, TriTrackHandoffUpdateArgs<ExtArgs>>): Prisma__TriTrackHandoffClient<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TriTrackHandoffs.
     * @param {TriTrackHandoffDeleteManyArgs} args - Arguments to filter TriTrackHandoffs to delete.
     * @example
     * // Delete a few TriTrackHandoffs
     * const { count } = await prisma.triTrackHandoff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TriTrackHandoffDeleteManyArgs>(args?: SelectSubset<T, TriTrackHandoffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TriTrackHandoffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriTrackHandoffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TriTrackHandoffs
     * const triTrackHandoff = await prisma.triTrackHandoff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TriTrackHandoffUpdateManyArgs>(args: SelectSubset<T, TriTrackHandoffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TriTrackHandoffs and returns the data updated in the database.
     * @param {TriTrackHandoffUpdateManyAndReturnArgs} args - Arguments to update many TriTrackHandoffs.
     * @example
     * // Update many TriTrackHandoffs
     * const triTrackHandoff = await prisma.triTrackHandoff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TriTrackHandoffs and only return the `id`
     * const triTrackHandoffWithIdOnly = await prisma.triTrackHandoff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TriTrackHandoffUpdateManyAndReturnArgs>(args: SelectSubset<T, TriTrackHandoffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TriTrackHandoff.
     * @param {TriTrackHandoffUpsertArgs} args - Arguments to update or create a TriTrackHandoff.
     * @example
     * // Update or create a TriTrackHandoff
     * const triTrackHandoff = await prisma.triTrackHandoff.upsert({
     *   create: {
     *     // ... data to create a TriTrackHandoff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TriTrackHandoff we want to update
     *   }
     * })
     */
    upsert<T extends TriTrackHandoffUpsertArgs>(args: SelectSubset<T, TriTrackHandoffUpsertArgs<ExtArgs>>): Prisma__TriTrackHandoffClient<$Result.GetResult<Prisma.$TriTrackHandoffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TriTrackHandoffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriTrackHandoffCountArgs} args - Arguments to filter TriTrackHandoffs to count.
     * @example
     * // Count the number of TriTrackHandoffs
     * const count = await prisma.triTrackHandoff.count({
     *   where: {
     *     // ... the filter for the TriTrackHandoffs we want to count
     *   }
     * })
    **/
    count<T extends TriTrackHandoffCountArgs>(
      args?: Subset<T, TriTrackHandoffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TriTrackHandoffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TriTrackHandoff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriTrackHandoffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TriTrackHandoffAggregateArgs>(args: Subset<T, TriTrackHandoffAggregateArgs>): Prisma.PrismaPromise<GetTriTrackHandoffAggregateType<T>>

    /**
     * Group by TriTrackHandoff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriTrackHandoffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TriTrackHandoffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TriTrackHandoffGroupByArgs['orderBy'] }
        : { orderBy?: TriTrackHandoffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TriTrackHandoffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTriTrackHandoffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TriTrackHandoff model
   */
  readonly fields: TriTrackHandoffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TriTrackHandoff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TriTrackHandoffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromReceipt<T extends BENReceiptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BENReceiptDefaultArgs<ExtArgs>>): Prisma__BENReceiptClient<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toReceipt<T extends TriTrackHandoff$toReceiptArgs<ExtArgs> = {}>(args?: Subset<T, TriTrackHandoff$toReceiptArgs<ExtArgs>>): Prisma__BENReceiptClient<$Result.GetResult<Prisma.$BENReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TriTrackHandoff model
   */
  interface TriTrackHandoffFieldRefs {
    readonly id: FieldRef<"TriTrackHandoff", 'Int'>
    readonly fromTrack: FieldRef<"TriTrackHandoff", 'TrackType'>
    readonly toTrack: FieldRef<"TriTrackHandoff", 'TrackType'>
    readonly status: FieldRef<"TriTrackHandoff", 'HandoffStatus'>
    readonly fromReceiptId: FieldRef<"TriTrackHandoff", 'Int'>
    readonly toReceiptId: FieldRef<"TriTrackHandoff", 'Int'>
    readonly initiatedAt: FieldRef<"TriTrackHandoff", 'DateTime'>
    readonly completedAt: FieldRef<"TriTrackHandoff", 'DateTime'>
    readonly latencyMs: FieldRef<"TriTrackHandoff", 'Int'>
    readonly exceededLimit: FieldRef<"TriTrackHandoff", 'Boolean'>
    readonly payload: FieldRef<"TriTrackHandoff", 'Json'>
    readonly result: FieldRef<"TriTrackHandoff", 'Json'>
    readonly errorMessage: FieldRef<"TriTrackHandoff", 'String'>
    readonly metadata: FieldRef<"TriTrackHandoff", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * TriTrackHandoff findUnique
   */
  export type TriTrackHandoffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    /**
     * Filter, which TriTrackHandoff to fetch.
     */
    where: TriTrackHandoffWhereUniqueInput
  }

  /**
   * TriTrackHandoff findUniqueOrThrow
   */
  export type TriTrackHandoffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    /**
     * Filter, which TriTrackHandoff to fetch.
     */
    where: TriTrackHandoffWhereUniqueInput
  }

  /**
   * TriTrackHandoff findFirst
   */
  export type TriTrackHandoffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    /**
     * Filter, which TriTrackHandoff to fetch.
     */
    where?: TriTrackHandoffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriTrackHandoffs to fetch.
     */
    orderBy?: TriTrackHandoffOrderByWithRelationInput | TriTrackHandoffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TriTrackHandoffs.
     */
    cursor?: TriTrackHandoffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriTrackHandoffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriTrackHandoffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TriTrackHandoffs.
     */
    distinct?: TriTrackHandoffScalarFieldEnum | TriTrackHandoffScalarFieldEnum[]
  }

  /**
   * TriTrackHandoff findFirstOrThrow
   */
  export type TriTrackHandoffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    /**
     * Filter, which TriTrackHandoff to fetch.
     */
    where?: TriTrackHandoffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriTrackHandoffs to fetch.
     */
    orderBy?: TriTrackHandoffOrderByWithRelationInput | TriTrackHandoffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TriTrackHandoffs.
     */
    cursor?: TriTrackHandoffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriTrackHandoffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriTrackHandoffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TriTrackHandoffs.
     */
    distinct?: TriTrackHandoffScalarFieldEnum | TriTrackHandoffScalarFieldEnum[]
  }

  /**
   * TriTrackHandoff findMany
   */
  export type TriTrackHandoffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    /**
     * Filter, which TriTrackHandoffs to fetch.
     */
    where?: TriTrackHandoffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriTrackHandoffs to fetch.
     */
    orderBy?: TriTrackHandoffOrderByWithRelationInput | TriTrackHandoffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TriTrackHandoffs.
     */
    cursor?: TriTrackHandoffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriTrackHandoffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriTrackHandoffs.
     */
    skip?: number
    distinct?: TriTrackHandoffScalarFieldEnum | TriTrackHandoffScalarFieldEnum[]
  }

  /**
   * TriTrackHandoff create
   */
  export type TriTrackHandoffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    /**
     * The data needed to create a TriTrackHandoff.
     */
    data: XOR<TriTrackHandoffCreateInput, TriTrackHandoffUncheckedCreateInput>
  }

  /**
   * TriTrackHandoff createMany
   */
  export type TriTrackHandoffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TriTrackHandoffs.
     */
    data: TriTrackHandoffCreateManyInput | TriTrackHandoffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TriTrackHandoff createManyAndReturn
   */
  export type TriTrackHandoffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * The data used to create many TriTrackHandoffs.
     */
    data: TriTrackHandoffCreateManyInput | TriTrackHandoffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TriTrackHandoff update
   */
  export type TriTrackHandoffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    /**
     * The data needed to update a TriTrackHandoff.
     */
    data: XOR<TriTrackHandoffUpdateInput, TriTrackHandoffUncheckedUpdateInput>
    /**
     * Choose, which TriTrackHandoff to update.
     */
    where: TriTrackHandoffWhereUniqueInput
  }

  /**
   * TriTrackHandoff updateMany
   */
  export type TriTrackHandoffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TriTrackHandoffs.
     */
    data: XOR<TriTrackHandoffUpdateManyMutationInput, TriTrackHandoffUncheckedUpdateManyInput>
    /**
     * Filter which TriTrackHandoffs to update
     */
    where?: TriTrackHandoffWhereInput
    /**
     * Limit how many TriTrackHandoffs to update.
     */
    limit?: number
  }

  /**
   * TriTrackHandoff updateManyAndReturn
   */
  export type TriTrackHandoffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * The data used to update TriTrackHandoffs.
     */
    data: XOR<TriTrackHandoffUpdateManyMutationInput, TriTrackHandoffUncheckedUpdateManyInput>
    /**
     * Filter which TriTrackHandoffs to update
     */
    where?: TriTrackHandoffWhereInput
    /**
     * Limit how many TriTrackHandoffs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TriTrackHandoff upsert
   */
  export type TriTrackHandoffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    /**
     * The filter to search for the TriTrackHandoff to update in case it exists.
     */
    where: TriTrackHandoffWhereUniqueInput
    /**
     * In case the TriTrackHandoff found by the `where` argument doesn't exist, create a new TriTrackHandoff with this data.
     */
    create: XOR<TriTrackHandoffCreateInput, TriTrackHandoffUncheckedCreateInput>
    /**
     * In case the TriTrackHandoff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TriTrackHandoffUpdateInput, TriTrackHandoffUncheckedUpdateInput>
  }

  /**
   * TriTrackHandoff delete
   */
  export type TriTrackHandoffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
    /**
     * Filter which TriTrackHandoff to delete.
     */
    where: TriTrackHandoffWhereUniqueInput
  }

  /**
   * TriTrackHandoff deleteMany
   */
  export type TriTrackHandoffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TriTrackHandoffs to delete
     */
    where?: TriTrackHandoffWhereInput
    /**
     * Limit how many TriTrackHandoffs to delete.
     */
    limit?: number
  }

  /**
   * TriTrackHandoff.toReceipt
   */
  export type TriTrackHandoff$toReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BENReceipt
     */
    select?: BENReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BENReceipt
     */
    omit?: BENReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BENReceiptInclude<ExtArgs> | null
    where?: BENReceiptWhereInput
  }

  /**
   * TriTrackHandoff without action
   */
  export type TriTrackHandoffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriTrackHandoff
     */
    select?: TriTrackHandoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TriTrackHandoff
     */
    omit?: TriTrackHandoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriTrackHandoffInclude<ExtArgs> | null
  }


  /**
   * Model ZScanVerification
   */

  export type AggregateZScanVerification = {
    _count: ZScanVerificationCountAggregateOutputType | null
    _avg: ZScanVerificationAvgAggregateOutputType | null
    _sum: ZScanVerificationSumAggregateOutputType | null
    _min: ZScanVerificationMinAggregateOutputType | null
    _max: ZScanVerificationMaxAggregateOutputType | null
  }

  export type ZScanVerificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    totalRules: number | null
    passed: number | null
    warnings: number | null
    critical: number | null
  }

  export type ZScanVerificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
    totalRules: number | null
    passed: number | null
    warnings: number | null
    critical: number | null
  }

  export type ZScanVerificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    totalRules: number | null
    passed: number | null
    warnings: number | null
    critical: number | null
    createdAt: Date | null
  }

  export type ZScanVerificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    totalRules: number | null
    passed: number | null
    warnings: number | null
    critical: number | null
    createdAt: Date | null
  }

  export type ZScanVerificationCountAggregateOutputType = {
    id: number
    userId: number
    totalRules: number
    passed: number
    warnings: number
    critical: number
    results: number
    config: number
    createdAt: number
    _all: number
  }


  export type ZScanVerificationAvgAggregateInputType = {
    id?: true
    userId?: true
    totalRules?: true
    passed?: true
    warnings?: true
    critical?: true
  }

  export type ZScanVerificationSumAggregateInputType = {
    id?: true
    userId?: true
    totalRules?: true
    passed?: true
    warnings?: true
    critical?: true
  }

  export type ZScanVerificationMinAggregateInputType = {
    id?: true
    userId?: true
    totalRules?: true
    passed?: true
    warnings?: true
    critical?: true
    createdAt?: true
  }

  export type ZScanVerificationMaxAggregateInputType = {
    id?: true
    userId?: true
    totalRules?: true
    passed?: true
    warnings?: true
    critical?: true
    createdAt?: true
  }

  export type ZScanVerificationCountAggregateInputType = {
    id?: true
    userId?: true
    totalRules?: true
    passed?: true
    warnings?: true
    critical?: true
    results?: true
    config?: true
    createdAt?: true
    _all?: true
  }

  export type ZScanVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZScanVerification to aggregate.
     */
    where?: ZScanVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZScanVerifications to fetch.
     */
    orderBy?: ZScanVerificationOrderByWithRelationInput | ZScanVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZScanVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZScanVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZScanVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ZScanVerifications
    **/
    _count?: true | ZScanVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZScanVerificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZScanVerificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZScanVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZScanVerificationMaxAggregateInputType
  }

  export type GetZScanVerificationAggregateType<T extends ZScanVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateZScanVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZScanVerification[P]>
      : GetScalarType<T[P], AggregateZScanVerification[P]>
  }




  export type ZScanVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZScanVerificationWhereInput
    orderBy?: ZScanVerificationOrderByWithAggregationInput | ZScanVerificationOrderByWithAggregationInput[]
    by: ZScanVerificationScalarFieldEnum[] | ZScanVerificationScalarFieldEnum
    having?: ZScanVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZScanVerificationCountAggregateInputType | true
    _avg?: ZScanVerificationAvgAggregateInputType
    _sum?: ZScanVerificationSumAggregateInputType
    _min?: ZScanVerificationMinAggregateInputType
    _max?: ZScanVerificationMaxAggregateInputType
  }

  export type ZScanVerificationGroupByOutputType = {
    id: number
    userId: number | null
    totalRules: number
    passed: number
    warnings: number
    critical: number
    results: JsonValue
    config: JsonValue
    createdAt: Date
    _count: ZScanVerificationCountAggregateOutputType | null
    _avg: ZScanVerificationAvgAggregateOutputType | null
    _sum: ZScanVerificationSumAggregateOutputType | null
    _min: ZScanVerificationMinAggregateOutputType | null
    _max: ZScanVerificationMaxAggregateOutputType | null
  }

  type GetZScanVerificationGroupByPayload<T extends ZScanVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZScanVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZScanVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZScanVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], ZScanVerificationGroupByOutputType[P]>
        }
      >
    >


  export type ZScanVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalRules?: boolean
    passed?: boolean
    warnings?: boolean
    critical?: boolean
    results?: boolean
    config?: boolean
    createdAt?: boolean
    user?: boolean | ZScanVerification$userArgs<ExtArgs>
  }, ExtArgs["result"]["zScanVerification"]>

  export type ZScanVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalRules?: boolean
    passed?: boolean
    warnings?: boolean
    critical?: boolean
    results?: boolean
    config?: boolean
    createdAt?: boolean
    user?: boolean | ZScanVerification$userArgs<ExtArgs>
  }, ExtArgs["result"]["zScanVerification"]>

  export type ZScanVerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalRules?: boolean
    passed?: boolean
    warnings?: boolean
    critical?: boolean
    results?: boolean
    config?: boolean
    createdAt?: boolean
    user?: boolean | ZScanVerification$userArgs<ExtArgs>
  }, ExtArgs["result"]["zScanVerification"]>

  export type ZScanVerificationSelectScalar = {
    id?: boolean
    userId?: boolean
    totalRules?: boolean
    passed?: boolean
    warnings?: boolean
    critical?: boolean
    results?: boolean
    config?: boolean
    createdAt?: boolean
  }

  export type ZScanVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "totalRules" | "passed" | "warnings" | "critical" | "results" | "config" | "createdAt", ExtArgs["result"]["zScanVerification"]>
  export type ZScanVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ZScanVerification$userArgs<ExtArgs>
  }
  export type ZScanVerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ZScanVerification$userArgs<ExtArgs>
  }
  export type ZScanVerificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ZScanVerification$userArgs<ExtArgs>
  }

  export type $ZScanVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ZScanVerification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      totalRules: number
      passed: number
      warnings: number
      critical: number
      results: Prisma.JsonValue
      config: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["zScanVerification"]>
    composites: {}
  }

  type ZScanVerificationGetPayload<S extends boolean | null | undefined | ZScanVerificationDefaultArgs> = $Result.GetResult<Prisma.$ZScanVerificationPayload, S>

  type ZScanVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ZScanVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZScanVerificationCountAggregateInputType | true
    }

  export interface ZScanVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ZScanVerification'], meta: { name: 'ZScanVerification' } }
    /**
     * Find zero or one ZScanVerification that matches the filter.
     * @param {ZScanVerificationFindUniqueArgs} args - Arguments to find a ZScanVerification
     * @example
     * // Get one ZScanVerification
     * const zScanVerification = await prisma.zScanVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZScanVerificationFindUniqueArgs>(args: SelectSubset<T, ZScanVerificationFindUniqueArgs<ExtArgs>>): Prisma__ZScanVerificationClient<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ZScanVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ZScanVerificationFindUniqueOrThrowArgs} args - Arguments to find a ZScanVerification
     * @example
     * // Get one ZScanVerification
     * const zScanVerification = await prisma.zScanVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZScanVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, ZScanVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZScanVerificationClient<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ZScanVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZScanVerificationFindFirstArgs} args - Arguments to find a ZScanVerification
     * @example
     * // Get one ZScanVerification
     * const zScanVerification = await prisma.zScanVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZScanVerificationFindFirstArgs>(args?: SelectSubset<T, ZScanVerificationFindFirstArgs<ExtArgs>>): Prisma__ZScanVerificationClient<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ZScanVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZScanVerificationFindFirstOrThrowArgs} args - Arguments to find a ZScanVerification
     * @example
     * // Get one ZScanVerification
     * const zScanVerification = await prisma.zScanVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZScanVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, ZScanVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZScanVerificationClient<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ZScanVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZScanVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ZScanVerifications
     * const zScanVerifications = await prisma.zScanVerification.findMany()
     * 
     * // Get first 10 ZScanVerifications
     * const zScanVerifications = await prisma.zScanVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zScanVerificationWithIdOnly = await prisma.zScanVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ZScanVerificationFindManyArgs>(args?: SelectSubset<T, ZScanVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ZScanVerification.
     * @param {ZScanVerificationCreateArgs} args - Arguments to create a ZScanVerification.
     * @example
     * // Create one ZScanVerification
     * const ZScanVerification = await prisma.zScanVerification.create({
     *   data: {
     *     // ... data to create a ZScanVerification
     *   }
     * })
     * 
     */
    create<T extends ZScanVerificationCreateArgs>(args: SelectSubset<T, ZScanVerificationCreateArgs<ExtArgs>>): Prisma__ZScanVerificationClient<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ZScanVerifications.
     * @param {ZScanVerificationCreateManyArgs} args - Arguments to create many ZScanVerifications.
     * @example
     * // Create many ZScanVerifications
     * const zScanVerification = await prisma.zScanVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZScanVerificationCreateManyArgs>(args?: SelectSubset<T, ZScanVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ZScanVerifications and returns the data saved in the database.
     * @param {ZScanVerificationCreateManyAndReturnArgs} args - Arguments to create many ZScanVerifications.
     * @example
     * // Create many ZScanVerifications
     * const zScanVerification = await prisma.zScanVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ZScanVerifications and only return the `id`
     * const zScanVerificationWithIdOnly = await prisma.zScanVerification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZScanVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, ZScanVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ZScanVerification.
     * @param {ZScanVerificationDeleteArgs} args - Arguments to delete one ZScanVerification.
     * @example
     * // Delete one ZScanVerification
     * const ZScanVerification = await prisma.zScanVerification.delete({
     *   where: {
     *     // ... filter to delete one ZScanVerification
     *   }
     * })
     * 
     */
    delete<T extends ZScanVerificationDeleteArgs>(args: SelectSubset<T, ZScanVerificationDeleteArgs<ExtArgs>>): Prisma__ZScanVerificationClient<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ZScanVerification.
     * @param {ZScanVerificationUpdateArgs} args - Arguments to update one ZScanVerification.
     * @example
     * // Update one ZScanVerification
     * const zScanVerification = await prisma.zScanVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZScanVerificationUpdateArgs>(args: SelectSubset<T, ZScanVerificationUpdateArgs<ExtArgs>>): Prisma__ZScanVerificationClient<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ZScanVerifications.
     * @param {ZScanVerificationDeleteManyArgs} args - Arguments to filter ZScanVerifications to delete.
     * @example
     * // Delete a few ZScanVerifications
     * const { count } = await prisma.zScanVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZScanVerificationDeleteManyArgs>(args?: SelectSubset<T, ZScanVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZScanVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZScanVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ZScanVerifications
     * const zScanVerification = await prisma.zScanVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZScanVerificationUpdateManyArgs>(args: SelectSubset<T, ZScanVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZScanVerifications and returns the data updated in the database.
     * @param {ZScanVerificationUpdateManyAndReturnArgs} args - Arguments to update many ZScanVerifications.
     * @example
     * // Update many ZScanVerifications
     * const zScanVerification = await prisma.zScanVerification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ZScanVerifications and only return the `id`
     * const zScanVerificationWithIdOnly = await prisma.zScanVerification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ZScanVerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, ZScanVerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ZScanVerification.
     * @param {ZScanVerificationUpsertArgs} args - Arguments to update or create a ZScanVerification.
     * @example
     * // Update or create a ZScanVerification
     * const zScanVerification = await prisma.zScanVerification.upsert({
     *   create: {
     *     // ... data to create a ZScanVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ZScanVerification we want to update
     *   }
     * })
     */
    upsert<T extends ZScanVerificationUpsertArgs>(args: SelectSubset<T, ZScanVerificationUpsertArgs<ExtArgs>>): Prisma__ZScanVerificationClient<$Result.GetResult<Prisma.$ZScanVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ZScanVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZScanVerificationCountArgs} args - Arguments to filter ZScanVerifications to count.
     * @example
     * // Count the number of ZScanVerifications
     * const count = await prisma.zScanVerification.count({
     *   where: {
     *     // ... the filter for the ZScanVerifications we want to count
     *   }
     * })
    **/
    count<T extends ZScanVerificationCountArgs>(
      args?: Subset<T, ZScanVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZScanVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ZScanVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZScanVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZScanVerificationAggregateArgs>(args: Subset<T, ZScanVerificationAggregateArgs>): Prisma.PrismaPromise<GetZScanVerificationAggregateType<T>>

    /**
     * Group by ZScanVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZScanVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZScanVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZScanVerificationGroupByArgs['orderBy'] }
        : { orderBy?: ZScanVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZScanVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZScanVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ZScanVerification model
   */
  readonly fields: ZScanVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ZScanVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZScanVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ZScanVerification$userArgs<ExtArgs> = {}>(args?: Subset<T, ZScanVerification$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ZScanVerification model
   */
  interface ZScanVerificationFieldRefs {
    readonly id: FieldRef<"ZScanVerification", 'Int'>
    readonly userId: FieldRef<"ZScanVerification", 'Int'>
    readonly totalRules: FieldRef<"ZScanVerification", 'Int'>
    readonly passed: FieldRef<"ZScanVerification", 'Int'>
    readonly warnings: FieldRef<"ZScanVerification", 'Int'>
    readonly critical: FieldRef<"ZScanVerification", 'Int'>
    readonly results: FieldRef<"ZScanVerification", 'Json'>
    readonly config: FieldRef<"ZScanVerification", 'Json'>
    readonly createdAt: FieldRef<"ZScanVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ZScanVerification findUnique
   */
  export type ZScanVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
    /**
     * Filter, which ZScanVerification to fetch.
     */
    where: ZScanVerificationWhereUniqueInput
  }

  /**
   * ZScanVerification findUniqueOrThrow
   */
  export type ZScanVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
    /**
     * Filter, which ZScanVerification to fetch.
     */
    where: ZScanVerificationWhereUniqueInput
  }

  /**
   * ZScanVerification findFirst
   */
  export type ZScanVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
    /**
     * Filter, which ZScanVerification to fetch.
     */
    where?: ZScanVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZScanVerifications to fetch.
     */
    orderBy?: ZScanVerificationOrderByWithRelationInput | ZScanVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZScanVerifications.
     */
    cursor?: ZScanVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZScanVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZScanVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZScanVerifications.
     */
    distinct?: ZScanVerificationScalarFieldEnum | ZScanVerificationScalarFieldEnum[]
  }

  /**
   * ZScanVerification findFirstOrThrow
   */
  export type ZScanVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
    /**
     * Filter, which ZScanVerification to fetch.
     */
    where?: ZScanVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZScanVerifications to fetch.
     */
    orderBy?: ZScanVerificationOrderByWithRelationInput | ZScanVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZScanVerifications.
     */
    cursor?: ZScanVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZScanVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZScanVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZScanVerifications.
     */
    distinct?: ZScanVerificationScalarFieldEnum | ZScanVerificationScalarFieldEnum[]
  }

  /**
   * ZScanVerification findMany
   */
  export type ZScanVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
    /**
     * Filter, which ZScanVerifications to fetch.
     */
    where?: ZScanVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZScanVerifications to fetch.
     */
    orderBy?: ZScanVerificationOrderByWithRelationInput | ZScanVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ZScanVerifications.
     */
    cursor?: ZScanVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZScanVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZScanVerifications.
     */
    skip?: number
    distinct?: ZScanVerificationScalarFieldEnum | ZScanVerificationScalarFieldEnum[]
  }

  /**
   * ZScanVerification create
   */
  export type ZScanVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a ZScanVerification.
     */
    data: XOR<ZScanVerificationCreateInput, ZScanVerificationUncheckedCreateInput>
  }

  /**
   * ZScanVerification createMany
   */
  export type ZScanVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ZScanVerifications.
     */
    data: ZScanVerificationCreateManyInput | ZScanVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ZScanVerification createManyAndReturn
   */
  export type ZScanVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * The data used to create many ZScanVerifications.
     */
    data: ZScanVerificationCreateManyInput | ZScanVerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ZScanVerification update
   */
  export type ZScanVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a ZScanVerification.
     */
    data: XOR<ZScanVerificationUpdateInput, ZScanVerificationUncheckedUpdateInput>
    /**
     * Choose, which ZScanVerification to update.
     */
    where: ZScanVerificationWhereUniqueInput
  }

  /**
   * ZScanVerification updateMany
   */
  export type ZScanVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ZScanVerifications.
     */
    data: XOR<ZScanVerificationUpdateManyMutationInput, ZScanVerificationUncheckedUpdateManyInput>
    /**
     * Filter which ZScanVerifications to update
     */
    where?: ZScanVerificationWhereInput
    /**
     * Limit how many ZScanVerifications to update.
     */
    limit?: number
  }

  /**
   * ZScanVerification updateManyAndReturn
   */
  export type ZScanVerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * The data used to update ZScanVerifications.
     */
    data: XOR<ZScanVerificationUpdateManyMutationInput, ZScanVerificationUncheckedUpdateManyInput>
    /**
     * Filter which ZScanVerifications to update
     */
    where?: ZScanVerificationWhereInput
    /**
     * Limit how many ZScanVerifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ZScanVerification upsert
   */
  export type ZScanVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the ZScanVerification to update in case it exists.
     */
    where: ZScanVerificationWhereUniqueInput
    /**
     * In case the ZScanVerification found by the `where` argument doesn't exist, create a new ZScanVerification with this data.
     */
    create: XOR<ZScanVerificationCreateInput, ZScanVerificationUncheckedCreateInput>
    /**
     * In case the ZScanVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZScanVerificationUpdateInput, ZScanVerificationUncheckedUpdateInput>
  }

  /**
   * ZScanVerification delete
   */
  export type ZScanVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
    /**
     * Filter which ZScanVerification to delete.
     */
    where: ZScanVerificationWhereUniqueInput
  }

  /**
   * ZScanVerification deleteMany
   */
  export type ZScanVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZScanVerifications to delete
     */
    where?: ZScanVerificationWhereInput
    /**
     * Limit how many ZScanVerifications to delete.
     */
    limit?: number
  }

  /**
   * ZScanVerification.user
   */
  export type ZScanVerification$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ZScanVerification without action
   */
  export type ZScanVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZScanVerification
     */
    select?: ZScanVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZScanVerification
     */
    omit?: ZScanVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZScanVerificationInclude<ExtArgs> | null
  }


  /**
   * Model SSOConfiguration
   */

  export type AggregateSSOConfiguration = {
    _count: SSOConfigurationCountAggregateOutputType | null
    _avg: SSOConfigurationAvgAggregateOutputType | null
    _sum: SSOConfigurationSumAggregateOutputType | null
    _min: SSOConfigurationMinAggregateOutputType | null
    _max: SSOConfigurationMaxAggregateOutputType | null
  }

  export type SSOConfigurationAvgAggregateOutputType = {
    id: number | null
    orgId: number | null
    createdBy: number | null
  }

  export type SSOConfigurationSumAggregateOutputType = {
    id: number | null
    orgId: number | null
    createdBy: number | null
  }

  export type SSOConfigurationMinAggregateOutputType = {
    id: number | null
    orgId: number | null
    provider: $Enums.SSOProvider | null
    enabled: boolean | null
    samlEntryPoint: string | null
    samlIssuer: string | null
    samlCert: string | null
    samlCallbackUrl: string | null
    samlLogoutUrl: string | null
    oauthClientId: string | null
    oauthClientSecret: string | null
    oauthAuthUrl: string | null
    oauthTokenUrl: string | null
    oauthUserInfoUrl: string | null
    jitProvisioning: boolean | null
    defaultRole: $Enums.Role | null
    defaultTier: $Enums.UserTier | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUsedAt: Date | null
  }

  export type SSOConfigurationMaxAggregateOutputType = {
    id: number | null
    orgId: number | null
    provider: $Enums.SSOProvider | null
    enabled: boolean | null
    samlEntryPoint: string | null
    samlIssuer: string | null
    samlCert: string | null
    samlCallbackUrl: string | null
    samlLogoutUrl: string | null
    oauthClientId: string | null
    oauthClientSecret: string | null
    oauthAuthUrl: string | null
    oauthTokenUrl: string | null
    oauthUserInfoUrl: string | null
    jitProvisioning: boolean | null
    defaultRole: $Enums.Role | null
    defaultTier: $Enums.UserTier | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUsedAt: Date | null
  }

  export type SSOConfigurationCountAggregateOutputType = {
    id: number
    orgId: number
    provider: number
    enabled: number
    samlEntryPoint: number
    samlIssuer: number
    samlCert: number
    samlCallbackUrl: number
    samlLogoutUrl: number
    oauthClientId: number
    oauthClientSecret: number
    oauthAuthUrl: number
    oauthTokenUrl: number
    oauthUserInfoUrl: number
    oauthScopes: number
    domainRestriction: number
    jitProvisioning: number
    defaultRole: number
    defaultTier: number
    metadata: number
    createdBy: number
    createdAt: number
    updatedAt: number
    lastUsedAt: number
    _all: number
  }


  export type SSOConfigurationAvgAggregateInputType = {
    id?: true
    orgId?: true
    createdBy?: true
  }

  export type SSOConfigurationSumAggregateInputType = {
    id?: true
    orgId?: true
    createdBy?: true
  }

  export type SSOConfigurationMinAggregateInputType = {
    id?: true
    orgId?: true
    provider?: true
    enabled?: true
    samlEntryPoint?: true
    samlIssuer?: true
    samlCert?: true
    samlCallbackUrl?: true
    samlLogoutUrl?: true
    oauthClientId?: true
    oauthClientSecret?: true
    oauthAuthUrl?: true
    oauthTokenUrl?: true
    oauthUserInfoUrl?: true
    jitProvisioning?: true
    defaultRole?: true
    defaultTier?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    lastUsedAt?: true
  }

  export type SSOConfigurationMaxAggregateInputType = {
    id?: true
    orgId?: true
    provider?: true
    enabled?: true
    samlEntryPoint?: true
    samlIssuer?: true
    samlCert?: true
    samlCallbackUrl?: true
    samlLogoutUrl?: true
    oauthClientId?: true
    oauthClientSecret?: true
    oauthAuthUrl?: true
    oauthTokenUrl?: true
    oauthUserInfoUrl?: true
    jitProvisioning?: true
    defaultRole?: true
    defaultTier?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    lastUsedAt?: true
  }

  export type SSOConfigurationCountAggregateInputType = {
    id?: true
    orgId?: true
    provider?: true
    enabled?: true
    samlEntryPoint?: true
    samlIssuer?: true
    samlCert?: true
    samlCallbackUrl?: true
    samlLogoutUrl?: true
    oauthClientId?: true
    oauthClientSecret?: true
    oauthAuthUrl?: true
    oauthTokenUrl?: true
    oauthUserInfoUrl?: true
    oauthScopes?: true
    domainRestriction?: true
    jitProvisioning?: true
    defaultRole?: true
    defaultTier?: true
    metadata?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    lastUsedAt?: true
    _all?: true
  }

  export type SSOConfigurationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SSOConfiguration to aggregate.
     */
    where?: SSOConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SSOConfigurations to fetch.
     */
    orderBy?: SSOConfigurationOrderByWithRelationInput | SSOConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SSOConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SSOConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SSOConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SSOConfigurations
    **/
    _count?: true | SSOConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SSOConfigurationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SSOConfigurationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SSOConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SSOConfigurationMaxAggregateInputType
  }

  export type GetSSOConfigurationAggregateType<T extends SSOConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateSSOConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSSOConfiguration[P]>
      : GetScalarType<T[P], AggregateSSOConfiguration[P]>
  }




  export type SSOConfigurationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SSOConfigurationWhereInput
    orderBy?: SSOConfigurationOrderByWithAggregationInput | SSOConfigurationOrderByWithAggregationInput[]
    by: SSOConfigurationScalarFieldEnum[] | SSOConfigurationScalarFieldEnum
    having?: SSOConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SSOConfigurationCountAggregateInputType | true
    _avg?: SSOConfigurationAvgAggregateInputType
    _sum?: SSOConfigurationSumAggregateInputType
    _min?: SSOConfigurationMinAggregateInputType
    _max?: SSOConfigurationMaxAggregateInputType
  }

  export type SSOConfigurationGroupByOutputType = {
    id: number
    orgId: number
    provider: $Enums.SSOProvider
    enabled: boolean
    samlEntryPoint: string | null
    samlIssuer: string | null
    samlCert: string | null
    samlCallbackUrl: string | null
    samlLogoutUrl: string | null
    oauthClientId: string | null
    oauthClientSecret: string | null
    oauthAuthUrl: string | null
    oauthTokenUrl: string | null
    oauthUserInfoUrl: string | null
    oauthScopes: string[]
    domainRestriction: string[]
    jitProvisioning: boolean
    defaultRole: $Enums.Role
    defaultTier: $Enums.UserTier
    metadata: JsonValue | null
    createdBy: number
    createdAt: Date
    updatedAt: Date
    lastUsedAt: Date | null
    _count: SSOConfigurationCountAggregateOutputType | null
    _avg: SSOConfigurationAvgAggregateOutputType | null
    _sum: SSOConfigurationSumAggregateOutputType | null
    _min: SSOConfigurationMinAggregateOutputType | null
    _max: SSOConfigurationMaxAggregateOutputType | null
  }

  type GetSSOConfigurationGroupByPayload<T extends SSOConfigurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SSOConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SSOConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SSOConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], SSOConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type SSOConfigurationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    provider?: boolean
    enabled?: boolean
    samlEntryPoint?: boolean
    samlIssuer?: boolean
    samlCert?: boolean
    samlCallbackUrl?: boolean
    samlLogoutUrl?: boolean
    oauthClientId?: boolean
    oauthClientSecret?: boolean
    oauthAuthUrl?: boolean
    oauthTokenUrl?: boolean
    oauthUserInfoUrl?: boolean
    oauthScopes?: boolean
    domainRestriction?: boolean
    jitProvisioning?: boolean
    defaultRole?: boolean
    defaultTier?: boolean
    metadata?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sSOConfiguration"]>

  export type SSOConfigurationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    provider?: boolean
    enabled?: boolean
    samlEntryPoint?: boolean
    samlIssuer?: boolean
    samlCert?: boolean
    samlCallbackUrl?: boolean
    samlLogoutUrl?: boolean
    oauthClientId?: boolean
    oauthClientSecret?: boolean
    oauthAuthUrl?: boolean
    oauthTokenUrl?: boolean
    oauthUserInfoUrl?: boolean
    oauthScopes?: boolean
    domainRestriction?: boolean
    jitProvisioning?: boolean
    defaultRole?: boolean
    defaultTier?: boolean
    metadata?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sSOConfiguration"]>

  export type SSOConfigurationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    provider?: boolean
    enabled?: boolean
    samlEntryPoint?: boolean
    samlIssuer?: boolean
    samlCert?: boolean
    samlCallbackUrl?: boolean
    samlLogoutUrl?: boolean
    oauthClientId?: boolean
    oauthClientSecret?: boolean
    oauthAuthUrl?: boolean
    oauthTokenUrl?: boolean
    oauthUserInfoUrl?: boolean
    oauthScopes?: boolean
    domainRestriction?: boolean
    jitProvisioning?: boolean
    defaultRole?: boolean
    defaultTier?: boolean
    metadata?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sSOConfiguration"]>

  export type SSOConfigurationSelectScalar = {
    id?: boolean
    orgId?: boolean
    provider?: boolean
    enabled?: boolean
    samlEntryPoint?: boolean
    samlIssuer?: boolean
    samlCert?: boolean
    samlCallbackUrl?: boolean
    samlLogoutUrl?: boolean
    oauthClientId?: boolean
    oauthClientSecret?: boolean
    oauthAuthUrl?: boolean
    oauthTokenUrl?: boolean
    oauthUserInfoUrl?: boolean
    oauthScopes?: boolean
    domainRestriction?: boolean
    jitProvisioning?: boolean
    defaultRole?: boolean
    defaultTier?: boolean
    metadata?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
  }

  export type SSOConfigurationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "provider" | "enabled" | "samlEntryPoint" | "samlIssuer" | "samlCert" | "samlCallbackUrl" | "samlLogoutUrl" | "oauthClientId" | "oauthClientSecret" | "oauthAuthUrl" | "oauthTokenUrl" | "oauthUserInfoUrl" | "oauthScopes" | "domainRestriction" | "jitProvisioning" | "defaultRole" | "defaultTier" | "metadata" | "createdBy" | "createdAt" | "updatedAt" | "lastUsedAt", ExtArgs["result"]["sSOConfiguration"]>
  export type SSOConfigurationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type SSOConfigurationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type SSOConfigurationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $SSOConfigurationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SSOConfiguration"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orgId: number
      provider: $Enums.SSOProvider
      enabled: boolean
      samlEntryPoint: string | null
      samlIssuer: string | null
      samlCert: string | null
      samlCallbackUrl: string | null
      samlLogoutUrl: string | null
      oauthClientId: string | null
      oauthClientSecret: string | null
      oauthAuthUrl: string | null
      oauthTokenUrl: string | null
      oauthUserInfoUrl: string | null
      oauthScopes: string[]
      domainRestriction: string[]
      jitProvisioning: boolean
      defaultRole: $Enums.Role
      defaultTier: $Enums.UserTier
      metadata: Prisma.JsonValue | null
      createdBy: number
      createdAt: Date
      updatedAt: Date
      lastUsedAt: Date | null
    }, ExtArgs["result"]["sSOConfiguration"]>
    composites: {}
  }

  type SSOConfigurationGetPayload<S extends boolean | null | undefined | SSOConfigurationDefaultArgs> = $Result.GetResult<Prisma.$SSOConfigurationPayload, S>

  type SSOConfigurationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SSOConfigurationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SSOConfigurationCountAggregateInputType | true
    }

  export interface SSOConfigurationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SSOConfiguration'], meta: { name: 'SSOConfiguration' } }
    /**
     * Find zero or one SSOConfiguration that matches the filter.
     * @param {SSOConfigurationFindUniqueArgs} args - Arguments to find a SSOConfiguration
     * @example
     * // Get one SSOConfiguration
     * const sSOConfiguration = await prisma.sSOConfiguration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SSOConfigurationFindUniqueArgs>(args: SelectSubset<T, SSOConfigurationFindUniqueArgs<ExtArgs>>): Prisma__SSOConfigurationClient<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SSOConfiguration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SSOConfigurationFindUniqueOrThrowArgs} args - Arguments to find a SSOConfiguration
     * @example
     * // Get one SSOConfiguration
     * const sSOConfiguration = await prisma.sSOConfiguration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SSOConfigurationFindUniqueOrThrowArgs>(args: SelectSubset<T, SSOConfigurationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SSOConfigurationClient<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SSOConfiguration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOConfigurationFindFirstArgs} args - Arguments to find a SSOConfiguration
     * @example
     * // Get one SSOConfiguration
     * const sSOConfiguration = await prisma.sSOConfiguration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SSOConfigurationFindFirstArgs>(args?: SelectSubset<T, SSOConfigurationFindFirstArgs<ExtArgs>>): Prisma__SSOConfigurationClient<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SSOConfiguration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOConfigurationFindFirstOrThrowArgs} args - Arguments to find a SSOConfiguration
     * @example
     * // Get one SSOConfiguration
     * const sSOConfiguration = await prisma.sSOConfiguration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SSOConfigurationFindFirstOrThrowArgs>(args?: SelectSubset<T, SSOConfigurationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SSOConfigurationClient<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SSOConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOConfigurationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SSOConfigurations
     * const sSOConfigurations = await prisma.sSOConfiguration.findMany()
     * 
     * // Get first 10 SSOConfigurations
     * const sSOConfigurations = await prisma.sSOConfiguration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sSOConfigurationWithIdOnly = await prisma.sSOConfiguration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SSOConfigurationFindManyArgs>(args?: SelectSubset<T, SSOConfigurationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SSOConfiguration.
     * @param {SSOConfigurationCreateArgs} args - Arguments to create a SSOConfiguration.
     * @example
     * // Create one SSOConfiguration
     * const SSOConfiguration = await prisma.sSOConfiguration.create({
     *   data: {
     *     // ... data to create a SSOConfiguration
     *   }
     * })
     * 
     */
    create<T extends SSOConfigurationCreateArgs>(args: SelectSubset<T, SSOConfigurationCreateArgs<ExtArgs>>): Prisma__SSOConfigurationClient<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SSOConfigurations.
     * @param {SSOConfigurationCreateManyArgs} args - Arguments to create many SSOConfigurations.
     * @example
     * // Create many SSOConfigurations
     * const sSOConfiguration = await prisma.sSOConfiguration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SSOConfigurationCreateManyArgs>(args?: SelectSubset<T, SSOConfigurationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SSOConfigurations and returns the data saved in the database.
     * @param {SSOConfigurationCreateManyAndReturnArgs} args - Arguments to create many SSOConfigurations.
     * @example
     * // Create many SSOConfigurations
     * const sSOConfiguration = await prisma.sSOConfiguration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SSOConfigurations and only return the `id`
     * const sSOConfigurationWithIdOnly = await prisma.sSOConfiguration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SSOConfigurationCreateManyAndReturnArgs>(args?: SelectSubset<T, SSOConfigurationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SSOConfiguration.
     * @param {SSOConfigurationDeleteArgs} args - Arguments to delete one SSOConfiguration.
     * @example
     * // Delete one SSOConfiguration
     * const SSOConfiguration = await prisma.sSOConfiguration.delete({
     *   where: {
     *     // ... filter to delete one SSOConfiguration
     *   }
     * })
     * 
     */
    delete<T extends SSOConfigurationDeleteArgs>(args: SelectSubset<T, SSOConfigurationDeleteArgs<ExtArgs>>): Prisma__SSOConfigurationClient<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SSOConfiguration.
     * @param {SSOConfigurationUpdateArgs} args - Arguments to update one SSOConfiguration.
     * @example
     * // Update one SSOConfiguration
     * const sSOConfiguration = await prisma.sSOConfiguration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SSOConfigurationUpdateArgs>(args: SelectSubset<T, SSOConfigurationUpdateArgs<ExtArgs>>): Prisma__SSOConfigurationClient<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SSOConfigurations.
     * @param {SSOConfigurationDeleteManyArgs} args - Arguments to filter SSOConfigurations to delete.
     * @example
     * // Delete a few SSOConfigurations
     * const { count } = await prisma.sSOConfiguration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SSOConfigurationDeleteManyArgs>(args?: SelectSubset<T, SSOConfigurationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SSOConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SSOConfigurations
     * const sSOConfiguration = await prisma.sSOConfiguration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SSOConfigurationUpdateManyArgs>(args: SelectSubset<T, SSOConfigurationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SSOConfigurations and returns the data updated in the database.
     * @param {SSOConfigurationUpdateManyAndReturnArgs} args - Arguments to update many SSOConfigurations.
     * @example
     * // Update many SSOConfigurations
     * const sSOConfiguration = await prisma.sSOConfiguration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SSOConfigurations and only return the `id`
     * const sSOConfigurationWithIdOnly = await prisma.sSOConfiguration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SSOConfigurationUpdateManyAndReturnArgs>(args: SelectSubset<T, SSOConfigurationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SSOConfiguration.
     * @param {SSOConfigurationUpsertArgs} args - Arguments to update or create a SSOConfiguration.
     * @example
     * // Update or create a SSOConfiguration
     * const sSOConfiguration = await prisma.sSOConfiguration.upsert({
     *   create: {
     *     // ... data to create a SSOConfiguration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SSOConfiguration we want to update
     *   }
     * })
     */
    upsert<T extends SSOConfigurationUpsertArgs>(args: SelectSubset<T, SSOConfigurationUpsertArgs<ExtArgs>>): Prisma__SSOConfigurationClient<$Result.GetResult<Prisma.$SSOConfigurationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SSOConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOConfigurationCountArgs} args - Arguments to filter SSOConfigurations to count.
     * @example
     * // Count the number of SSOConfigurations
     * const count = await prisma.sSOConfiguration.count({
     *   where: {
     *     // ... the filter for the SSOConfigurations we want to count
     *   }
     * })
    **/
    count<T extends SSOConfigurationCountArgs>(
      args?: Subset<T, SSOConfigurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SSOConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SSOConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SSOConfigurationAggregateArgs>(args: Subset<T, SSOConfigurationAggregateArgs>): Prisma.PrismaPromise<GetSSOConfigurationAggregateType<T>>

    /**
     * Group by SSOConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSOConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SSOConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SSOConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: SSOConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SSOConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSSOConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SSOConfiguration model
   */
  readonly fields: SSOConfigurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SSOConfiguration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SSOConfigurationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SSOConfiguration model
   */
  interface SSOConfigurationFieldRefs {
    readonly id: FieldRef<"SSOConfiguration", 'Int'>
    readonly orgId: FieldRef<"SSOConfiguration", 'Int'>
    readonly provider: FieldRef<"SSOConfiguration", 'SSOProvider'>
    readonly enabled: FieldRef<"SSOConfiguration", 'Boolean'>
    readonly samlEntryPoint: FieldRef<"SSOConfiguration", 'String'>
    readonly samlIssuer: FieldRef<"SSOConfiguration", 'String'>
    readonly samlCert: FieldRef<"SSOConfiguration", 'String'>
    readonly samlCallbackUrl: FieldRef<"SSOConfiguration", 'String'>
    readonly samlLogoutUrl: FieldRef<"SSOConfiguration", 'String'>
    readonly oauthClientId: FieldRef<"SSOConfiguration", 'String'>
    readonly oauthClientSecret: FieldRef<"SSOConfiguration", 'String'>
    readonly oauthAuthUrl: FieldRef<"SSOConfiguration", 'String'>
    readonly oauthTokenUrl: FieldRef<"SSOConfiguration", 'String'>
    readonly oauthUserInfoUrl: FieldRef<"SSOConfiguration", 'String'>
    readonly oauthScopes: FieldRef<"SSOConfiguration", 'String[]'>
    readonly domainRestriction: FieldRef<"SSOConfiguration", 'String[]'>
    readonly jitProvisioning: FieldRef<"SSOConfiguration", 'Boolean'>
    readonly defaultRole: FieldRef<"SSOConfiguration", 'Role'>
    readonly defaultTier: FieldRef<"SSOConfiguration", 'UserTier'>
    readonly metadata: FieldRef<"SSOConfiguration", 'Json'>
    readonly createdBy: FieldRef<"SSOConfiguration", 'Int'>
    readonly createdAt: FieldRef<"SSOConfiguration", 'DateTime'>
    readonly updatedAt: FieldRef<"SSOConfiguration", 'DateTime'>
    readonly lastUsedAt: FieldRef<"SSOConfiguration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SSOConfiguration findUnique
   */
  export type SSOConfigurationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which SSOConfiguration to fetch.
     */
    where: SSOConfigurationWhereUniqueInput
  }

  /**
   * SSOConfiguration findUniqueOrThrow
   */
  export type SSOConfigurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which SSOConfiguration to fetch.
     */
    where: SSOConfigurationWhereUniqueInput
  }

  /**
   * SSOConfiguration findFirst
   */
  export type SSOConfigurationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which SSOConfiguration to fetch.
     */
    where?: SSOConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SSOConfigurations to fetch.
     */
    orderBy?: SSOConfigurationOrderByWithRelationInput | SSOConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SSOConfigurations.
     */
    cursor?: SSOConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SSOConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SSOConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SSOConfigurations.
     */
    distinct?: SSOConfigurationScalarFieldEnum | SSOConfigurationScalarFieldEnum[]
  }

  /**
   * SSOConfiguration findFirstOrThrow
   */
  export type SSOConfigurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which SSOConfiguration to fetch.
     */
    where?: SSOConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SSOConfigurations to fetch.
     */
    orderBy?: SSOConfigurationOrderByWithRelationInput | SSOConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SSOConfigurations.
     */
    cursor?: SSOConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SSOConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SSOConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SSOConfigurations.
     */
    distinct?: SSOConfigurationScalarFieldEnum | SSOConfigurationScalarFieldEnum[]
  }

  /**
   * SSOConfiguration findMany
   */
  export type SSOConfigurationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which SSOConfigurations to fetch.
     */
    where?: SSOConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SSOConfigurations to fetch.
     */
    orderBy?: SSOConfigurationOrderByWithRelationInput | SSOConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SSOConfigurations.
     */
    cursor?: SSOConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SSOConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SSOConfigurations.
     */
    skip?: number
    distinct?: SSOConfigurationScalarFieldEnum | SSOConfigurationScalarFieldEnum[]
  }

  /**
   * SSOConfiguration create
   */
  export type SSOConfigurationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
    /**
     * The data needed to create a SSOConfiguration.
     */
    data: XOR<SSOConfigurationCreateInput, SSOConfigurationUncheckedCreateInput>
  }

  /**
   * SSOConfiguration createMany
   */
  export type SSOConfigurationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SSOConfigurations.
     */
    data: SSOConfigurationCreateManyInput | SSOConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SSOConfiguration createManyAndReturn
   */
  export type SSOConfigurationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * The data used to create many SSOConfigurations.
     */
    data: SSOConfigurationCreateManyInput | SSOConfigurationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SSOConfiguration update
   */
  export type SSOConfigurationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
    /**
     * The data needed to update a SSOConfiguration.
     */
    data: XOR<SSOConfigurationUpdateInput, SSOConfigurationUncheckedUpdateInput>
    /**
     * Choose, which SSOConfiguration to update.
     */
    where: SSOConfigurationWhereUniqueInput
  }

  /**
   * SSOConfiguration updateMany
   */
  export type SSOConfigurationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SSOConfigurations.
     */
    data: XOR<SSOConfigurationUpdateManyMutationInput, SSOConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which SSOConfigurations to update
     */
    where?: SSOConfigurationWhereInput
    /**
     * Limit how many SSOConfigurations to update.
     */
    limit?: number
  }

  /**
   * SSOConfiguration updateManyAndReturn
   */
  export type SSOConfigurationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * The data used to update SSOConfigurations.
     */
    data: XOR<SSOConfigurationUpdateManyMutationInput, SSOConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which SSOConfigurations to update
     */
    where?: SSOConfigurationWhereInput
    /**
     * Limit how many SSOConfigurations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SSOConfiguration upsert
   */
  export type SSOConfigurationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
    /**
     * The filter to search for the SSOConfiguration to update in case it exists.
     */
    where: SSOConfigurationWhereUniqueInput
    /**
     * In case the SSOConfiguration found by the `where` argument doesn't exist, create a new SSOConfiguration with this data.
     */
    create: XOR<SSOConfigurationCreateInput, SSOConfigurationUncheckedCreateInput>
    /**
     * In case the SSOConfiguration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SSOConfigurationUpdateInput, SSOConfigurationUncheckedUpdateInput>
  }

  /**
   * SSOConfiguration delete
   */
  export type SSOConfigurationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
    /**
     * Filter which SSOConfiguration to delete.
     */
    where: SSOConfigurationWhereUniqueInput
  }

  /**
   * SSOConfiguration deleteMany
   */
  export type SSOConfigurationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SSOConfigurations to delete
     */
    where?: SSOConfigurationWhereInput
    /**
     * Limit how many SSOConfigurations to delete.
     */
    limit?: number
  }

  /**
   * SSOConfiguration without action
   */
  export type SSOConfigurationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SSOConfiguration
     */
    select?: SSOConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SSOConfiguration
     */
    omit?: SSOConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SSOConfigurationInclude<ExtArgs> | null
  }


  /**
   * Model NotificationPreference
   */

  export type AggregateNotificationPreference = {
    _count: NotificationPreferenceCountAggregateOutputType | null
    _avg: NotificationPreferenceAvgAggregateOutputType | null
    _sum: NotificationPreferenceSumAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  export type NotificationPreferenceAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    lowScoreThreshold: number | null
    highScoreThreshold: number | null
  }

  export type NotificationPreferenceSumAggregateOutputType = {
    id: number | null
    userId: number | null
    lowScoreThreshold: number | null
    highScoreThreshold: number | null
  }

  export type NotificationPreferenceMinAggregateOutputType = {
    id: number | null
    userId: number | null
    emailEnabled: boolean | null
    testComplete: boolean | null
    batchComplete: boolean | null
    scheduledTestComplete: boolean | null
    alertsEnabled: boolean | null
    lowScoreThreshold: number | null
    highScoreThreshold: number | null
    scoreDropAlert: boolean | null
    witnessFailureAlert: boolean | null
    dailyReport: boolean | null
    weeklyReport: boolean | null
    monthlyReport: boolean | null
    reportTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    emailEnabled: boolean | null
    testComplete: boolean | null
    batchComplete: boolean | null
    scheduledTestComplete: boolean | null
    alertsEnabled: boolean | null
    lowScoreThreshold: number | null
    highScoreThreshold: number | null
    scoreDropAlert: boolean | null
    witnessFailureAlert: boolean | null
    dailyReport: boolean | null
    weeklyReport: boolean | null
    monthlyReport: boolean | null
    reportTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceCountAggregateOutputType = {
    id: number
    userId: number
    emailEnabled: number
    testComplete: number
    batchComplete: number
    scheduledTestComplete: number
    alertsEnabled: number
    lowScoreThreshold: number
    highScoreThreshold: number
    scoreDropAlert: number
    witnessFailureAlert: number
    dailyReport: number
    weeklyReport: number
    monthlyReport: number
    reportTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationPreferenceAvgAggregateInputType = {
    id?: true
    userId?: true
    lowScoreThreshold?: true
    highScoreThreshold?: true
  }

  export type NotificationPreferenceSumAggregateInputType = {
    id?: true
    userId?: true
    lowScoreThreshold?: true
    highScoreThreshold?: true
  }

  export type NotificationPreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    emailEnabled?: true
    testComplete?: true
    batchComplete?: true
    scheduledTestComplete?: true
    alertsEnabled?: true
    lowScoreThreshold?: true
    highScoreThreshold?: true
    scoreDropAlert?: true
    witnessFailureAlert?: true
    dailyReport?: true
    weeklyReport?: true
    monthlyReport?: true
    reportTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    emailEnabled?: true
    testComplete?: true
    batchComplete?: true
    scheduledTestComplete?: true
    alertsEnabled?: true
    lowScoreThreshold?: true
    highScoreThreshold?: true
    scoreDropAlert?: true
    witnessFailureAlert?: true
    dailyReport?: true
    weeklyReport?: true
    monthlyReport?: true
    reportTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    emailEnabled?: true
    testComplete?: true
    batchComplete?: true
    scheduledTestComplete?: true
    alertsEnabled?: true
    lowScoreThreshold?: true
    highScoreThreshold?: true
    scoreDropAlert?: true
    witnessFailureAlert?: true
    dailyReport?: true
    weeklyReport?: true
    monthlyReport?: true
    reportTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreference to aggregate.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPreferences
    **/
    _count?: true | NotificationPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationPreferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationPreferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type GetNotificationPreferenceAggregateType<T extends NotificationPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreference[P]>
      : GetScalarType<T[P], AggregateNotificationPreference[P]>
  }




  export type NotificationPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithAggregationInput | NotificationPreferenceOrderByWithAggregationInput[]
    by: NotificationPreferenceScalarFieldEnum[] | NotificationPreferenceScalarFieldEnum
    having?: NotificationPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPreferenceCountAggregateInputType | true
    _avg?: NotificationPreferenceAvgAggregateInputType
    _sum?: NotificationPreferenceSumAggregateInputType
    _min?: NotificationPreferenceMinAggregateInputType
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type NotificationPreferenceGroupByOutputType = {
    id: number
    userId: number
    emailEnabled: boolean
    testComplete: boolean
    batchComplete: boolean
    scheduledTestComplete: boolean
    alertsEnabled: boolean
    lowScoreThreshold: number
    highScoreThreshold: number
    scoreDropAlert: boolean
    witnessFailureAlert: boolean
    dailyReport: boolean
    weeklyReport: boolean
    monthlyReport: boolean
    reportTime: string
    createdAt: Date
    updatedAt: Date
    _count: NotificationPreferenceCountAggregateOutputType | null
    _avg: NotificationPreferenceAvgAggregateOutputType | null
    _sum: NotificationPreferenceSumAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  type GetNotificationPreferenceGroupByPayload<T extends NotificationPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    testComplete?: boolean
    batchComplete?: boolean
    scheduledTestComplete?: boolean
    alertsEnabled?: boolean
    lowScoreThreshold?: boolean
    highScoreThreshold?: boolean
    scoreDropAlert?: boolean
    witnessFailureAlert?: boolean
    dailyReport?: boolean
    weeklyReport?: boolean
    monthlyReport?: boolean
    reportTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    testComplete?: boolean
    batchComplete?: boolean
    scheduledTestComplete?: boolean
    alertsEnabled?: boolean
    lowScoreThreshold?: boolean
    highScoreThreshold?: boolean
    scoreDropAlert?: boolean
    witnessFailureAlert?: boolean
    dailyReport?: boolean
    weeklyReport?: boolean
    monthlyReport?: boolean
    reportTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    testComplete?: boolean
    batchComplete?: boolean
    scheduledTestComplete?: boolean
    alertsEnabled?: boolean
    lowScoreThreshold?: boolean
    highScoreThreshold?: boolean
    scoreDropAlert?: boolean
    witnessFailureAlert?: boolean
    dailyReport?: boolean
    weeklyReport?: boolean
    monthlyReport?: boolean
    reportTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    testComplete?: boolean
    batchComplete?: boolean
    scheduledTestComplete?: boolean
    alertsEnabled?: boolean
    lowScoreThreshold?: boolean
    highScoreThreshold?: boolean
    scoreDropAlert?: boolean
    witnessFailureAlert?: boolean
    dailyReport?: boolean
    weeklyReport?: boolean
    monthlyReport?: boolean
    reportTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationPreferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "emailEnabled" | "testComplete" | "batchComplete" | "scheduledTestComplete" | "alertsEnabled" | "lowScoreThreshold" | "highScoreThreshold" | "scoreDropAlert" | "witnessFailureAlert" | "dailyReport" | "weeklyReport" | "monthlyReport" | "reportTime" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationPreference"]>
  export type NotificationPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      emailEnabled: boolean
      testComplete: boolean
      batchComplete: boolean
      scheduledTestComplete: boolean
      alertsEnabled: boolean
      lowScoreThreshold: number
      highScoreThreshold: number
      scoreDropAlert: boolean
      witnessFailureAlert: boolean
      dailyReport: boolean
      weeklyReport: boolean
      monthlyReport: boolean
      reportTime: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationPreference"]>
    composites: {}
  }

  type NotificationPreferenceGetPayload<S extends boolean | null | undefined | NotificationPreferenceDefaultArgs> = $Result.GetResult<Prisma.$NotificationPreferencePayload, S>

  type NotificationPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationPreferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationPreferenceCountAggregateInputType | true
    }

  export interface NotificationPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPreference'], meta: { name: 'NotificationPreference' } }
    /**
     * Find zero or one NotificationPreference that matches the filter.
     * @param {NotificationPreferenceFindUniqueArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPreferenceFindUniqueArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPreferenceFindFirstArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany()
     * 
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationPreferenceFindManyArgs>(args?: SelectSubset<T, NotificationPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationPreference.
     * @param {NotificationPreferenceCreateArgs} args - Arguments to create a NotificationPreference.
     * @example
     * // Create one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.create({
     *   data: {
     *     // ... data to create a NotificationPreference
     *   }
     * })
     * 
     */
    create<T extends NotificationPreferenceCreateArgs>(args: SelectSubset<T, NotificationPreferenceCreateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationPreferences.
     * @param {NotificationPreferenceCreateManyArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPreferenceCreateManyArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPreferences and returns the data saved in the database.
     * @param {NotificationPreferenceCreateManyAndReturnArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationPreference.
     * @param {NotificationPreferenceDeleteArgs} args - Arguments to delete one NotificationPreference.
     * @example
     * // Delete one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreference
     *   }
     * })
     * 
     */
    delete<T extends NotificationPreferenceDeleteArgs>(args: SelectSubset<T, NotificationPreferenceDeleteArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationPreference.
     * @param {NotificationPreferenceUpdateArgs} args - Arguments to update one NotificationPreference.
     * @example
     * // Update one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPreferenceUpdateArgs>(args: SelectSubset<T, NotificationPreferenceUpdateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferenceDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPreferenceDeleteManyArgs>(args?: SelectSubset<T, NotificationPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPreferenceUpdateManyArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences and returns the data updated in the database.
     * @param {NotificationPreferenceUpdateManyAndReturnArgs} args - Arguments to update many NotificationPreferences.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationPreferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationPreference.
     * @param {NotificationPreferenceUpsertArgs} args - Arguments to update or create a NotificationPreference.
     * @example
     * // Update or create a NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.upsert({
     *   create: {
     *     // ... data to create a NotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreference we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPreferenceUpsertArgs>(args: SelectSubset<T, NotificationPreferenceUpsertArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreference.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends NotificationPreferenceCountArgs>(
      args?: Subset<T, NotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPreferenceAggregateArgs>(args: Subset<T, NotificationPreferenceAggregateArgs>): Prisma.PrismaPromise<GetNotificationPreferenceAggregateType<T>>

    /**
     * Group by NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPreference model
   */
  readonly fields: NotificationPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPreference model
   */
  interface NotificationPreferenceFieldRefs {
    readonly id: FieldRef<"NotificationPreference", 'Int'>
    readonly userId: FieldRef<"NotificationPreference", 'Int'>
    readonly emailEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly testComplete: FieldRef<"NotificationPreference", 'Boolean'>
    readonly batchComplete: FieldRef<"NotificationPreference", 'Boolean'>
    readonly scheduledTestComplete: FieldRef<"NotificationPreference", 'Boolean'>
    readonly alertsEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly lowScoreThreshold: FieldRef<"NotificationPreference", 'Float'>
    readonly highScoreThreshold: FieldRef<"NotificationPreference", 'Float'>
    readonly scoreDropAlert: FieldRef<"NotificationPreference", 'Boolean'>
    readonly witnessFailureAlert: FieldRef<"NotificationPreference", 'Boolean'>
    readonly dailyReport: FieldRef<"NotificationPreference", 'Boolean'>
    readonly weeklyReport: FieldRef<"NotificationPreference", 'Boolean'>
    readonly monthlyReport: FieldRef<"NotificationPreference", 'Boolean'>
    readonly reportTime: FieldRef<"NotificationPreference", 'String'>
    readonly createdAt: FieldRef<"NotificationPreference", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPreference findUnique
   */
  export type NotificationPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findUniqueOrThrow
   */
  export type NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findFirst
   */
  export type NotificationPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findFirstOrThrow
   */
  export type NotificationPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findMany
   */
  export type NotificationPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference create
   */
  export type NotificationPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPreference.
     */
    data: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
  }

  /**
   * NotificationPreference createMany
   */
  export type NotificationPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPreference createManyAndReturn
   */
  export type NotificationPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference update
   */
  export type NotificationPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPreference.
     */
    data: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
    /**
     * Choose, which NotificationPreference to update.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference updateMany
   */
  export type NotificationPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
  }

  /**
   * NotificationPreference updateManyAndReturn
   */
  export type NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference upsert
   */
  export type NotificationPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPreference to update in case it exists.
     */
    where: NotificationPreferenceWhereUniqueInput
    /**
     * In case the NotificationPreference found by the `where` argument doesn't exist, create a new NotificationPreference with this data.
     */
    create: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
    /**
     * In case the NotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
  }

  /**
   * NotificationPreference delete
   */
  export type NotificationPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter which NotificationPreference to delete.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference deleteMany
   */
  export type NotificationPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to delete.
     */
    limit?: number
  }

  /**
   * NotificationPreference without action
   */
  export type NotificationPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    tier: 'tier',
    permissions: 'permissions',
    orgId: 'orgId',
    status: 'status',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    twoFactorEnabled: 'twoFactorEnabled',
    twoFactorSecret: 'twoFactorSecret',
    backupCodes: 'backupCodes',
    failedLoginAttempts: 'failedLoginAttempts',
    lockedUntil: 'lockedUntil',
    passwordChangedAt: 'passwordChangedAt',
    ssoProvider: 'ssoProvider',
    ssoId: 'ssoId',
    ssoMetadata: 'ssoMetadata',
    currentPersona: 'currentPersona',
    personaLocked: 'personaLocked',
    lamportCounter: 'lamportCounter',
    lastReceiptId: 'lastReceiptId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    plan: 'plan',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    orgId: 'orgId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    userId: 'userId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const AuditRecordScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    category: 'category',
    details: 'details',
    metadata: 'metadata',
    status: 'status',
    lamport: 'lamport',
    hashPointer: 'hashPointer',
    organizationId: 'organizationId',
    blockHash: 'blockHash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuditRecordScalarFieldEnum = (typeof AuditRecordScalarFieldEnum)[keyof typeof AuditRecordScalarFieldEnum]


  export const BlockScalarFieldEnum: {
    id: 'id',
    hash: 'hash',
    previousHash: 'previousHash',
    organizationId: 'organizationId',
    lamportClock: 'lamportClock',
    metricsData: 'metricsData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlockScalarFieldEnum = (typeof BlockScalarFieldEnum)[keyof typeof BlockScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    expiresAt: 'expiresAt',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt',
    lastUsedAt: 'lastUsedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const BudgetScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    limit: 'limit',
    period: 'period',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BudgetScalarFieldEnum = (typeof BudgetScalarFieldEnum)[keyof typeof BudgetScalarFieldEnum]


  export const RegressionBaselineScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    modelName: 'modelName',
    modelVersion: 'modelVersion',
    testType: 'testType',
    avgResponseTime: 'avgResponseTime',
    avgCost: 'avgCost',
    avgQualityScore: 'avgQualityScore',
    avgAccuracy: 'avgAccuracy',
    successRate: 'successRate',
    alertThreshold: 'alertThreshold',
    sampleSize: 'sampleSize',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RegressionBaselineScalarFieldEnum = (typeof RegressionBaselineScalarFieldEnum)[keyof typeof RegressionBaselineScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    category: 'category',
    priority: 'priority',
    subject: 'subject',
    message: 'message',
    url: 'url',
    userAgent: 'userAgent',
    status: 'status',
    assignedTo: 'assignedTo',
    response: 'response',
    respondedAt: 'respondedAt',
    respondedBy: 'respondedBy',
    sentiment: 'sentiment',
    sentimentScore: 'sentimentScore',
    upvotes: 'upvotes',
    isPublic: 'isPublic',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    resolvedAt: 'resolvedAt'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const BENReceiptScalarFieldEnum: {
    id: 'id',
    receiptType: 'receiptType',
    lamportClock: 'lamportClock',
    realTimestamp: 'realTimestamp',
    userId: 'userId',
    persona: 'persona',
    track: 'track',
    payload: 'payload',
    digest: 'digest',
    previousDigest: 'previousDigest',
    baselineDigest: 'baselineDigest',
    witnessModel: 'witnessModel',
    witnessSignature: 'witnessSignature',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type BENReceiptScalarFieldEnum = (typeof BENReceiptScalarFieldEnum)[keyof typeof BENReceiptScalarFieldEnum]


  export const BENSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    persona: 'persona',
    priority: 'priority',
    locked: 'locked',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    duration: 'duration',
    startLamport: 'startLamport',
    endLamport: 'endLamport',
    switchReason: 'switchReason',
    metadata: 'metadata'
  };

  export type BENSessionScalarFieldEnum = (typeof BENSessionScalarFieldEnum)[keyof typeof BENSessionScalarFieldEnum]


  export const TriTrackHandoffScalarFieldEnum: {
    id: 'id',
    fromTrack: 'fromTrack',
    toTrack: 'toTrack',
    status: 'status',
    fromReceiptId: 'fromReceiptId',
    toReceiptId: 'toReceiptId',
    initiatedAt: 'initiatedAt',
    completedAt: 'completedAt',
    latencyMs: 'latencyMs',
    exceededLimit: 'exceededLimit',
    payload: 'payload',
    result: 'result',
    errorMessage: 'errorMessage',
    metadata: 'metadata'
  };

  export type TriTrackHandoffScalarFieldEnum = (typeof TriTrackHandoffScalarFieldEnum)[keyof typeof TriTrackHandoffScalarFieldEnum]


  export const ZScanVerificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    totalRules: 'totalRules',
    passed: 'passed',
    warnings: 'warnings',
    critical: 'critical',
    results: 'results',
    config: 'config',
    createdAt: 'createdAt'
  };

  export type ZScanVerificationScalarFieldEnum = (typeof ZScanVerificationScalarFieldEnum)[keyof typeof ZScanVerificationScalarFieldEnum]


  export const SSOConfigurationScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    provider: 'provider',
    enabled: 'enabled',
    samlEntryPoint: 'samlEntryPoint',
    samlIssuer: 'samlIssuer',
    samlCert: 'samlCert',
    samlCallbackUrl: 'samlCallbackUrl',
    samlLogoutUrl: 'samlLogoutUrl',
    oauthClientId: 'oauthClientId',
    oauthClientSecret: 'oauthClientSecret',
    oauthAuthUrl: 'oauthAuthUrl',
    oauthTokenUrl: 'oauthTokenUrl',
    oauthUserInfoUrl: 'oauthUserInfoUrl',
    oauthScopes: 'oauthScopes',
    domainRestriction: 'domainRestriction',
    jitProvisioning: 'jitProvisioning',
    defaultRole: 'defaultRole',
    defaultTier: 'defaultTier',
    metadata: 'metadata',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastUsedAt: 'lastUsedAt'
  };

  export type SSOConfigurationScalarFieldEnum = (typeof SSOConfigurationScalarFieldEnum)[keyof typeof SSOConfigurationScalarFieldEnum]


  export const NotificationPreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    emailEnabled: 'emailEnabled',
    testComplete: 'testComplete',
    batchComplete: 'batchComplete',
    scheduledTestComplete: 'scheduledTestComplete',
    alertsEnabled: 'alertsEnabled',
    lowScoreThreshold: 'lowScoreThreshold',
    highScoreThreshold: 'highScoreThreshold',
    scoreDropAlert: 'scoreDropAlert',
    witnessFailureAlert: 'witnessFailureAlert',
    dailyReport: 'dailyReport',
    weeklyReport: 'weeklyReport',
    monthlyReport: 'monthlyReport',
    reportTime: 'reportTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'UserTier'
   */
  export type EnumUserTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserTier'>
    


  /**
   * Reference to a field of type 'UserTier[]'
   */
  export type ListEnumUserTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserTier[]'>
    


  /**
   * Reference to a field of type 'Permission[]'
   */
  export type ListEnumPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Permission[]'>
    


  /**
   * Reference to a field of type 'Permission'
   */
  export type EnumPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Permission'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'BENPersona'
   */
  export type EnumBENPersonaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BENPersona'>
    


  /**
   * Reference to a field of type 'BENPersona[]'
   */
  export type ListEnumBENPersonaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BENPersona[]'>
    


  /**
   * Reference to a field of type 'PlanType'
   */
  export type EnumPlanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanType'>
    


  /**
   * Reference to a field of type 'PlanType[]'
   */
  export type ListEnumPlanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanType[]'>
    


  /**
   * Reference to a field of type 'OrgStatus'
   */
  export type EnumOrgStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrgStatus'>
    


  /**
   * Reference to a field of type 'OrgStatus[]'
   */
  export type ListEnumOrgStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrgStatus[]'>
    


  /**
   * Reference to a field of type 'TeamRole'
   */
  export type EnumTeamRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamRole'>
    


  /**
   * Reference to a field of type 'TeamRole[]'
   */
  export type ListEnumTeamRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamRole[]'>
    


  /**
   * Reference to a field of type 'AuditCategory'
   */
  export type EnumAuditCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditCategory'>
    


  /**
   * Reference to a field of type 'AuditCategory[]'
   */
  export type ListEnumAuditCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditCategory[]'>
    


  /**
   * Reference to a field of type 'AuditStatus'
   */
  export type EnumAuditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditStatus'>
    


  /**
   * Reference to a field of type 'AuditStatus[]'
   */
  export type ListEnumAuditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'FeedbackType'
   */
  export type EnumFeedbackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackType'>
    


  /**
   * Reference to a field of type 'FeedbackType[]'
   */
  export type ListEnumFeedbackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackType[]'>
    


  /**
   * Reference to a field of type 'FeedbackCategory'
   */
  export type EnumFeedbackCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackCategory'>
    


  /**
   * Reference to a field of type 'FeedbackCategory[]'
   */
  export type ListEnumFeedbackCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackCategory[]'>
    


  /**
   * Reference to a field of type 'FeedbackPriority'
   */
  export type EnumFeedbackPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackPriority'>
    


  /**
   * Reference to a field of type 'FeedbackPriority[]'
   */
  export type ListEnumFeedbackPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackPriority[]'>
    


  /**
   * Reference to a field of type 'FeedbackStatus'
   */
  export type EnumFeedbackStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackStatus'>
    


  /**
   * Reference to a field of type 'FeedbackStatus[]'
   */
  export type ListEnumFeedbackStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackStatus[]'>
    


  /**
   * Reference to a field of type 'ReceiptType'
   */
  export type EnumReceiptTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReceiptType'>
    


  /**
   * Reference to a field of type 'ReceiptType[]'
   */
  export type ListEnumReceiptTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReceiptType[]'>
    


  /**
   * Reference to a field of type 'TrackType'
   */
  export type EnumTrackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrackType'>
    


  /**
   * Reference to a field of type 'TrackType[]'
   */
  export type ListEnumTrackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrackType[]'>
    


  /**
   * Reference to a field of type 'HandoffStatus'
   */
  export type EnumHandoffStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HandoffStatus'>
    


  /**
   * Reference to a field of type 'HandoffStatus[]'
   */
  export type ListEnumHandoffStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HandoffStatus[]'>
    


  /**
   * Reference to a field of type 'SSOProvider'
   */
  export type EnumSSOProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SSOProvider'>
    


  /**
   * Reference to a field of type 'SSOProvider[]'
   */
  export type ListEnumSSOProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SSOProvider[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    tier?: EnumUserTierFilter<"User"> | $Enums.UserTier
    permissions?: EnumPermissionNullableListFilter<"User">
    orgId?: IntNullableFilter<"User"> | number | null
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    backupCodes?: StringNullableListFilter<"User">
    failedLoginAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordChangedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    ssoProvider?: StringNullableFilter<"User"> | string | null
    ssoId?: StringNullableFilter<"User"> | string | null
    ssoMetadata?: JsonNullableFilter<"User">
    currentPersona?: EnumBENPersonaFilter<"User"> | $Enums.BENPersona
    personaLocked?: BoolFilter<"User"> | boolean
    lamportCounter?: IntFilter<"User"> | number
    lastReceiptId?: IntNullableFilter<"User"> | number | null
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    sessions?: SessionListRelationFilter
    audits?: AuditRecordListRelationFilter
    teams?: TeamMemberListRelationFilter
    notifications?: XOR<NotificationPreferenceNullableScalarRelationFilter, NotificationPreferenceWhereInput> | null
    budgets?: BudgetListRelationFilter
    regressionBaselines?: RegressionBaselineListRelationFilter
    feedbacks?: FeedbackListRelationFilter
    benReceipts?: BENReceiptListRelationFilter
    benSessions?: BENSessionListRelationFilter
    zscans?: ZScanVerificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    tier?: SortOrder
    permissions?: SortOrder
    orgId?: SortOrderInput | SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    backupCodes?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    passwordChangedAt?: SortOrderInput | SortOrder
    ssoProvider?: SortOrderInput | SortOrder
    ssoId?: SortOrderInput | SortOrder
    ssoMetadata?: SortOrderInput | SortOrder
    currentPersona?: SortOrder
    personaLocked?: SortOrder
    lamportCounter?: SortOrder
    lastReceiptId?: SortOrderInput | SortOrder
    organization?: OrganizationOrderByWithRelationInput
    sessions?: SessionOrderByRelationAggregateInput
    audits?: AuditRecordOrderByRelationAggregateInput
    teams?: TeamMemberOrderByRelationAggregateInput
    notifications?: NotificationPreferenceOrderByWithRelationInput
    budgets?: BudgetOrderByRelationAggregateInput
    regressionBaselines?: RegressionBaselineOrderByRelationAggregateInput
    feedbacks?: FeedbackOrderByRelationAggregateInput
    benReceipts?: BENReceiptOrderByRelationAggregateInput
    benSessions?: BENSessionOrderByRelationAggregateInput
    zscans?: ZScanVerificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    ssoId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    tier?: EnumUserTierFilter<"User"> | $Enums.UserTier
    permissions?: EnumPermissionNullableListFilter<"User">
    orgId?: IntNullableFilter<"User"> | number | null
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    backupCodes?: StringNullableListFilter<"User">
    failedLoginAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordChangedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    ssoProvider?: StringNullableFilter<"User"> | string | null
    ssoMetadata?: JsonNullableFilter<"User">
    currentPersona?: EnumBENPersonaFilter<"User"> | $Enums.BENPersona
    personaLocked?: BoolFilter<"User"> | boolean
    lamportCounter?: IntFilter<"User"> | number
    lastReceiptId?: IntNullableFilter<"User"> | number | null
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    sessions?: SessionListRelationFilter
    audits?: AuditRecordListRelationFilter
    teams?: TeamMemberListRelationFilter
    notifications?: XOR<NotificationPreferenceNullableScalarRelationFilter, NotificationPreferenceWhereInput> | null
    budgets?: BudgetListRelationFilter
    regressionBaselines?: RegressionBaselineListRelationFilter
    feedbacks?: FeedbackListRelationFilter
    benReceipts?: BENReceiptListRelationFilter
    benSessions?: BENSessionListRelationFilter
    zscans?: ZScanVerificationListRelationFilter
  }, "id" | "email" | "ssoId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    tier?: SortOrder
    permissions?: SortOrder
    orgId?: SortOrderInput | SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    backupCodes?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    passwordChangedAt?: SortOrderInput | SortOrder
    ssoProvider?: SortOrderInput | SortOrder
    ssoId?: SortOrderInput | SortOrder
    ssoMetadata?: SortOrderInput | SortOrder
    currentPersona?: SortOrder
    personaLocked?: SortOrder
    lamportCounter?: SortOrder
    lastReceiptId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    tier?: EnumUserTierWithAggregatesFilter<"User"> | $Enums.UserTier
    permissions?: EnumPermissionNullableListFilter<"User">
    orgId?: IntNullableWithAggregatesFilter<"User"> | number | null
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    backupCodes?: StringNullableListFilter<"User">
    failedLoginAttempts?: IntWithAggregatesFilter<"User"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    passwordChangedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    ssoProvider?: StringNullableWithAggregatesFilter<"User"> | string | null
    ssoId?: StringNullableWithAggregatesFilter<"User"> | string | null
    ssoMetadata?: JsonNullableWithAggregatesFilter<"User">
    currentPersona?: EnumBENPersonaWithAggregatesFilter<"User"> | $Enums.BENPersona
    personaLocked?: BoolWithAggregatesFilter<"User"> | boolean
    lamportCounter?: IntWithAggregatesFilter<"User"> | number
    lastReceiptId?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: IntFilter<"Organization"> | number
    name?: StringFilter<"Organization"> | string
    plan?: EnumPlanTypeFilter<"Organization"> | $Enums.PlanType
    status?: EnumOrgStatusFilter<"Organization"> | $Enums.OrgStatus
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    users?: UserListRelationFilter
    teams?: TeamListRelationFilter
    ssoConfigs?: SSOConfigurationListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    teams?: TeamOrderByRelationAggregateInput
    ssoConfigs?: SSOConfigurationOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    plan?: EnumPlanTypeFilter<"Organization"> | $Enums.PlanType
    status?: EnumOrgStatusFilter<"Organization"> | $Enums.OrgStatus
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    users?: UserListRelationFilter
    teams?: TeamListRelationFilter
    ssoConfigs?: SSOConfigurationListRelationFilter
  }, "id">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _avg?: OrganizationAvgOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
    _sum?: OrganizationSumOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Organization"> | number
    name?: StringWithAggregatesFilter<"Organization"> | string
    plan?: EnumPlanTypeWithAggregatesFilter<"Organization"> | $Enums.PlanType
    status?: EnumOrgStatusWithAggregatesFilter<"Organization"> | $Enums.OrgStatus
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: IntFilter<"Team"> | number
    name?: StringFilter<"Team"> | string
    orgId?: IntFilter<"Team"> | number
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    members?: TeamMemberListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    members?: TeamMemberOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    orgId?: IntFilter<"Team"> | number
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    members?: TeamMemberListRelationFilter
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _avg?: TeamAvgOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
    _sum?: TeamSumOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Team"> | number
    name?: StringWithAggregatesFilter<"Team"> | string
    orgId?: IntWithAggregatesFilter<"Team"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    id?: IntFilter<"TeamMember"> | number
    teamId?: IntFilter<"TeamMember"> | number
    userId?: IntFilter<"TeamMember"> | number
    role?: EnumTeamRoleFilter<"TeamMember"> | $Enums.TeamRole
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"TeamMember"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    teamId_userId?: TeamMemberTeamIdUserIdCompoundUniqueInput
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    teamId?: IntFilter<"TeamMember"> | number
    userId?: IntFilter<"TeamMember"> | number
    role?: EnumTeamRoleFilter<"TeamMember"> | $Enums.TeamRole
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"TeamMember"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "teamId_userId">

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _avg?: TeamMemberAvgOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
    _sum?: TeamMemberSumOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    OR?: TeamMemberScalarWhereWithAggregatesInput[]
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TeamMember"> | number
    teamId?: IntWithAggregatesFilter<"TeamMember"> | number
    userId?: IntWithAggregatesFilter<"TeamMember"> | number
    role?: EnumTeamRoleWithAggregatesFilter<"TeamMember"> | $Enums.TeamRole
    createdAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
  }

  export type AuditRecordWhereInput = {
    AND?: AuditRecordWhereInput | AuditRecordWhereInput[]
    OR?: AuditRecordWhereInput[]
    NOT?: AuditRecordWhereInput | AuditRecordWhereInput[]
    id?: IntFilter<"AuditRecord"> | number
    userId?: IntFilter<"AuditRecord"> | number
    action?: StringFilter<"AuditRecord"> | string
    category?: EnumAuditCategoryFilter<"AuditRecord"> | $Enums.AuditCategory
    details?: JsonNullableFilter<"AuditRecord">
    metadata?: JsonNullableFilter<"AuditRecord">
    status?: EnumAuditStatusFilter<"AuditRecord"> | $Enums.AuditStatus
    lamport?: IntFilter<"AuditRecord"> | number
    hashPointer?: StringNullableFilter<"AuditRecord"> | string | null
    organizationId?: IntNullableFilter<"AuditRecord"> | number | null
    blockHash?: StringNullableFilter<"AuditRecord"> | string | null
    createdAt?: DateTimeFilter<"AuditRecord"> | Date | string
    updatedAt?: DateTimeFilter<"AuditRecord"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditRecordOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    category?: SortOrder
    details?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    status?: SortOrder
    lamport?: SortOrder
    hashPointer?: SortOrderInput | SortOrder
    organizationId?: SortOrderInput | SortOrder
    blockHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditRecordWhereInput | AuditRecordWhereInput[]
    OR?: AuditRecordWhereInput[]
    NOT?: AuditRecordWhereInput | AuditRecordWhereInput[]
    userId?: IntFilter<"AuditRecord"> | number
    action?: StringFilter<"AuditRecord"> | string
    category?: EnumAuditCategoryFilter<"AuditRecord"> | $Enums.AuditCategory
    details?: JsonNullableFilter<"AuditRecord">
    metadata?: JsonNullableFilter<"AuditRecord">
    status?: EnumAuditStatusFilter<"AuditRecord"> | $Enums.AuditStatus
    lamport?: IntFilter<"AuditRecord"> | number
    hashPointer?: StringNullableFilter<"AuditRecord"> | string | null
    organizationId?: IntNullableFilter<"AuditRecord"> | number | null
    blockHash?: StringNullableFilter<"AuditRecord"> | string | null
    createdAt?: DateTimeFilter<"AuditRecord"> | Date | string
    updatedAt?: DateTimeFilter<"AuditRecord"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditRecordOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    category?: SortOrder
    details?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    status?: SortOrder
    lamport?: SortOrder
    hashPointer?: SortOrderInput | SortOrder
    organizationId?: SortOrderInput | SortOrder
    blockHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuditRecordCountOrderByAggregateInput
    _avg?: AuditRecordAvgOrderByAggregateInput
    _max?: AuditRecordMaxOrderByAggregateInput
    _min?: AuditRecordMinOrderByAggregateInput
    _sum?: AuditRecordSumOrderByAggregateInput
  }

  export type AuditRecordScalarWhereWithAggregatesInput = {
    AND?: AuditRecordScalarWhereWithAggregatesInput | AuditRecordScalarWhereWithAggregatesInput[]
    OR?: AuditRecordScalarWhereWithAggregatesInput[]
    NOT?: AuditRecordScalarWhereWithAggregatesInput | AuditRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditRecord"> | number
    userId?: IntWithAggregatesFilter<"AuditRecord"> | number
    action?: StringWithAggregatesFilter<"AuditRecord"> | string
    category?: EnumAuditCategoryWithAggregatesFilter<"AuditRecord"> | $Enums.AuditCategory
    details?: JsonNullableWithAggregatesFilter<"AuditRecord">
    metadata?: JsonNullableWithAggregatesFilter<"AuditRecord">
    status?: EnumAuditStatusWithAggregatesFilter<"AuditRecord"> | $Enums.AuditStatus
    lamport?: IntWithAggregatesFilter<"AuditRecord"> | number
    hashPointer?: StringNullableWithAggregatesFilter<"AuditRecord"> | string | null
    organizationId?: IntNullableWithAggregatesFilter<"AuditRecord"> | number | null
    blockHash?: StringNullableWithAggregatesFilter<"AuditRecord"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuditRecord"> | Date | string
  }

  export type BlockWhereInput = {
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    id?: IntFilter<"Block"> | number
    hash?: StringFilter<"Block"> | string
    previousHash?: StringFilter<"Block"> | string
    organizationId?: IntNullableFilter<"Block"> | number | null
    lamportClock?: IntFilter<"Block"> | number
    metricsData?: JsonFilter<"Block">
    createdAt?: DateTimeFilter<"Block"> | Date | string
    updatedAt?: DateTimeFilter<"Block"> | Date | string
  }

  export type BlockOrderByWithRelationInput = {
    id?: SortOrder
    hash?: SortOrder
    previousHash?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    lamportClock?: SortOrder
    metricsData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    hash?: string
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    previousHash?: StringFilter<"Block"> | string
    organizationId?: IntNullableFilter<"Block"> | number | null
    lamportClock?: IntFilter<"Block"> | number
    metricsData?: JsonFilter<"Block">
    createdAt?: DateTimeFilter<"Block"> | Date | string
    updatedAt?: DateTimeFilter<"Block"> | Date | string
  }, "id" | "hash">

  export type BlockOrderByWithAggregationInput = {
    id?: SortOrder
    hash?: SortOrder
    previousHash?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    lamportClock?: SortOrder
    metricsData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlockCountOrderByAggregateInput
    _avg?: BlockAvgOrderByAggregateInput
    _max?: BlockMaxOrderByAggregateInput
    _min?: BlockMinOrderByAggregateInput
    _sum?: BlockSumOrderByAggregateInput
  }

  export type BlockScalarWhereWithAggregatesInput = {
    AND?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    OR?: BlockScalarWhereWithAggregatesInput[]
    NOT?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Block"> | number
    hash?: StringWithAggregatesFilter<"Block"> | string
    previousHash?: StringWithAggregatesFilter<"Block"> | string
    organizationId?: IntNullableWithAggregatesFilter<"Block"> | number | null
    lamportClock?: IntWithAggregatesFilter<"Block"> | number
    metricsData?: JsonWithAggregatesFilter<"Block">
    createdAt?: DateTimeWithAggregatesFilter<"Block"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Block"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: IntFilter<"Session"> | number
    userId?: IntFilter<"Session"> | number
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    userAgent?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    lastUsedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: IntFilter<"Session"> | number
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    userAgent?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    lastUsedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Session"> | number
    userId?: IntWithAggregatesFilter<"Session"> | number
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    lastUsedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type BudgetWhereInput = {
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    id?: IntFilter<"Budget"> | number
    userId?: IntFilter<"Budget"> | number
    limit?: FloatFilter<"Budget"> | number
    period?: StringFilter<"Budget"> | string
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BudgetOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    limit?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BudgetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    userId?: IntFilter<"Budget"> | number
    limit?: FloatFilter<"Budget"> | number
    period?: StringFilter<"Budget"> | string
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type BudgetOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    limit?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BudgetCountOrderByAggregateInput
    _avg?: BudgetAvgOrderByAggregateInput
    _max?: BudgetMaxOrderByAggregateInput
    _min?: BudgetMinOrderByAggregateInput
    _sum?: BudgetSumOrderByAggregateInput
  }

  export type BudgetScalarWhereWithAggregatesInput = {
    AND?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    OR?: BudgetScalarWhereWithAggregatesInput[]
    NOT?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Budget"> | number
    userId?: IntWithAggregatesFilter<"Budget"> | number
    limit?: FloatWithAggregatesFilter<"Budget"> | number
    period?: StringWithAggregatesFilter<"Budget"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
  }

  export type RegressionBaselineWhereInput = {
    AND?: RegressionBaselineWhereInput | RegressionBaselineWhereInput[]
    OR?: RegressionBaselineWhereInput[]
    NOT?: RegressionBaselineWhereInput | RegressionBaselineWhereInput[]
    id?: IntFilter<"RegressionBaseline"> | number
    userId?: IntFilter<"RegressionBaseline"> | number
    modelName?: StringFilter<"RegressionBaseline"> | string
    modelVersion?: StringNullableFilter<"RegressionBaseline"> | string | null
    testType?: StringFilter<"RegressionBaseline"> | string
    avgResponseTime?: FloatFilter<"RegressionBaseline"> | number
    avgCost?: FloatFilter<"RegressionBaseline"> | number
    avgQualityScore?: FloatFilter<"RegressionBaseline"> | number
    avgAccuracy?: FloatFilter<"RegressionBaseline"> | number
    successRate?: FloatFilter<"RegressionBaseline"> | number
    alertThreshold?: FloatFilter<"RegressionBaseline"> | number
    sampleSize?: IntFilter<"RegressionBaseline"> | number
    isActive?: BoolFilter<"RegressionBaseline"> | boolean
    createdAt?: DateTimeFilter<"RegressionBaseline"> | Date | string
    updatedAt?: DateTimeFilter<"RegressionBaseline"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RegressionBaselineOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrderInput | SortOrder
    testType?: SortOrder
    avgResponseTime?: SortOrder
    avgCost?: SortOrder
    avgQualityScore?: SortOrder
    avgAccuracy?: SortOrder
    successRate?: SortOrder
    alertThreshold?: SortOrder
    sampleSize?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RegressionBaselineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_modelName_modelVersion_testType?: RegressionBaselineUserIdModelNameModelVersionTestTypeCompoundUniqueInput
    AND?: RegressionBaselineWhereInput | RegressionBaselineWhereInput[]
    OR?: RegressionBaselineWhereInput[]
    NOT?: RegressionBaselineWhereInput | RegressionBaselineWhereInput[]
    userId?: IntFilter<"RegressionBaseline"> | number
    modelName?: StringFilter<"RegressionBaseline"> | string
    modelVersion?: StringNullableFilter<"RegressionBaseline"> | string | null
    testType?: StringFilter<"RegressionBaseline"> | string
    avgResponseTime?: FloatFilter<"RegressionBaseline"> | number
    avgCost?: FloatFilter<"RegressionBaseline"> | number
    avgQualityScore?: FloatFilter<"RegressionBaseline"> | number
    avgAccuracy?: FloatFilter<"RegressionBaseline"> | number
    successRate?: FloatFilter<"RegressionBaseline"> | number
    alertThreshold?: FloatFilter<"RegressionBaseline"> | number
    sampleSize?: IntFilter<"RegressionBaseline"> | number
    isActive?: BoolFilter<"RegressionBaseline"> | boolean
    createdAt?: DateTimeFilter<"RegressionBaseline"> | Date | string
    updatedAt?: DateTimeFilter<"RegressionBaseline"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_modelName_modelVersion_testType">

  export type RegressionBaselineOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrderInput | SortOrder
    testType?: SortOrder
    avgResponseTime?: SortOrder
    avgCost?: SortOrder
    avgQualityScore?: SortOrder
    avgAccuracy?: SortOrder
    successRate?: SortOrder
    alertThreshold?: SortOrder
    sampleSize?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RegressionBaselineCountOrderByAggregateInput
    _avg?: RegressionBaselineAvgOrderByAggregateInput
    _max?: RegressionBaselineMaxOrderByAggregateInput
    _min?: RegressionBaselineMinOrderByAggregateInput
    _sum?: RegressionBaselineSumOrderByAggregateInput
  }

  export type RegressionBaselineScalarWhereWithAggregatesInput = {
    AND?: RegressionBaselineScalarWhereWithAggregatesInput | RegressionBaselineScalarWhereWithAggregatesInput[]
    OR?: RegressionBaselineScalarWhereWithAggregatesInput[]
    NOT?: RegressionBaselineScalarWhereWithAggregatesInput | RegressionBaselineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RegressionBaseline"> | number
    userId?: IntWithAggregatesFilter<"RegressionBaseline"> | number
    modelName?: StringWithAggregatesFilter<"RegressionBaseline"> | string
    modelVersion?: StringNullableWithAggregatesFilter<"RegressionBaseline"> | string | null
    testType?: StringWithAggregatesFilter<"RegressionBaseline"> | string
    avgResponseTime?: FloatWithAggregatesFilter<"RegressionBaseline"> | number
    avgCost?: FloatWithAggregatesFilter<"RegressionBaseline"> | number
    avgQualityScore?: FloatWithAggregatesFilter<"RegressionBaseline"> | number
    avgAccuracy?: FloatWithAggregatesFilter<"RegressionBaseline"> | number
    successRate?: FloatWithAggregatesFilter<"RegressionBaseline"> | number
    alertThreshold?: FloatWithAggregatesFilter<"RegressionBaseline"> | number
    sampleSize?: IntWithAggregatesFilter<"RegressionBaseline"> | number
    isActive?: BoolWithAggregatesFilter<"RegressionBaseline"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RegressionBaseline"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RegressionBaseline"> | Date | string
  }

  export type FeedbackWhereInput = {
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    id?: IntFilter<"Feedback"> | number
    userId?: IntFilter<"Feedback"> | number
    type?: EnumFeedbackTypeFilter<"Feedback"> | $Enums.FeedbackType
    category?: EnumFeedbackCategoryFilter<"Feedback"> | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityFilter<"Feedback"> | $Enums.FeedbackPriority
    subject?: StringFilter<"Feedback"> | string
    message?: StringFilter<"Feedback"> | string
    url?: StringNullableFilter<"Feedback"> | string | null
    userAgent?: StringNullableFilter<"Feedback"> | string | null
    status?: EnumFeedbackStatusFilter<"Feedback"> | $Enums.FeedbackStatus
    assignedTo?: IntNullableFilter<"Feedback"> | number | null
    response?: StringNullableFilter<"Feedback"> | string | null
    respondedAt?: DateTimeNullableFilter<"Feedback"> | Date | string | null
    respondedBy?: IntNullableFilter<"Feedback"> | number | null
    sentiment?: StringNullableFilter<"Feedback"> | string | null
    sentimentScore?: FloatNullableFilter<"Feedback"> | number | null
    upvotes?: IntFilter<"Feedback"> | number
    isPublic?: BoolFilter<"Feedback"> | boolean
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeFilter<"Feedback"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Feedback"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FeedbackOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    url?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    status?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    respondedBy?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    sentimentScore?: SortOrderInput | SortOrder
    upvotes?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    userId?: IntFilter<"Feedback"> | number
    type?: EnumFeedbackTypeFilter<"Feedback"> | $Enums.FeedbackType
    category?: EnumFeedbackCategoryFilter<"Feedback"> | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityFilter<"Feedback"> | $Enums.FeedbackPriority
    subject?: StringFilter<"Feedback"> | string
    message?: StringFilter<"Feedback"> | string
    url?: StringNullableFilter<"Feedback"> | string | null
    userAgent?: StringNullableFilter<"Feedback"> | string | null
    status?: EnumFeedbackStatusFilter<"Feedback"> | $Enums.FeedbackStatus
    assignedTo?: IntNullableFilter<"Feedback"> | number | null
    response?: StringNullableFilter<"Feedback"> | string | null
    respondedAt?: DateTimeNullableFilter<"Feedback"> | Date | string | null
    respondedBy?: IntNullableFilter<"Feedback"> | number | null
    sentiment?: StringNullableFilter<"Feedback"> | string | null
    sentimentScore?: FloatNullableFilter<"Feedback"> | number | null
    upvotes?: IntFilter<"Feedback"> | number
    isPublic?: BoolFilter<"Feedback"> | boolean
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeFilter<"Feedback"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Feedback"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    url?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    status?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    respondedBy?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    sentimentScore?: SortOrderInput | SortOrder
    upvotes?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    _count?: FeedbackCountOrderByAggregateInput
    _avg?: FeedbackAvgOrderByAggregateInput
    _max?: FeedbackMaxOrderByAggregateInput
    _min?: FeedbackMinOrderByAggregateInput
    _sum?: FeedbackSumOrderByAggregateInput
  }

  export type FeedbackScalarWhereWithAggregatesInput = {
    AND?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    OR?: FeedbackScalarWhereWithAggregatesInput[]
    NOT?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Feedback"> | number
    userId?: IntWithAggregatesFilter<"Feedback"> | number
    type?: EnumFeedbackTypeWithAggregatesFilter<"Feedback"> | $Enums.FeedbackType
    category?: EnumFeedbackCategoryWithAggregatesFilter<"Feedback"> | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityWithAggregatesFilter<"Feedback"> | $Enums.FeedbackPriority
    subject?: StringWithAggregatesFilter<"Feedback"> | string
    message?: StringWithAggregatesFilter<"Feedback"> | string
    url?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    status?: EnumFeedbackStatusWithAggregatesFilter<"Feedback"> | $Enums.FeedbackStatus
    assignedTo?: IntNullableWithAggregatesFilter<"Feedback"> | number | null
    response?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    respondedAt?: DateTimeNullableWithAggregatesFilter<"Feedback"> | Date | string | null
    respondedBy?: IntNullableWithAggregatesFilter<"Feedback"> | number | null
    sentiment?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    sentimentScore?: FloatNullableWithAggregatesFilter<"Feedback"> | number | null
    upvotes?: IntWithAggregatesFilter<"Feedback"> | number
    isPublic?: BoolWithAggregatesFilter<"Feedback"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Feedback"> | Date | string | null
  }

  export type BENReceiptWhereInput = {
    AND?: BENReceiptWhereInput | BENReceiptWhereInput[]
    OR?: BENReceiptWhereInput[]
    NOT?: BENReceiptWhereInput | BENReceiptWhereInput[]
    id?: IntFilter<"BENReceipt"> | number
    receiptType?: EnumReceiptTypeFilter<"BENReceipt"> | $Enums.ReceiptType
    lamportClock?: IntFilter<"BENReceipt"> | number
    realTimestamp?: DateTimeFilter<"BENReceipt"> | Date | string
    userId?: IntNullableFilter<"BENReceipt"> | number | null
    persona?: EnumBENPersonaFilter<"BENReceipt"> | $Enums.BENPersona
    track?: EnumTrackTypeNullableFilter<"BENReceipt"> | $Enums.TrackType | null
    payload?: JsonFilter<"BENReceipt">
    digest?: StringFilter<"BENReceipt"> | string
    previousDigest?: StringNullableFilter<"BENReceipt"> | string | null
    baselineDigest?: StringNullableFilter<"BENReceipt"> | string | null
    witnessModel?: StringNullableFilter<"BENReceipt"> | string | null
    witnessSignature?: StringNullableFilter<"BENReceipt"> | string | null
    metadata?: JsonNullableFilter<"BENReceipt">
    createdAt?: DateTimeFilter<"BENReceipt"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    handoffsFrom?: TriTrackHandoffListRelationFilter
    handoffsTo?: TriTrackHandoffListRelationFilter
  }

  export type BENReceiptOrderByWithRelationInput = {
    id?: SortOrder
    receiptType?: SortOrder
    lamportClock?: SortOrder
    realTimestamp?: SortOrder
    userId?: SortOrderInput | SortOrder
    persona?: SortOrder
    track?: SortOrderInput | SortOrder
    payload?: SortOrder
    digest?: SortOrder
    previousDigest?: SortOrderInput | SortOrder
    baselineDigest?: SortOrderInput | SortOrder
    witnessModel?: SortOrderInput | SortOrder
    witnessSignature?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    handoffsFrom?: TriTrackHandoffOrderByRelationAggregateInput
    handoffsTo?: TriTrackHandoffOrderByRelationAggregateInput
  }

  export type BENReceiptWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BENReceiptWhereInput | BENReceiptWhereInput[]
    OR?: BENReceiptWhereInput[]
    NOT?: BENReceiptWhereInput | BENReceiptWhereInput[]
    receiptType?: EnumReceiptTypeFilter<"BENReceipt"> | $Enums.ReceiptType
    lamportClock?: IntFilter<"BENReceipt"> | number
    realTimestamp?: DateTimeFilter<"BENReceipt"> | Date | string
    userId?: IntNullableFilter<"BENReceipt"> | number | null
    persona?: EnumBENPersonaFilter<"BENReceipt"> | $Enums.BENPersona
    track?: EnumTrackTypeNullableFilter<"BENReceipt"> | $Enums.TrackType | null
    payload?: JsonFilter<"BENReceipt">
    digest?: StringFilter<"BENReceipt"> | string
    previousDigest?: StringNullableFilter<"BENReceipt"> | string | null
    baselineDigest?: StringNullableFilter<"BENReceipt"> | string | null
    witnessModel?: StringNullableFilter<"BENReceipt"> | string | null
    witnessSignature?: StringNullableFilter<"BENReceipt"> | string | null
    metadata?: JsonNullableFilter<"BENReceipt">
    createdAt?: DateTimeFilter<"BENReceipt"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    handoffsFrom?: TriTrackHandoffListRelationFilter
    handoffsTo?: TriTrackHandoffListRelationFilter
  }, "id">

  export type BENReceiptOrderByWithAggregationInput = {
    id?: SortOrder
    receiptType?: SortOrder
    lamportClock?: SortOrder
    realTimestamp?: SortOrder
    userId?: SortOrderInput | SortOrder
    persona?: SortOrder
    track?: SortOrderInput | SortOrder
    payload?: SortOrder
    digest?: SortOrder
    previousDigest?: SortOrderInput | SortOrder
    baselineDigest?: SortOrderInput | SortOrder
    witnessModel?: SortOrderInput | SortOrder
    witnessSignature?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BENReceiptCountOrderByAggregateInput
    _avg?: BENReceiptAvgOrderByAggregateInput
    _max?: BENReceiptMaxOrderByAggregateInput
    _min?: BENReceiptMinOrderByAggregateInput
    _sum?: BENReceiptSumOrderByAggregateInput
  }

  export type BENReceiptScalarWhereWithAggregatesInput = {
    AND?: BENReceiptScalarWhereWithAggregatesInput | BENReceiptScalarWhereWithAggregatesInput[]
    OR?: BENReceiptScalarWhereWithAggregatesInput[]
    NOT?: BENReceiptScalarWhereWithAggregatesInput | BENReceiptScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BENReceipt"> | number
    receiptType?: EnumReceiptTypeWithAggregatesFilter<"BENReceipt"> | $Enums.ReceiptType
    lamportClock?: IntWithAggregatesFilter<"BENReceipt"> | number
    realTimestamp?: DateTimeWithAggregatesFilter<"BENReceipt"> | Date | string
    userId?: IntNullableWithAggregatesFilter<"BENReceipt"> | number | null
    persona?: EnumBENPersonaWithAggregatesFilter<"BENReceipt"> | $Enums.BENPersona
    track?: EnumTrackTypeNullableWithAggregatesFilter<"BENReceipt"> | $Enums.TrackType | null
    payload?: JsonWithAggregatesFilter<"BENReceipt">
    digest?: StringWithAggregatesFilter<"BENReceipt"> | string
    previousDigest?: StringNullableWithAggregatesFilter<"BENReceipt"> | string | null
    baselineDigest?: StringNullableWithAggregatesFilter<"BENReceipt"> | string | null
    witnessModel?: StringNullableWithAggregatesFilter<"BENReceipt"> | string | null
    witnessSignature?: StringNullableWithAggregatesFilter<"BENReceipt"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"BENReceipt">
    createdAt?: DateTimeWithAggregatesFilter<"BENReceipt"> | Date | string
  }

  export type BENSessionWhereInput = {
    AND?: BENSessionWhereInput | BENSessionWhereInput[]
    OR?: BENSessionWhereInput[]
    NOT?: BENSessionWhereInput | BENSessionWhereInput[]
    id?: IntFilter<"BENSession"> | number
    userId?: IntFilter<"BENSession"> | number
    persona?: EnumBENPersonaFilter<"BENSession"> | $Enums.BENPersona
    priority?: IntFilter<"BENSession"> | number
    locked?: BoolFilter<"BENSession"> | boolean
    startedAt?: DateTimeFilter<"BENSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"BENSession"> | Date | string | null
    duration?: IntNullableFilter<"BENSession"> | number | null
    startLamport?: IntFilter<"BENSession"> | number
    endLamport?: IntNullableFilter<"BENSession"> | number | null
    switchReason?: StringNullableFilter<"BENSession"> | string | null
    metadata?: JsonNullableFilter<"BENSession">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BENSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    persona?: SortOrder
    priority?: SortOrder
    locked?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    startLamport?: SortOrder
    endLamport?: SortOrderInput | SortOrder
    switchReason?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BENSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BENSessionWhereInput | BENSessionWhereInput[]
    OR?: BENSessionWhereInput[]
    NOT?: BENSessionWhereInput | BENSessionWhereInput[]
    userId?: IntFilter<"BENSession"> | number
    persona?: EnumBENPersonaFilter<"BENSession"> | $Enums.BENPersona
    priority?: IntFilter<"BENSession"> | number
    locked?: BoolFilter<"BENSession"> | boolean
    startedAt?: DateTimeFilter<"BENSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"BENSession"> | Date | string | null
    duration?: IntNullableFilter<"BENSession"> | number | null
    startLamport?: IntFilter<"BENSession"> | number
    endLamport?: IntNullableFilter<"BENSession"> | number | null
    switchReason?: StringNullableFilter<"BENSession"> | string | null
    metadata?: JsonNullableFilter<"BENSession">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type BENSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    persona?: SortOrder
    priority?: SortOrder
    locked?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    startLamport?: SortOrder
    endLamport?: SortOrderInput | SortOrder
    switchReason?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: BENSessionCountOrderByAggregateInput
    _avg?: BENSessionAvgOrderByAggregateInput
    _max?: BENSessionMaxOrderByAggregateInput
    _min?: BENSessionMinOrderByAggregateInput
    _sum?: BENSessionSumOrderByAggregateInput
  }

  export type BENSessionScalarWhereWithAggregatesInput = {
    AND?: BENSessionScalarWhereWithAggregatesInput | BENSessionScalarWhereWithAggregatesInput[]
    OR?: BENSessionScalarWhereWithAggregatesInput[]
    NOT?: BENSessionScalarWhereWithAggregatesInput | BENSessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BENSession"> | number
    userId?: IntWithAggregatesFilter<"BENSession"> | number
    persona?: EnumBENPersonaWithAggregatesFilter<"BENSession"> | $Enums.BENPersona
    priority?: IntWithAggregatesFilter<"BENSession"> | number
    locked?: BoolWithAggregatesFilter<"BENSession"> | boolean
    startedAt?: DateTimeWithAggregatesFilter<"BENSession"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"BENSession"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"BENSession"> | number | null
    startLamport?: IntWithAggregatesFilter<"BENSession"> | number
    endLamport?: IntNullableWithAggregatesFilter<"BENSession"> | number | null
    switchReason?: StringNullableWithAggregatesFilter<"BENSession"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"BENSession">
  }

  export type TriTrackHandoffWhereInput = {
    AND?: TriTrackHandoffWhereInput | TriTrackHandoffWhereInput[]
    OR?: TriTrackHandoffWhereInput[]
    NOT?: TriTrackHandoffWhereInput | TriTrackHandoffWhereInput[]
    id?: IntFilter<"TriTrackHandoff"> | number
    fromTrack?: EnumTrackTypeFilter<"TriTrackHandoff"> | $Enums.TrackType
    toTrack?: EnumTrackTypeFilter<"TriTrackHandoff"> | $Enums.TrackType
    status?: EnumHandoffStatusFilter<"TriTrackHandoff"> | $Enums.HandoffStatus
    fromReceiptId?: IntFilter<"TriTrackHandoff"> | number
    toReceiptId?: IntNullableFilter<"TriTrackHandoff"> | number | null
    initiatedAt?: DateTimeFilter<"TriTrackHandoff"> | Date | string
    completedAt?: DateTimeNullableFilter<"TriTrackHandoff"> | Date | string | null
    latencyMs?: IntNullableFilter<"TriTrackHandoff"> | number | null
    exceededLimit?: BoolFilter<"TriTrackHandoff"> | boolean
    payload?: JsonFilter<"TriTrackHandoff">
    result?: JsonNullableFilter<"TriTrackHandoff">
    errorMessage?: StringNullableFilter<"TriTrackHandoff"> | string | null
    metadata?: JsonNullableFilter<"TriTrackHandoff">
    fromReceipt?: XOR<BENReceiptScalarRelationFilter, BENReceiptWhereInput>
    toReceipt?: XOR<BENReceiptNullableScalarRelationFilter, BENReceiptWhereInput> | null
  }

  export type TriTrackHandoffOrderByWithRelationInput = {
    id?: SortOrder
    fromTrack?: SortOrder
    toTrack?: SortOrder
    status?: SortOrder
    fromReceiptId?: SortOrder
    toReceiptId?: SortOrderInput | SortOrder
    initiatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    latencyMs?: SortOrderInput | SortOrder
    exceededLimit?: SortOrder
    payload?: SortOrder
    result?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    fromReceipt?: BENReceiptOrderByWithRelationInput
    toReceipt?: BENReceiptOrderByWithRelationInput
  }

  export type TriTrackHandoffWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TriTrackHandoffWhereInput | TriTrackHandoffWhereInput[]
    OR?: TriTrackHandoffWhereInput[]
    NOT?: TriTrackHandoffWhereInput | TriTrackHandoffWhereInput[]
    fromTrack?: EnumTrackTypeFilter<"TriTrackHandoff"> | $Enums.TrackType
    toTrack?: EnumTrackTypeFilter<"TriTrackHandoff"> | $Enums.TrackType
    status?: EnumHandoffStatusFilter<"TriTrackHandoff"> | $Enums.HandoffStatus
    fromReceiptId?: IntFilter<"TriTrackHandoff"> | number
    toReceiptId?: IntNullableFilter<"TriTrackHandoff"> | number | null
    initiatedAt?: DateTimeFilter<"TriTrackHandoff"> | Date | string
    completedAt?: DateTimeNullableFilter<"TriTrackHandoff"> | Date | string | null
    latencyMs?: IntNullableFilter<"TriTrackHandoff"> | number | null
    exceededLimit?: BoolFilter<"TriTrackHandoff"> | boolean
    payload?: JsonFilter<"TriTrackHandoff">
    result?: JsonNullableFilter<"TriTrackHandoff">
    errorMessage?: StringNullableFilter<"TriTrackHandoff"> | string | null
    metadata?: JsonNullableFilter<"TriTrackHandoff">
    fromReceipt?: XOR<BENReceiptScalarRelationFilter, BENReceiptWhereInput>
    toReceipt?: XOR<BENReceiptNullableScalarRelationFilter, BENReceiptWhereInput> | null
  }, "id">

  export type TriTrackHandoffOrderByWithAggregationInput = {
    id?: SortOrder
    fromTrack?: SortOrder
    toTrack?: SortOrder
    status?: SortOrder
    fromReceiptId?: SortOrder
    toReceiptId?: SortOrderInput | SortOrder
    initiatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    latencyMs?: SortOrderInput | SortOrder
    exceededLimit?: SortOrder
    payload?: SortOrder
    result?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: TriTrackHandoffCountOrderByAggregateInput
    _avg?: TriTrackHandoffAvgOrderByAggregateInput
    _max?: TriTrackHandoffMaxOrderByAggregateInput
    _min?: TriTrackHandoffMinOrderByAggregateInput
    _sum?: TriTrackHandoffSumOrderByAggregateInput
  }

  export type TriTrackHandoffScalarWhereWithAggregatesInput = {
    AND?: TriTrackHandoffScalarWhereWithAggregatesInput | TriTrackHandoffScalarWhereWithAggregatesInput[]
    OR?: TriTrackHandoffScalarWhereWithAggregatesInput[]
    NOT?: TriTrackHandoffScalarWhereWithAggregatesInput | TriTrackHandoffScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TriTrackHandoff"> | number
    fromTrack?: EnumTrackTypeWithAggregatesFilter<"TriTrackHandoff"> | $Enums.TrackType
    toTrack?: EnumTrackTypeWithAggregatesFilter<"TriTrackHandoff"> | $Enums.TrackType
    status?: EnumHandoffStatusWithAggregatesFilter<"TriTrackHandoff"> | $Enums.HandoffStatus
    fromReceiptId?: IntWithAggregatesFilter<"TriTrackHandoff"> | number
    toReceiptId?: IntNullableWithAggregatesFilter<"TriTrackHandoff"> | number | null
    initiatedAt?: DateTimeWithAggregatesFilter<"TriTrackHandoff"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"TriTrackHandoff"> | Date | string | null
    latencyMs?: IntNullableWithAggregatesFilter<"TriTrackHandoff"> | number | null
    exceededLimit?: BoolWithAggregatesFilter<"TriTrackHandoff"> | boolean
    payload?: JsonWithAggregatesFilter<"TriTrackHandoff">
    result?: JsonNullableWithAggregatesFilter<"TriTrackHandoff">
    errorMessage?: StringNullableWithAggregatesFilter<"TriTrackHandoff"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"TriTrackHandoff">
  }

  export type ZScanVerificationWhereInput = {
    AND?: ZScanVerificationWhereInput | ZScanVerificationWhereInput[]
    OR?: ZScanVerificationWhereInput[]
    NOT?: ZScanVerificationWhereInput | ZScanVerificationWhereInput[]
    id?: IntFilter<"ZScanVerification"> | number
    userId?: IntNullableFilter<"ZScanVerification"> | number | null
    totalRules?: IntFilter<"ZScanVerification"> | number
    passed?: IntFilter<"ZScanVerification"> | number
    warnings?: IntFilter<"ZScanVerification"> | number
    critical?: IntFilter<"ZScanVerification"> | number
    results?: JsonFilter<"ZScanVerification">
    config?: JsonFilter<"ZScanVerification">
    createdAt?: DateTimeFilter<"ZScanVerification"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ZScanVerificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    totalRules?: SortOrder
    passed?: SortOrder
    warnings?: SortOrder
    critical?: SortOrder
    results?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ZScanVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ZScanVerificationWhereInput | ZScanVerificationWhereInput[]
    OR?: ZScanVerificationWhereInput[]
    NOT?: ZScanVerificationWhereInput | ZScanVerificationWhereInput[]
    userId?: IntNullableFilter<"ZScanVerification"> | number | null
    totalRules?: IntFilter<"ZScanVerification"> | number
    passed?: IntFilter<"ZScanVerification"> | number
    warnings?: IntFilter<"ZScanVerification"> | number
    critical?: IntFilter<"ZScanVerification"> | number
    results?: JsonFilter<"ZScanVerification">
    config?: JsonFilter<"ZScanVerification">
    createdAt?: DateTimeFilter<"ZScanVerification"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ZScanVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    totalRules?: SortOrder
    passed?: SortOrder
    warnings?: SortOrder
    critical?: SortOrder
    results?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    _count?: ZScanVerificationCountOrderByAggregateInput
    _avg?: ZScanVerificationAvgOrderByAggregateInput
    _max?: ZScanVerificationMaxOrderByAggregateInput
    _min?: ZScanVerificationMinOrderByAggregateInput
    _sum?: ZScanVerificationSumOrderByAggregateInput
  }

  export type ZScanVerificationScalarWhereWithAggregatesInput = {
    AND?: ZScanVerificationScalarWhereWithAggregatesInput | ZScanVerificationScalarWhereWithAggregatesInput[]
    OR?: ZScanVerificationScalarWhereWithAggregatesInput[]
    NOT?: ZScanVerificationScalarWhereWithAggregatesInput | ZScanVerificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ZScanVerification"> | number
    userId?: IntNullableWithAggregatesFilter<"ZScanVerification"> | number | null
    totalRules?: IntWithAggregatesFilter<"ZScanVerification"> | number
    passed?: IntWithAggregatesFilter<"ZScanVerification"> | number
    warnings?: IntWithAggregatesFilter<"ZScanVerification"> | number
    critical?: IntWithAggregatesFilter<"ZScanVerification"> | number
    results?: JsonWithAggregatesFilter<"ZScanVerification">
    config?: JsonWithAggregatesFilter<"ZScanVerification">
    createdAt?: DateTimeWithAggregatesFilter<"ZScanVerification"> | Date | string
  }

  export type SSOConfigurationWhereInput = {
    AND?: SSOConfigurationWhereInput | SSOConfigurationWhereInput[]
    OR?: SSOConfigurationWhereInput[]
    NOT?: SSOConfigurationWhereInput | SSOConfigurationWhereInput[]
    id?: IntFilter<"SSOConfiguration"> | number
    orgId?: IntFilter<"SSOConfiguration"> | number
    provider?: EnumSSOProviderFilter<"SSOConfiguration"> | $Enums.SSOProvider
    enabled?: BoolFilter<"SSOConfiguration"> | boolean
    samlEntryPoint?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlIssuer?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlCert?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlCallbackUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlLogoutUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthClientId?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthClientSecret?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthAuthUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthTokenUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthUserInfoUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthScopes?: StringNullableListFilter<"SSOConfiguration">
    domainRestriction?: StringNullableListFilter<"SSOConfiguration">
    jitProvisioning?: BoolFilter<"SSOConfiguration"> | boolean
    defaultRole?: EnumRoleFilter<"SSOConfiguration"> | $Enums.Role
    defaultTier?: EnumUserTierFilter<"SSOConfiguration"> | $Enums.UserTier
    metadata?: JsonNullableFilter<"SSOConfiguration">
    createdBy?: IntFilter<"SSOConfiguration"> | number
    createdAt?: DateTimeFilter<"SSOConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"SSOConfiguration"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"SSOConfiguration"> | Date | string | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type SSOConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    provider?: SortOrder
    enabled?: SortOrder
    samlEntryPoint?: SortOrderInput | SortOrder
    samlIssuer?: SortOrderInput | SortOrder
    samlCert?: SortOrderInput | SortOrder
    samlCallbackUrl?: SortOrderInput | SortOrder
    samlLogoutUrl?: SortOrderInput | SortOrder
    oauthClientId?: SortOrderInput | SortOrder
    oauthClientSecret?: SortOrderInput | SortOrder
    oauthAuthUrl?: SortOrderInput | SortOrder
    oauthTokenUrl?: SortOrderInput | SortOrder
    oauthUserInfoUrl?: SortOrderInput | SortOrder
    oauthScopes?: SortOrder
    domainRestriction?: SortOrder
    jitProvisioning?: SortOrder
    defaultRole?: SortOrder
    defaultTier?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type SSOConfigurationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orgId_provider?: SSOConfigurationOrgIdProviderCompoundUniqueInput
    AND?: SSOConfigurationWhereInput | SSOConfigurationWhereInput[]
    OR?: SSOConfigurationWhereInput[]
    NOT?: SSOConfigurationWhereInput | SSOConfigurationWhereInput[]
    orgId?: IntFilter<"SSOConfiguration"> | number
    provider?: EnumSSOProviderFilter<"SSOConfiguration"> | $Enums.SSOProvider
    enabled?: BoolFilter<"SSOConfiguration"> | boolean
    samlEntryPoint?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlIssuer?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlCert?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlCallbackUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlLogoutUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthClientId?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthClientSecret?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthAuthUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthTokenUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthUserInfoUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthScopes?: StringNullableListFilter<"SSOConfiguration">
    domainRestriction?: StringNullableListFilter<"SSOConfiguration">
    jitProvisioning?: BoolFilter<"SSOConfiguration"> | boolean
    defaultRole?: EnumRoleFilter<"SSOConfiguration"> | $Enums.Role
    defaultTier?: EnumUserTierFilter<"SSOConfiguration"> | $Enums.UserTier
    metadata?: JsonNullableFilter<"SSOConfiguration">
    createdBy?: IntFilter<"SSOConfiguration"> | number
    createdAt?: DateTimeFilter<"SSOConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"SSOConfiguration"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"SSOConfiguration"> | Date | string | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "orgId_provider">

  export type SSOConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    provider?: SortOrder
    enabled?: SortOrder
    samlEntryPoint?: SortOrderInput | SortOrder
    samlIssuer?: SortOrderInput | SortOrder
    samlCert?: SortOrderInput | SortOrder
    samlCallbackUrl?: SortOrderInput | SortOrder
    samlLogoutUrl?: SortOrderInput | SortOrder
    oauthClientId?: SortOrderInput | SortOrder
    oauthClientSecret?: SortOrderInput | SortOrder
    oauthAuthUrl?: SortOrderInput | SortOrder
    oauthTokenUrl?: SortOrderInput | SortOrder
    oauthUserInfoUrl?: SortOrderInput | SortOrder
    oauthScopes?: SortOrder
    domainRestriction?: SortOrder
    jitProvisioning?: SortOrder
    defaultRole?: SortOrder
    defaultTier?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    _count?: SSOConfigurationCountOrderByAggregateInput
    _avg?: SSOConfigurationAvgOrderByAggregateInput
    _max?: SSOConfigurationMaxOrderByAggregateInput
    _min?: SSOConfigurationMinOrderByAggregateInput
    _sum?: SSOConfigurationSumOrderByAggregateInput
  }

  export type SSOConfigurationScalarWhereWithAggregatesInput = {
    AND?: SSOConfigurationScalarWhereWithAggregatesInput | SSOConfigurationScalarWhereWithAggregatesInput[]
    OR?: SSOConfigurationScalarWhereWithAggregatesInput[]
    NOT?: SSOConfigurationScalarWhereWithAggregatesInput | SSOConfigurationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SSOConfiguration"> | number
    orgId?: IntWithAggregatesFilter<"SSOConfiguration"> | number
    provider?: EnumSSOProviderWithAggregatesFilter<"SSOConfiguration"> | $Enums.SSOProvider
    enabled?: BoolWithAggregatesFilter<"SSOConfiguration"> | boolean
    samlEntryPoint?: StringNullableWithAggregatesFilter<"SSOConfiguration"> | string | null
    samlIssuer?: StringNullableWithAggregatesFilter<"SSOConfiguration"> | string | null
    samlCert?: StringNullableWithAggregatesFilter<"SSOConfiguration"> | string | null
    samlCallbackUrl?: StringNullableWithAggregatesFilter<"SSOConfiguration"> | string | null
    samlLogoutUrl?: StringNullableWithAggregatesFilter<"SSOConfiguration"> | string | null
    oauthClientId?: StringNullableWithAggregatesFilter<"SSOConfiguration"> | string | null
    oauthClientSecret?: StringNullableWithAggregatesFilter<"SSOConfiguration"> | string | null
    oauthAuthUrl?: StringNullableWithAggregatesFilter<"SSOConfiguration"> | string | null
    oauthTokenUrl?: StringNullableWithAggregatesFilter<"SSOConfiguration"> | string | null
    oauthUserInfoUrl?: StringNullableWithAggregatesFilter<"SSOConfiguration"> | string | null
    oauthScopes?: StringNullableListFilter<"SSOConfiguration">
    domainRestriction?: StringNullableListFilter<"SSOConfiguration">
    jitProvisioning?: BoolWithAggregatesFilter<"SSOConfiguration"> | boolean
    defaultRole?: EnumRoleWithAggregatesFilter<"SSOConfiguration"> | $Enums.Role
    defaultTier?: EnumUserTierWithAggregatesFilter<"SSOConfiguration"> | $Enums.UserTier
    metadata?: JsonNullableWithAggregatesFilter<"SSOConfiguration">
    createdBy?: IntWithAggregatesFilter<"SSOConfiguration"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SSOConfiguration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SSOConfiguration"> | Date | string
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"SSOConfiguration"> | Date | string | null
  }

  export type NotificationPreferenceWhereInput = {
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    id?: IntFilter<"NotificationPreference"> | number
    userId?: IntFilter<"NotificationPreference"> | number
    emailEnabled?: BoolFilter<"NotificationPreference"> | boolean
    testComplete?: BoolFilter<"NotificationPreference"> | boolean
    batchComplete?: BoolFilter<"NotificationPreference"> | boolean
    scheduledTestComplete?: BoolFilter<"NotificationPreference"> | boolean
    alertsEnabled?: BoolFilter<"NotificationPreference"> | boolean
    lowScoreThreshold?: FloatFilter<"NotificationPreference"> | number
    highScoreThreshold?: FloatFilter<"NotificationPreference"> | number
    scoreDropAlert?: BoolFilter<"NotificationPreference"> | boolean
    witnessFailureAlert?: BoolFilter<"NotificationPreference"> | boolean
    dailyReport?: BoolFilter<"NotificationPreference"> | boolean
    weeklyReport?: BoolFilter<"NotificationPreference"> | boolean
    monthlyReport?: BoolFilter<"NotificationPreference"> | boolean
    reportTime?: StringFilter<"NotificationPreference"> | string
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    testComplete?: SortOrder
    batchComplete?: SortOrder
    scheduledTestComplete?: SortOrder
    alertsEnabled?: SortOrder
    lowScoreThreshold?: SortOrder
    highScoreThreshold?: SortOrder
    scoreDropAlert?: SortOrder
    witnessFailureAlert?: SortOrder
    dailyReport?: SortOrder
    weeklyReport?: SortOrder
    monthlyReport?: SortOrder
    reportTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    emailEnabled?: BoolFilter<"NotificationPreference"> | boolean
    testComplete?: BoolFilter<"NotificationPreference"> | boolean
    batchComplete?: BoolFilter<"NotificationPreference"> | boolean
    scheduledTestComplete?: BoolFilter<"NotificationPreference"> | boolean
    alertsEnabled?: BoolFilter<"NotificationPreference"> | boolean
    lowScoreThreshold?: FloatFilter<"NotificationPreference"> | number
    highScoreThreshold?: FloatFilter<"NotificationPreference"> | number
    scoreDropAlert?: BoolFilter<"NotificationPreference"> | boolean
    witnessFailureAlert?: BoolFilter<"NotificationPreference"> | boolean
    dailyReport?: BoolFilter<"NotificationPreference"> | boolean
    weeklyReport?: BoolFilter<"NotificationPreference"> | boolean
    monthlyReport?: BoolFilter<"NotificationPreference"> | boolean
    reportTime?: StringFilter<"NotificationPreference"> | string
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NotificationPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    testComplete?: SortOrder
    batchComplete?: SortOrder
    scheduledTestComplete?: SortOrder
    alertsEnabled?: SortOrder
    lowScoreThreshold?: SortOrder
    highScoreThreshold?: SortOrder
    scoreDropAlert?: SortOrder
    witnessFailureAlert?: SortOrder
    dailyReport?: SortOrder
    weeklyReport?: SortOrder
    monthlyReport?: SortOrder
    reportTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPreferenceCountOrderByAggregateInput
    _avg?: NotificationPreferenceAvgOrderByAggregateInput
    _max?: NotificationPreferenceMaxOrderByAggregateInput
    _min?: NotificationPreferenceMinOrderByAggregateInput
    _sum?: NotificationPreferenceSumOrderByAggregateInput
  }

  export type NotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    OR?: NotificationPreferenceScalarWhereWithAggregatesInput[]
    NOT?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NotificationPreference"> | number
    userId?: IntWithAggregatesFilter<"NotificationPreference"> | number
    emailEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    testComplete?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    batchComplete?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    scheduledTestComplete?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    alertsEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    lowScoreThreshold?: FloatWithAggregatesFilter<"NotificationPreference"> | number
    highScoreThreshold?: FloatWithAggregatesFilter<"NotificationPreference"> | number
    scoreDropAlert?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    witnessFailureAlert?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    dailyReport?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    weeklyReport?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    monthlyReport?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    reportTime?: StringWithAggregatesFilter<"NotificationPreference"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrganizationCreateInput = {
    name: string
    plan?: $Enums.PlanType
    status?: $Enums.OrgStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    teams?: TeamCreateNestedManyWithoutOrganizationInput
    ssoConfigs?: SSOConfigurationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: number
    name: string
    plan?: $Enums.PlanType
    status?: $Enums.OrgStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    teams?: TeamUncheckedCreateNestedManyWithoutOrganizationInput
    ssoConfigs?: SSOConfigurationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    status?: EnumOrgStatusFieldUpdateOperationsInput | $Enums.OrgStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    teams?: TeamUpdateManyWithoutOrganizationNestedInput
    ssoConfigs?: SSOConfigurationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    status?: EnumOrgStatusFieldUpdateOperationsInput | $Enums.OrgStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    teams?: TeamUncheckedUpdateManyWithoutOrganizationNestedInput
    ssoConfigs?: SSOConfigurationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: number
    name: string
    plan?: $Enums.PlanType
    status?: $Enums.OrgStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    status?: EnumOrgStatusFieldUpdateOperationsInput | $Enums.OrgStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    status?: EnumOrgStatusFieldUpdateOperationsInput | $Enums.OrgStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: number
    name: string
    orgId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    orgId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: number
    name: string
    orgId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    orgId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateInput = {
    role?: $Enums.TeamRole
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutTeamsInput
  }

  export type TeamMemberUncheckedCreateInput = {
    id?: number
    teamId: number
    userId: number
    role?: $Enums.TeamRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUpdateInput = {
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutTeamsNestedInput
  }

  export type TeamMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyInput = {
    id?: number
    teamId: number
    userId: number
    role?: $Enums.TeamRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUpdateManyMutationInput = {
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditRecordCreateInput = {
    action: string
    category: $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AuditStatus
    lamport: number
    hashPointer?: string | null
    organizationId?: number | null
    blockHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAuditsInput
  }

  export type AuditRecordUncheckedCreateInput = {
    id?: number
    userId: number
    action: string
    category: $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AuditStatus
    lamport: number
    hashPointer?: string | null
    organizationId?: number | null
    blockHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditRecordUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    category?: EnumAuditCategoryFieldUpdateOperationsInput | $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    lamport?: IntFieldUpdateOperationsInput | number
    hashPointer?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    blockHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditsNestedInput
  }

  export type AuditRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    category?: EnumAuditCategoryFieldUpdateOperationsInput | $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    lamport?: IntFieldUpdateOperationsInput | number
    hashPointer?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    blockHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditRecordCreateManyInput = {
    id?: number
    userId: number
    action: string
    category: $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AuditStatus
    lamport: number
    hashPointer?: string | null
    organizationId?: number | null
    blockHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditRecordUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    category?: EnumAuditCategoryFieldUpdateOperationsInput | $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    lamport?: IntFieldUpdateOperationsInput | number
    hashPointer?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    blockHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    category?: EnumAuditCategoryFieldUpdateOperationsInput | $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    lamport?: IntFieldUpdateOperationsInput | number
    hashPointer?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    blockHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockCreateInput = {
    hash: string
    previousHash: string
    organizationId?: number | null
    lamportClock: number
    metricsData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockUncheckedCreateInput = {
    id?: number
    hash: string
    previousHash: string
    organizationId?: number | null
    lamportClock: number
    metricsData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockUpdateInput = {
    hash?: StringFieldUpdateOperationsInput | string
    previousHash?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    lamportClock?: IntFieldUpdateOperationsInput | number
    metricsData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hash?: StringFieldUpdateOperationsInput | string
    previousHash?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    lamportClock?: IntFieldUpdateOperationsInput | number
    metricsData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockCreateManyInput = {
    id?: number
    hash: string
    previousHash: string
    organizationId?: number | null
    lamportClock: number
    metricsData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockUpdateManyMutationInput = {
    hash?: StringFieldUpdateOperationsInput | string
    previousHash?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    lamportClock?: IntFieldUpdateOperationsInput | number
    metricsData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hash?: StringFieldUpdateOperationsInput | string
    previousHash?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    lamportClock?: IntFieldUpdateOperationsInput | number
    metricsData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: number
    userId: number
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type SessionUpdateInput = {
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: number
    userId: number
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCreateInput = {
    limit: number
    period?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBudgetsInput
  }

  export type BudgetUncheckedCreateInput = {
    id?: number
    userId: number
    limit: number
    period?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetUpdateInput = {
    limit?: FloatFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBudgetsNestedInput
  }

  export type BudgetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    limit?: FloatFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCreateManyInput = {
    id?: number
    userId: number
    limit: number
    period?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetUpdateManyMutationInput = {
    limit?: FloatFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    limit?: FloatFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegressionBaselineCreateInput = {
    modelName: string
    modelVersion?: string | null
    testType: string
    avgResponseTime: number
    avgCost: number
    avgQualityScore: number
    avgAccuracy: number
    successRate: number
    alertThreshold?: number
    sampleSize: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRegressionBaselinesInput
  }

  export type RegressionBaselineUncheckedCreateInput = {
    id?: number
    userId: number
    modelName: string
    modelVersion?: string | null
    testType: string
    avgResponseTime: number
    avgCost: number
    avgQualityScore: number
    avgAccuracy: number
    successRate: number
    alertThreshold?: number
    sampleSize: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegressionBaselineUpdateInput = {
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: StringFieldUpdateOperationsInput | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    avgQualityScore?: FloatFieldUpdateOperationsInput | number
    avgAccuracy?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRegressionBaselinesNestedInput
  }

  export type RegressionBaselineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: StringFieldUpdateOperationsInput | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    avgQualityScore?: FloatFieldUpdateOperationsInput | number
    avgAccuracy?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegressionBaselineCreateManyInput = {
    id?: number
    userId: number
    modelName: string
    modelVersion?: string | null
    testType: string
    avgResponseTime: number
    avgCost: number
    avgQualityScore: number
    avgAccuracy: number
    successRate: number
    alertThreshold?: number
    sampleSize: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegressionBaselineUpdateManyMutationInput = {
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: StringFieldUpdateOperationsInput | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    avgQualityScore?: FloatFieldUpdateOperationsInput | number
    avgAccuracy?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegressionBaselineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: StringFieldUpdateOperationsInput | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    avgQualityScore?: FloatFieldUpdateOperationsInput | number
    avgAccuracy?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateInput = {
    type: $Enums.FeedbackType
    category: $Enums.FeedbackCategory
    priority?: $Enums.FeedbackPriority
    subject: string
    message: string
    url?: string | null
    userAgent?: string | null
    status?: $Enums.FeedbackStatus
    assignedTo?: number | null
    response?: string | null
    respondedAt?: Date | string | null
    respondedBy?: number | null
    sentiment?: string | null
    sentimentScore?: number | null
    upvotes?: number
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    user: UserCreateNestedOneWithoutFeedbacksInput
  }

  export type FeedbackUncheckedCreateInput = {
    id?: number
    userId: number
    type: $Enums.FeedbackType
    category: $Enums.FeedbackCategory
    priority?: $Enums.FeedbackPriority
    subject: string
    message: string
    url?: string | null
    userAgent?: string | null
    status?: $Enums.FeedbackStatus
    assignedTo?: number | null
    response?: string | null
    respondedAt?: Date | string | null
    respondedBy?: number | null
    sentiment?: string | null
    sentimentScore?: number | null
    upvotes?: number
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type FeedbackUpdateInput = {
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type FeedbackUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeedbackCreateManyInput = {
    id?: number
    userId: number
    type: $Enums.FeedbackType
    category: $Enums.FeedbackCategory
    priority?: $Enums.FeedbackPriority
    subject: string
    message: string
    url?: string | null
    userAgent?: string | null
    status?: $Enums.FeedbackStatus
    assignedTo?: number | null
    response?: string | null
    respondedAt?: Date | string | null
    respondedBy?: number | null
    sentiment?: string | null
    sentimentScore?: number | null
    upvotes?: number
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type FeedbackUpdateManyMutationInput = {
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeedbackUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BENReceiptCreateInput = {
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp?: Date | string
    persona?: $Enums.BENPersona
    track?: $Enums.TrackType | null
    payload: JsonNullValueInput | InputJsonValue
    digest: string
    previousDigest?: string | null
    baselineDigest?: string | null
    witnessModel?: string | null
    witnessSignature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutBenReceiptsInput
    handoffsFrom?: TriTrackHandoffCreateNestedManyWithoutFromReceiptInput
    handoffsTo?: TriTrackHandoffCreateNestedManyWithoutToReceiptInput
  }

  export type BENReceiptUncheckedCreateInput = {
    id?: number
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp?: Date | string
    userId?: number | null
    persona?: $Enums.BENPersona
    track?: $Enums.TrackType | null
    payload: JsonNullValueInput | InputJsonValue
    digest: string
    previousDigest?: string | null
    baselineDigest?: string | null
    witnessModel?: string | null
    witnessSignature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    handoffsFrom?: TriTrackHandoffUncheckedCreateNestedManyWithoutFromReceiptInput
    handoffsTo?: TriTrackHandoffUncheckedCreateNestedManyWithoutToReceiptInput
  }

  export type BENReceiptUpdateInput = {
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutBenReceiptsNestedInput
    handoffsFrom?: TriTrackHandoffUpdateManyWithoutFromReceiptNestedInput
    handoffsTo?: TriTrackHandoffUpdateManyWithoutToReceiptNestedInput
  }

  export type BENReceiptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handoffsFrom?: TriTrackHandoffUncheckedUpdateManyWithoutFromReceiptNestedInput
    handoffsTo?: TriTrackHandoffUncheckedUpdateManyWithoutToReceiptNestedInput
  }

  export type BENReceiptCreateManyInput = {
    id?: number
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp?: Date | string
    userId?: number | null
    persona?: $Enums.BENPersona
    track?: $Enums.TrackType | null
    payload: JsonNullValueInput | InputJsonValue
    digest: string
    previousDigest?: string | null
    baselineDigest?: string | null
    witnessModel?: string | null
    witnessSignature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BENReceiptUpdateManyMutationInput = {
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BENReceiptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BENSessionCreateInput = {
    persona: $Enums.BENPersona
    priority: number
    locked?: boolean
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    startLamport: number
    endLamport?: number | null
    switchReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutBenSessionsInput
  }

  export type BENSessionUncheckedCreateInput = {
    id?: number
    userId: number
    persona: $Enums.BENPersona
    priority: number
    locked?: boolean
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    startLamport: number
    endLamport?: number | null
    switchReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BENSessionUpdateInput = {
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    priority?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startLamport?: IntFieldUpdateOperationsInput | number
    endLamport?: NullableIntFieldUpdateOperationsInput | number | null
    switchReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutBenSessionsNestedInput
  }

  export type BENSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    priority?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startLamport?: IntFieldUpdateOperationsInput | number
    endLamport?: NullableIntFieldUpdateOperationsInput | number | null
    switchReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BENSessionCreateManyInput = {
    id?: number
    userId: number
    persona: $Enums.BENPersona
    priority: number
    locked?: boolean
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    startLamport: number
    endLamport?: number | null
    switchReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BENSessionUpdateManyMutationInput = {
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    priority?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startLamport?: IntFieldUpdateOperationsInput | number
    endLamport?: NullableIntFieldUpdateOperationsInput | number | null
    switchReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BENSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    priority?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startLamport?: IntFieldUpdateOperationsInput | number
    endLamport?: NullableIntFieldUpdateOperationsInput | number | null
    switchReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffCreateInput = {
    fromTrack: $Enums.TrackType
    toTrack: $Enums.TrackType
    status?: $Enums.HandoffStatus
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    latencyMs?: number | null
    exceededLimit?: boolean
    payload: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    fromReceipt: BENReceiptCreateNestedOneWithoutHandoffsFromInput
    toReceipt?: BENReceiptCreateNestedOneWithoutHandoffsToInput
  }

  export type TriTrackHandoffUncheckedCreateInput = {
    id?: number
    fromTrack: $Enums.TrackType
    toTrack: $Enums.TrackType
    status?: $Enums.HandoffStatus
    fromReceiptId: number
    toReceiptId?: number | null
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    latencyMs?: number | null
    exceededLimit?: boolean
    payload: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffUpdateInput = {
    fromTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    toTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    status?: EnumHandoffStatusFieldUpdateOperationsInput | $Enums.HandoffStatus
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    exceededLimit?: BoolFieldUpdateOperationsInput | boolean
    payload?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    fromReceipt?: BENReceiptUpdateOneRequiredWithoutHandoffsFromNestedInput
    toReceipt?: BENReceiptUpdateOneWithoutHandoffsToNestedInput
  }

  export type TriTrackHandoffUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    toTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    status?: EnumHandoffStatusFieldUpdateOperationsInput | $Enums.HandoffStatus
    fromReceiptId?: IntFieldUpdateOperationsInput | number
    toReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    exceededLimit?: BoolFieldUpdateOperationsInput | boolean
    payload?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffCreateManyInput = {
    id?: number
    fromTrack: $Enums.TrackType
    toTrack: $Enums.TrackType
    status?: $Enums.HandoffStatus
    fromReceiptId: number
    toReceiptId?: number | null
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    latencyMs?: number | null
    exceededLimit?: boolean
    payload: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffUpdateManyMutationInput = {
    fromTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    toTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    status?: EnumHandoffStatusFieldUpdateOperationsInput | $Enums.HandoffStatus
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    exceededLimit?: BoolFieldUpdateOperationsInput | boolean
    payload?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    toTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    status?: EnumHandoffStatusFieldUpdateOperationsInput | $Enums.HandoffStatus
    fromReceiptId?: IntFieldUpdateOperationsInput | number
    toReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    exceededLimit?: BoolFieldUpdateOperationsInput | boolean
    payload?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ZScanVerificationCreateInput = {
    totalRules: number
    passed: number
    warnings: number
    critical: number
    results: JsonNullValueInput | InputJsonValue
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutZscansInput
  }

  export type ZScanVerificationUncheckedCreateInput = {
    id?: number
    userId?: number | null
    totalRules: number
    passed: number
    warnings: number
    critical: number
    results: JsonNullValueInput | InputJsonValue
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ZScanVerificationUpdateInput = {
    totalRules?: IntFieldUpdateOperationsInput | number
    passed?: IntFieldUpdateOperationsInput | number
    warnings?: IntFieldUpdateOperationsInput | number
    critical?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutZscansNestedInput
  }

  export type ZScanVerificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    totalRules?: IntFieldUpdateOperationsInput | number
    passed?: IntFieldUpdateOperationsInput | number
    warnings?: IntFieldUpdateOperationsInput | number
    critical?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZScanVerificationCreateManyInput = {
    id?: number
    userId?: number | null
    totalRules: number
    passed: number
    warnings: number
    critical: number
    results: JsonNullValueInput | InputJsonValue
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ZScanVerificationUpdateManyMutationInput = {
    totalRules?: IntFieldUpdateOperationsInput | number
    passed?: IntFieldUpdateOperationsInput | number
    warnings?: IntFieldUpdateOperationsInput | number
    critical?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZScanVerificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    totalRules?: IntFieldUpdateOperationsInput | number
    passed?: IntFieldUpdateOperationsInput | number
    warnings?: IntFieldUpdateOperationsInput | number
    critical?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SSOConfigurationCreateInput = {
    provider: $Enums.SSOProvider
    enabled?: boolean
    samlEntryPoint?: string | null
    samlIssuer?: string | null
    samlCert?: string | null
    samlCallbackUrl?: string | null
    samlLogoutUrl?: string | null
    oauthClientId?: string | null
    oauthClientSecret?: string | null
    oauthAuthUrl?: string | null
    oauthTokenUrl?: string | null
    oauthUserInfoUrl?: string | null
    oauthScopes?: SSOConfigurationCreateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationCreatedomainRestrictionInput | string[]
    jitProvisioning?: boolean
    defaultRole?: $Enums.Role
    defaultTier?: $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
    organization: OrganizationCreateNestedOneWithoutSsoConfigsInput
  }

  export type SSOConfigurationUncheckedCreateInput = {
    id?: number
    orgId: number
    provider: $Enums.SSOProvider
    enabled?: boolean
    samlEntryPoint?: string | null
    samlIssuer?: string | null
    samlCert?: string | null
    samlCallbackUrl?: string | null
    samlLogoutUrl?: string | null
    oauthClientId?: string | null
    oauthClientSecret?: string | null
    oauthAuthUrl?: string | null
    oauthTokenUrl?: string | null
    oauthUserInfoUrl?: string | null
    oauthScopes?: SSOConfigurationCreateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationCreatedomainRestrictionInput | string[]
    jitProvisioning?: boolean
    defaultRole?: $Enums.Role
    defaultTier?: $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type SSOConfigurationUpdateInput = {
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    enabled?: BoolFieldUpdateOperationsInput | boolean
    samlEntryPoint?: NullableStringFieldUpdateOperationsInput | string | null
    samlIssuer?: NullableStringFieldUpdateOperationsInput | string | null
    samlCert?: NullableStringFieldUpdateOperationsInput | string | null
    samlCallbackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    samlLogoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthAuthUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthUserInfoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthScopes?: SSOConfigurationUpdateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationUpdatedomainRestrictionInput | string[]
    jitProvisioning?: BoolFieldUpdateOperationsInput | boolean
    defaultRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    defaultTier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: OrganizationUpdateOneRequiredWithoutSsoConfigsNestedInput
  }

  export type SSOConfigurationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orgId?: IntFieldUpdateOperationsInput | number
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    enabled?: BoolFieldUpdateOperationsInput | boolean
    samlEntryPoint?: NullableStringFieldUpdateOperationsInput | string | null
    samlIssuer?: NullableStringFieldUpdateOperationsInput | string | null
    samlCert?: NullableStringFieldUpdateOperationsInput | string | null
    samlCallbackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    samlLogoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthAuthUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthUserInfoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthScopes?: SSOConfigurationUpdateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationUpdatedomainRestrictionInput | string[]
    jitProvisioning?: BoolFieldUpdateOperationsInput | boolean
    defaultRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    defaultTier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SSOConfigurationCreateManyInput = {
    id?: number
    orgId: number
    provider: $Enums.SSOProvider
    enabled?: boolean
    samlEntryPoint?: string | null
    samlIssuer?: string | null
    samlCert?: string | null
    samlCallbackUrl?: string | null
    samlLogoutUrl?: string | null
    oauthClientId?: string | null
    oauthClientSecret?: string | null
    oauthAuthUrl?: string | null
    oauthTokenUrl?: string | null
    oauthUserInfoUrl?: string | null
    oauthScopes?: SSOConfigurationCreateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationCreatedomainRestrictionInput | string[]
    jitProvisioning?: boolean
    defaultRole?: $Enums.Role
    defaultTier?: $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type SSOConfigurationUpdateManyMutationInput = {
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    enabled?: BoolFieldUpdateOperationsInput | boolean
    samlEntryPoint?: NullableStringFieldUpdateOperationsInput | string | null
    samlIssuer?: NullableStringFieldUpdateOperationsInput | string | null
    samlCert?: NullableStringFieldUpdateOperationsInput | string | null
    samlCallbackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    samlLogoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthAuthUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthUserInfoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthScopes?: SSOConfigurationUpdateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationUpdatedomainRestrictionInput | string[]
    jitProvisioning?: BoolFieldUpdateOperationsInput | boolean
    defaultRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    defaultTier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SSOConfigurationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orgId?: IntFieldUpdateOperationsInput | number
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    enabled?: BoolFieldUpdateOperationsInput | boolean
    samlEntryPoint?: NullableStringFieldUpdateOperationsInput | string | null
    samlIssuer?: NullableStringFieldUpdateOperationsInput | string | null
    samlCert?: NullableStringFieldUpdateOperationsInput | string | null
    samlCallbackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    samlLogoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthAuthUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthUserInfoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthScopes?: SSOConfigurationUpdateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationUpdatedomainRestrictionInput | string[]
    jitProvisioning?: BoolFieldUpdateOperationsInput | boolean
    defaultRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    defaultTier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationPreferenceCreateInput = {
    emailEnabled?: boolean
    testComplete?: boolean
    batchComplete?: boolean
    scheduledTestComplete?: boolean
    alertsEnabled?: boolean
    lowScoreThreshold?: number
    highScoreThreshold?: number
    scoreDropAlert?: boolean
    witnessFailureAlert?: boolean
    dailyReport?: boolean
    weeklyReport?: boolean
    monthlyReport?: boolean
    reportTime?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationPreferenceUncheckedCreateInput = {
    id?: number
    userId: number
    emailEnabled?: boolean
    testComplete?: boolean
    batchComplete?: boolean
    scheduledTestComplete?: boolean
    alertsEnabled?: boolean
    lowScoreThreshold?: number
    highScoreThreshold?: number
    scoreDropAlert?: boolean
    witnessFailureAlert?: boolean
    dailyReport?: boolean
    weeklyReport?: boolean
    monthlyReport?: boolean
    reportTime?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateInput = {
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    testComplete?: BoolFieldUpdateOperationsInput | boolean
    batchComplete?: BoolFieldUpdateOperationsInput | boolean
    scheduledTestComplete?: BoolFieldUpdateOperationsInput | boolean
    alertsEnabled?: BoolFieldUpdateOperationsInput | boolean
    lowScoreThreshold?: FloatFieldUpdateOperationsInput | number
    highScoreThreshold?: FloatFieldUpdateOperationsInput | number
    scoreDropAlert?: BoolFieldUpdateOperationsInput | boolean
    witnessFailureAlert?: BoolFieldUpdateOperationsInput | boolean
    dailyReport?: BoolFieldUpdateOperationsInput | boolean
    weeklyReport?: BoolFieldUpdateOperationsInput | boolean
    monthlyReport?: BoolFieldUpdateOperationsInput | boolean
    reportTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationPreferenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    testComplete?: BoolFieldUpdateOperationsInput | boolean
    batchComplete?: BoolFieldUpdateOperationsInput | boolean
    scheduledTestComplete?: BoolFieldUpdateOperationsInput | boolean
    alertsEnabled?: BoolFieldUpdateOperationsInput | boolean
    lowScoreThreshold?: FloatFieldUpdateOperationsInput | number
    highScoreThreshold?: FloatFieldUpdateOperationsInput | number
    scoreDropAlert?: BoolFieldUpdateOperationsInput | boolean
    witnessFailureAlert?: BoolFieldUpdateOperationsInput | boolean
    dailyReport?: BoolFieldUpdateOperationsInput | boolean
    weeklyReport?: BoolFieldUpdateOperationsInput | boolean
    monthlyReport?: BoolFieldUpdateOperationsInput | boolean
    reportTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateManyInput = {
    id?: number
    userId: number
    emailEnabled?: boolean
    testComplete?: boolean
    batchComplete?: boolean
    scheduledTestComplete?: boolean
    alertsEnabled?: boolean
    lowScoreThreshold?: number
    highScoreThreshold?: number
    scoreDropAlert?: boolean
    witnessFailureAlert?: boolean
    dailyReport?: boolean
    weeklyReport?: boolean
    monthlyReport?: boolean
    reportTime?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateManyMutationInput = {
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    testComplete?: BoolFieldUpdateOperationsInput | boolean
    batchComplete?: BoolFieldUpdateOperationsInput | boolean
    scheduledTestComplete?: BoolFieldUpdateOperationsInput | boolean
    alertsEnabled?: BoolFieldUpdateOperationsInput | boolean
    lowScoreThreshold?: FloatFieldUpdateOperationsInput | number
    highScoreThreshold?: FloatFieldUpdateOperationsInput | number
    scoreDropAlert?: BoolFieldUpdateOperationsInput | boolean
    witnessFailureAlert?: BoolFieldUpdateOperationsInput | boolean
    dailyReport?: BoolFieldUpdateOperationsInput | boolean
    weeklyReport?: BoolFieldUpdateOperationsInput | boolean
    monthlyReport?: BoolFieldUpdateOperationsInput | boolean
    reportTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    testComplete?: BoolFieldUpdateOperationsInput | boolean
    batchComplete?: BoolFieldUpdateOperationsInput | boolean
    scheduledTestComplete?: BoolFieldUpdateOperationsInput | boolean
    alertsEnabled?: BoolFieldUpdateOperationsInput | boolean
    lowScoreThreshold?: FloatFieldUpdateOperationsInput | number
    highScoreThreshold?: FloatFieldUpdateOperationsInput | number
    scoreDropAlert?: BoolFieldUpdateOperationsInput | boolean
    witnessFailureAlert?: BoolFieldUpdateOperationsInput | boolean
    dailyReport?: BoolFieldUpdateOperationsInput | boolean
    weeklyReport?: BoolFieldUpdateOperationsInput | boolean
    monthlyReport?: BoolFieldUpdateOperationsInput | boolean
    reportTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EnumUserTierFilter<$PrismaModel = never> = {
    equals?: $Enums.UserTier | EnumUserTierFieldRefInput<$PrismaModel>
    in?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTierFilter<$PrismaModel> | $Enums.UserTier
  }

  export type EnumPermissionNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel> | null
    has?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumBENPersonaFilter<$PrismaModel = never> = {
    equals?: $Enums.BENPersona | EnumBENPersonaFieldRefInput<$PrismaModel>
    in?: $Enums.BENPersona[] | ListEnumBENPersonaFieldRefInput<$PrismaModel>
    notIn?: $Enums.BENPersona[] | ListEnumBENPersonaFieldRefInput<$PrismaModel>
    not?: NestedEnumBENPersonaFilter<$PrismaModel> | $Enums.BENPersona
  }

  export type OrganizationNullableScalarRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AuditRecordListRelationFilter = {
    every?: AuditRecordWhereInput
    some?: AuditRecordWhereInput
    none?: AuditRecordWhereInput
  }

  export type TeamMemberListRelationFilter = {
    every?: TeamMemberWhereInput
    some?: TeamMemberWhereInput
    none?: TeamMemberWhereInput
  }

  export type NotificationPreferenceNullableScalarRelationFilter = {
    is?: NotificationPreferenceWhereInput | null
    isNot?: NotificationPreferenceWhereInput | null
  }

  export type BudgetListRelationFilter = {
    every?: BudgetWhereInput
    some?: BudgetWhereInput
    none?: BudgetWhereInput
  }

  export type RegressionBaselineListRelationFilter = {
    every?: RegressionBaselineWhereInput
    some?: RegressionBaselineWhereInput
    none?: RegressionBaselineWhereInput
  }

  export type FeedbackListRelationFilter = {
    every?: FeedbackWhereInput
    some?: FeedbackWhereInput
    none?: FeedbackWhereInput
  }

  export type BENReceiptListRelationFilter = {
    every?: BENReceiptWhereInput
    some?: BENReceiptWhereInput
    none?: BENReceiptWhereInput
  }

  export type BENSessionListRelationFilter = {
    every?: BENSessionWhereInput
    some?: BENSessionWhereInput
    none?: BENSessionWhereInput
  }

  export type ZScanVerificationListRelationFilter = {
    every?: ZScanVerificationWhereInput
    some?: ZScanVerificationWhereInput
    none?: ZScanVerificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BudgetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegressionBaselineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BENReceiptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BENSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZScanVerificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    tier?: SortOrder
    permissions?: SortOrder
    orgId?: SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    backupCodes?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    passwordChangedAt?: SortOrder
    ssoProvider?: SortOrder
    ssoId?: SortOrder
    ssoMetadata?: SortOrder
    currentPersona?: SortOrder
    personaLocked?: SortOrder
    lamportCounter?: SortOrder
    lastReceiptId?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    failedLoginAttempts?: SortOrder
    lamportCounter?: SortOrder
    lastReceiptId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    tier?: SortOrder
    orgId?: SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    passwordChangedAt?: SortOrder
    ssoProvider?: SortOrder
    ssoId?: SortOrder
    currentPersona?: SortOrder
    personaLocked?: SortOrder
    lamportCounter?: SortOrder
    lastReceiptId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    tier?: SortOrder
    orgId?: SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    passwordChangedAt?: SortOrder
    ssoProvider?: SortOrder
    ssoId?: SortOrder
    currentPersona?: SortOrder
    personaLocked?: SortOrder
    lamportCounter?: SortOrder
    lastReceiptId?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    failedLoginAttempts?: SortOrder
    lamportCounter?: SortOrder
    lastReceiptId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumUserTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserTier | EnumUserTierFieldRefInput<$PrismaModel>
    in?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTierWithAggregatesFilter<$PrismaModel> | $Enums.UserTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTierFilter<$PrismaModel>
    _max?: NestedEnumUserTierFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumBENPersonaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BENPersona | EnumBENPersonaFieldRefInput<$PrismaModel>
    in?: $Enums.BENPersona[] | ListEnumBENPersonaFieldRefInput<$PrismaModel>
    notIn?: $Enums.BENPersona[] | ListEnumBENPersonaFieldRefInput<$PrismaModel>
    not?: NestedEnumBENPersonaWithAggregatesFilter<$PrismaModel> | $Enums.BENPersona
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBENPersonaFilter<$PrismaModel>
    _max?: NestedEnumBENPersonaFilter<$PrismaModel>
  }

  export type EnumPlanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeFilter<$PrismaModel> | $Enums.PlanType
  }

  export type EnumOrgStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgStatus | EnumOrgStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrgStatus[] | ListEnumOrgStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgStatus[] | ListEnumOrgStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgStatusFilter<$PrismaModel> | $Enums.OrgStatus
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type SSOConfigurationListRelationFilter = {
    every?: SSOConfigurationWhereInput
    some?: SSOConfigurationWhereInput
    none?: SSOConfigurationWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SSOConfigurationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumPlanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTypeFilter<$PrismaModel>
    _max?: NestedEnumPlanTypeFilter<$PrismaModel>
  }

  export type EnumOrgStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgStatus | EnumOrgStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrgStatus[] | ListEnumOrgStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgStatus[] | ListEnumOrgStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrgStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrgStatusFilter<$PrismaModel>
    _max?: NestedEnumOrgStatusFilter<$PrismaModel>
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamAvgOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamSumOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
  }

  export type EnumTeamRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleFilter<$PrismaModel> | $Enums.TeamRole
  }

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TeamMemberTeamIdUserIdCompoundUniqueInput = {
    teamId: number
    userId: number
  }

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type EnumTeamRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel> | $Enums.TeamRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamRoleFilter<$PrismaModel>
    _max?: NestedEnumTeamRoleFilter<$PrismaModel>
  }

  export type EnumAuditCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditCategory | EnumAuditCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AuditCategory[] | ListEnumAuditCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditCategory[] | ListEnumAuditCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditCategoryFilter<$PrismaModel> | $Enums.AuditCategory
  }

  export type EnumAuditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusFilter<$PrismaModel> | $Enums.AuditStatus
  }

  export type AuditRecordCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    category?: SortOrder
    details?: SortOrder
    metadata?: SortOrder
    status?: SortOrder
    lamport?: SortOrder
    hashPointer?: SortOrder
    organizationId?: SortOrder
    blockHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lamport?: SortOrder
    organizationId?: SortOrder
  }

  export type AuditRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    category?: SortOrder
    status?: SortOrder
    lamport?: SortOrder
    hashPointer?: SortOrder
    organizationId?: SortOrder
    blockHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditRecordMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    category?: SortOrder
    status?: SortOrder
    lamport?: SortOrder
    hashPointer?: SortOrder
    organizationId?: SortOrder
    blockHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditRecordSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lamport?: SortOrder
    organizationId?: SortOrder
  }

  export type EnumAuditCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditCategory | EnumAuditCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AuditCategory[] | ListEnumAuditCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditCategory[] | ListEnumAuditCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AuditCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditCategoryFilter<$PrismaModel>
    _max?: NestedEnumAuditCategoryFilter<$PrismaModel>
  }

  export type EnumAuditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditStatusFilter<$PrismaModel>
    _max?: NestedEnumAuditStatusFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BlockCountOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
    previousHash?: SortOrder
    organizationId?: SortOrder
    lamportClock?: SortOrder
    metricsData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockAvgOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    lamportClock?: SortOrder
  }

  export type BlockMaxOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
    previousHash?: SortOrder
    organizationId?: SortOrder
    lamportClock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockMinOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
    previousHash?: SortOrder
    organizationId?: SortOrder
    lamportClock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockSumOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    lamportClock?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BudgetCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    limit?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    limit?: SortOrder
  }

  export type BudgetMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    limit?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    limit?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    limit?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type RegressionBaselineUserIdModelNameModelVersionTestTypeCompoundUniqueInput = {
    userId: number
    modelName: string
    modelVersion: string
    testType: string
  }

  export type RegressionBaselineCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrder
    testType?: SortOrder
    avgResponseTime?: SortOrder
    avgCost?: SortOrder
    avgQualityScore?: SortOrder
    avgAccuracy?: SortOrder
    successRate?: SortOrder
    alertThreshold?: SortOrder
    sampleSize?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RegressionBaselineAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    avgResponseTime?: SortOrder
    avgCost?: SortOrder
    avgQualityScore?: SortOrder
    avgAccuracy?: SortOrder
    successRate?: SortOrder
    alertThreshold?: SortOrder
    sampleSize?: SortOrder
  }

  export type RegressionBaselineMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrder
    testType?: SortOrder
    avgResponseTime?: SortOrder
    avgCost?: SortOrder
    avgQualityScore?: SortOrder
    avgAccuracy?: SortOrder
    successRate?: SortOrder
    alertThreshold?: SortOrder
    sampleSize?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RegressionBaselineMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrder
    testType?: SortOrder
    avgResponseTime?: SortOrder
    avgCost?: SortOrder
    avgQualityScore?: SortOrder
    avgAccuracy?: SortOrder
    successRate?: SortOrder
    alertThreshold?: SortOrder
    sampleSize?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RegressionBaselineSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    avgResponseTime?: SortOrder
    avgCost?: SortOrder
    avgQualityScore?: SortOrder
    avgAccuracy?: SortOrder
    successRate?: SortOrder
    alertThreshold?: SortOrder
    sampleSize?: SortOrder
  }

  export type EnumFeedbackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeFilter<$PrismaModel> | $Enums.FeedbackType
  }

  export type EnumFeedbackCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackCategory | EnumFeedbackCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackCategoryFilter<$PrismaModel> | $Enums.FeedbackCategory
  }

  export type EnumFeedbackPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackPriority | EnumFeedbackPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackPriorityFilter<$PrismaModel> | $Enums.FeedbackPriority
  }

  export type EnumFeedbackStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackStatus | EnumFeedbackStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackStatusFilter<$PrismaModel> | $Enums.FeedbackStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type FeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    url?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    response?: SortOrder
    respondedAt?: SortOrder
    respondedBy?: SortOrder
    sentiment?: SortOrder
    sentimentScore?: SortOrder
    upvotes?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type FeedbackAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assignedTo?: SortOrder
    respondedBy?: SortOrder
    sentimentScore?: SortOrder
    upvotes?: SortOrder
  }

  export type FeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    url?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    response?: SortOrder
    respondedAt?: SortOrder
    respondedBy?: SortOrder
    sentiment?: SortOrder
    sentimentScore?: SortOrder
    upvotes?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type FeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    url?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    response?: SortOrder
    respondedAt?: SortOrder
    respondedBy?: SortOrder
    sentiment?: SortOrder
    sentimentScore?: SortOrder
    upvotes?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type FeedbackSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assignedTo?: SortOrder
    respondedBy?: SortOrder
    sentimentScore?: SortOrder
    upvotes?: SortOrder
  }

  export type EnumFeedbackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedbackTypeFilter<$PrismaModel>
  }

  export type EnumFeedbackCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackCategory | EnumFeedbackCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackCategoryFilter<$PrismaModel>
    _max?: NestedEnumFeedbackCategoryFilter<$PrismaModel>
  }

  export type EnumFeedbackPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackPriority | EnumFeedbackPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackPriorityWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackPriorityFilter<$PrismaModel>
    _max?: NestedEnumFeedbackPriorityFilter<$PrismaModel>
  }

  export type EnumFeedbackStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackStatus | EnumFeedbackStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackStatusWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackStatusFilter<$PrismaModel>
    _max?: NestedEnumFeedbackStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumReceiptTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReceiptType | EnumReceiptTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReceiptType[] | ListEnumReceiptTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReceiptType[] | ListEnumReceiptTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReceiptTypeFilter<$PrismaModel> | $Enums.ReceiptType
  }

  export type EnumTrackTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackType | EnumTrackTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTrackTypeNullableFilter<$PrismaModel> | $Enums.TrackType | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type TriTrackHandoffListRelationFilter = {
    every?: TriTrackHandoffWhereInput
    some?: TriTrackHandoffWhereInput
    none?: TriTrackHandoffWhereInput
  }

  export type TriTrackHandoffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BENReceiptCountOrderByAggregateInput = {
    id?: SortOrder
    receiptType?: SortOrder
    lamportClock?: SortOrder
    realTimestamp?: SortOrder
    userId?: SortOrder
    persona?: SortOrder
    track?: SortOrder
    payload?: SortOrder
    digest?: SortOrder
    previousDigest?: SortOrder
    baselineDigest?: SortOrder
    witnessModel?: SortOrder
    witnessSignature?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type BENReceiptAvgOrderByAggregateInput = {
    id?: SortOrder
    lamportClock?: SortOrder
    userId?: SortOrder
  }

  export type BENReceiptMaxOrderByAggregateInput = {
    id?: SortOrder
    receiptType?: SortOrder
    lamportClock?: SortOrder
    realTimestamp?: SortOrder
    userId?: SortOrder
    persona?: SortOrder
    track?: SortOrder
    digest?: SortOrder
    previousDigest?: SortOrder
    baselineDigest?: SortOrder
    witnessModel?: SortOrder
    witnessSignature?: SortOrder
    createdAt?: SortOrder
  }

  export type BENReceiptMinOrderByAggregateInput = {
    id?: SortOrder
    receiptType?: SortOrder
    lamportClock?: SortOrder
    realTimestamp?: SortOrder
    userId?: SortOrder
    persona?: SortOrder
    track?: SortOrder
    digest?: SortOrder
    previousDigest?: SortOrder
    baselineDigest?: SortOrder
    witnessModel?: SortOrder
    witnessSignature?: SortOrder
    createdAt?: SortOrder
  }

  export type BENReceiptSumOrderByAggregateInput = {
    id?: SortOrder
    lamportClock?: SortOrder
    userId?: SortOrder
  }

  export type EnumReceiptTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReceiptType | EnumReceiptTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReceiptType[] | ListEnumReceiptTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReceiptType[] | ListEnumReceiptTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReceiptTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReceiptType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReceiptTypeFilter<$PrismaModel>
    _max?: NestedEnumReceiptTypeFilter<$PrismaModel>
  }

  export type EnumTrackTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackType | EnumTrackTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTrackTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TrackType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTrackTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumTrackTypeNullableFilter<$PrismaModel>
  }

  export type BENSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    persona?: SortOrder
    priority?: SortOrder
    locked?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    duration?: SortOrder
    startLamport?: SortOrder
    endLamport?: SortOrder
    switchReason?: SortOrder
    metadata?: SortOrder
  }

  export type BENSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
    duration?: SortOrder
    startLamport?: SortOrder
    endLamport?: SortOrder
  }

  export type BENSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    persona?: SortOrder
    priority?: SortOrder
    locked?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    duration?: SortOrder
    startLamport?: SortOrder
    endLamport?: SortOrder
    switchReason?: SortOrder
  }

  export type BENSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    persona?: SortOrder
    priority?: SortOrder
    locked?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    duration?: SortOrder
    startLamport?: SortOrder
    endLamport?: SortOrder
    switchReason?: SortOrder
  }

  export type BENSessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
    duration?: SortOrder
    startLamport?: SortOrder
    endLamport?: SortOrder
  }

  export type EnumTrackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackType | EnumTrackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrackTypeFilter<$PrismaModel> | $Enums.TrackType
  }

  export type EnumHandoffStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HandoffStatus | EnumHandoffStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HandoffStatus[] | ListEnumHandoffStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HandoffStatus[] | ListEnumHandoffStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHandoffStatusFilter<$PrismaModel> | $Enums.HandoffStatus
  }

  export type BENReceiptScalarRelationFilter = {
    is?: BENReceiptWhereInput
    isNot?: BENReceiptWhereInput
  }

  export type BENReceiptNullableScalarRelationFilter = {
    is?: BENReceiptWhereInput | null
    isNot?: BENReceiptWhereInput | null
  }

  export type TriTrackHandoffCountOrderByAggregateInput = {
    id?: SortOrder
    fromTrack?: SortOrder
    toTrack?: SortOrder
    status?: SortOrder
    fromReceiptId?: SortOrder
    toReceiptId?: SortOrder
    initiatedAt?: SortOrder
    completedAt?: SortOrder
    latencyMs?: SortOrder
    exceededLimit?: SortOrder
    payload?: SortOrder
    result?: SortOrder
    errorMessage?: SortOrder
    metadata?: SortOrder
  }

  export type TriTrackHandoffAvgOrderByAggregateInput = {
    id?: SortOrder
    fromReceiptId?: SortOrder
    toReceiptId?: SortOrder
    latencyMs?: SortOrder
  }

  export type TriTrackHandoffMaxOrderByAggregateInput = {
    id?: SortOrder
    fromTrack?: SortOrder
    toTrack?: SortOrder
    status?: SortOrder
    fromReceiptId?: SortOrder
    toReceiptId?: SortOrder
    initiatedAt?: SortOrder
    completedAt?: SortOrder
    latencyMs?: SortOrder
    exceededLimit?: SortOrder
    errorMessage?: SortOrder
  }

  export type TriTrackHandoffMinOrderByAggregateInput = {
    id?: SortOrder
    fromTrack?: SortOrder
    toTrack?: SortOrder
    status?: SortOrder
    fromReceiptId?: SortOrder
    toReceiptId?: SortOrder
    initiatedAt?: SortOrder
    completedAt?: SortOrder
    latencyMs?: SortOrder
    exceededLimit?: SortOrder
    errorMessage?: SortOrder
  }

  export type TriTrackHandoffSumOrderByAggregateInput = {
    id?: SortOrder
    fromReceiptId?: SortOrder
    toReceiptId?: SortOrder
    latencyMs?: SortOrder
  }

  export type EnumTrackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackType | EnumTrackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrackTypeWithAggregatesFilter<$PrismaModel> | $Enums.TrackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrackTypeFilter<$PrismaModel>
    _max?: NestedEnumTrackTypeFilter<$PrismaModel>
  }

  export type EnumHandoffStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HandoffStatus | EnumHandoffStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HandoffStatus[] | ListEnumHandoffStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HandoffStatus[] | ListEnumHandoffStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHandoffStatusWithAggregatesFilter<$PrismaModel> | $Enums.HandoffStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHandoffStatusFilter<$PrismaModel>
    _max?: NestedEnumHandoffStatusFilter<$PrismaModel>
  }

  export type ZScanVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalRules?: SortOrder
    passed?: SortOrder
    warnings?: SortOrder
    critical?: SortOrder
    results?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
  }

  export type ZScanVerificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalRules?: SortOrder
    passed?: SortOrder
    warnings?: SortOrder
    critical?: SortOrder
  }

  export type ZScanVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalRules?: SortOrder
    passed?: SortOrder
    warnings?: SortOrder
    critical?: SortOrder
    createdAt?: SortOrder
  }

  export type ZScanVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalRules?: SortOrder
    passed?: SortOrder
    warnings?: SortOrder
    critical?: SortOrder
    createdAt?: SortOrder
  }

  export type ZScanVerificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalRules?: SortOrder
    passed?: SortOrder
    warnings?: SortOrder
    critical?: SortOrder
  }

  export type EnumSSOProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.SSOProvider | EnumSSOProviderFieldRefInput<$PrismaModel>
    in?: $Enums.SSOProvider[] | ListEnumSSOProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.SSOProvider[] | ListEnumSSOProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumSSOProviderFilter<$PrismaModel> | $Enums.SSOProvider
  }

  export type SSOConfigurationOrgIdProviderCompoundUniqueInput = {
    orgId: number
    provider: $Enums.SSOProvider
  }

  export type SSOConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    provider?: SortOrder
    enabled?: SortOrder
    samlEntryPoint?: SortOrder
    samlIssuer?: SortOrder
    samlCert?: SortOrder
    samlCallbackUrl?: SortOrder
    samlLogoutUrl?: SortOrder
    oauthClientId?: SortOrder
    oauthClientSecret?: SortOrder
    oauthAuthUrl?: SortOrder
    oauthTokenUrl?: SortOrder
    oauthUserInfoUrl?: SortOrder
    oauthScopes?: SortOrder
    domainRestriction?: SortOrder
    jitProvisioning?: SortOrder
    defaultRole?: SortOrder
    defaultTier?: SortOrder
    metadata?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type SSOConfigurationAvgOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    createdBy?: SortOrder
  }

  export type SSOConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    provider?: SortOrder
    enabled?: SortOrder
    samlEntryPoint?: SortOrder
    samlIssuer?: SortOrder
    samlCert?: SortOrder
    samlCallbackUrl?: SortOrder
    samlLogoutUrl?: SortOrder
    oauthClientId?: SortOrder
    oauthClientSecret?: SortOrder
    oauthAuthUrl?: SortOrder
    oauthTokenUrl?: SortOrder
    oauthUserInfoUrl?: SortOrder
    jitProvisioning?: SortOrder
    defaultRole?: SortOrder
    defaultTier?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type SSOConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    provider?: SortOrder
    enabled?: SortOrder
    samlEntryPoint?: SortOrder
    samlIssuer?: SortOrder
    samlCert?: SortOrder
    samlCallbackUrl?: SortOrder
    samlLogoutUrl?: SortOrder
    oauthClientId?: SortOrder
    oauthClientSecret?: SortOrder
    oauthAuthUrl?: SortOrder
    oauthTokenUrl?: SortOrder
    oauthUserInfoUrl?: SortOrder
    jitProvisioning?: SortOrder
    defaultRole?: SortOrder
    defaultTier?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type SSOConfigurationSumOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumSSOProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SSOProvider | EnumSSOProviderFieldRefInput<$PrismaModel>
    in?: $Enums.SSOProvider[] | ListEnumSSOProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.SSOProvider[] | ListEnumSSOProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumSSOProviderWithAggregatesFilter<$PrismaModel> | $Enums.SSOProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSSOProviderFilter<$PrismaModel>
    _max?: NestedEnumSSOProviderFilter<$PrismaModel>
  }

  export type NotificationPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    testComplete?: SortOrder
    batchComplete?: SortOrder
    scheduledTestComplete?: SortOrder
    alertsEnabled?: SortOrder
    lowScoreThreshold?: SortOrder
    highScoreThreshold?: SortOrder
    scoreDropAlert?: SortOrder
    witnessFailureAlert?: SortOrder
    dailyReport?: SortOrder
    weeklyReport?: SortOrder
    monthlyReport?: SortOrder
    reportTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lowScoreThreshold?: SortOrder
    highScoreThreshold?: SortOrder
  }

  export type NotificationPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    testComplete?: SortOrder
    batchComplete?: SortOrder
    scheduledTestComplete?: SortOrder
    alertsEnabled?: SortOrder
    lowScoreThreshold?: SortOrder
    highScoreThreshold?: SortOrder
    scoreDropAlert?: SortOrder
    witnessFailureAlert?: SortOrder
    dailyReport?: SortOrder
    weeklyReport?: SortOrder
    monthlyReport?: SortOrder
    reportTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    testComplete?: SortOrder
    batchComplete?: SortOrder
    scheduledTestComplete?: SortOrder
    alertsEnabled?: SortOrder
    lowScoreThreshold?: SortOrder
    highScoreThreshold?: SortOrder
    scoreDropAlert?: SortOrder
    witnessFailureAlert?: SortOrder
    dailyReport?: SortOrder
    weeklyReport?: SortOrder
    monthlyReport?: SortOrder
    reportTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lowScoreThreshold?: SortOrder
    highScoreThreshold?: SortOrder
  }

  export type UserCreatepermissionsInput = {
    set: $Enums.Permission[]
  }

  export type UserCreatebackupCodesInput = {
    set: string[]
  }

  export type OrganizationCreateNestedOneWithoutUsersInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AuditRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditRecordCreateWithoutUserInput, AuditRecordUncheckedCreateWithoutUserInput> | AuditRecordCreateWithoutUserInput[] | AuditRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditRecordCreateOrConnectWithoutUserInput | AuditRecordCreateOrConnectWithoutUserInput[]
    createMany?: AuditRecordCreateManyUserInputEnvelope
    connect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
  }

  export type TeamMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type NotificationPreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type BudgetCreateNestedManyWithoutUserInput = {
    create?: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput> | BudgetCreateWithoutUserInput[] | BudgetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutUserInput | BudgetCreateOrConnectWithoutUserInput[]
    createMany?: BudgetCreateManyUserInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type RegressionBaselineCreateNestedManyWithoutUserInput = {
    create?: XOR<RegressionBaselineCreateWithoutUserInput, RegressionBaselineUncheckedCreateWithoutUserInput> | RegressionBaselineCreateWithoutUserInput[] | RegressionBaselineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RegressionBaselineCreateOrConnectWithoutUserInput | RegressionBaselineCreateOrConnectWithoutUserInput[]
    createMany?: RegressionBaselineCreateManyUserInputEnvelope
    connect?: RegressionBaselineWhereUniqueInput | RegressionBaselineWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type BENReceiptCreateNestedManyWithoutUserInput = {
    create?: XOR<BENReceiptCreateWithoutUserInput, BENReceiptUncheckedCreateWithoutUserInput> | BENReceiptCreateWithoutUserInput[] | BENReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BENReceiptCreateOrConnectWithoutUserInput | BENReceiptCreateOrConnectWithoutUserInput[]
    createMany?: BENReceiptCreateManyUserInputEnvelope
    connect?: BENReceiptWhereUniqueInput | BENReceiptWhereUniqueInput[]
  }

  export type BENSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<BENSessionCreateWithoutUserInput, BENSessionUncheckedCreateWithoutUserInput> | BENSessionCreateWithoutUserInput[] | BENSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BENSessionCreateOrConnectWithoutUserInput | BENSessionCreateOrConnectWithoutUserInput[]
    createMany?: BENSessionCreateManyUserInputEnvelope
    connect?: BENSessionWhereUniqueInput | BENSessionWhereUniqueInput[]
  }

  export type ZScanVerificationCreateNestedManyWithoutUserInput = {
    create?: XOR<ZScanVerificationCreateWithoutUserInput, ZScanVerificationUncheckedCreateWithoutUserInput> | ZScanVerificationCreateWithoutUserInput[] | ZScanVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZScanVerificationCreateOrConnectWithoutUserInput | ZScanVerificationCreateOrConnectWithoutUserInput[]
    createMany?: ZScanVerificationCreateManyUserInputEnvelope
    connect?: ZScanVerificationWhereUniqueInput | ZScanVerificationWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AuditRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditRecordCreateWithoutUserInput, AuditRecordUncheckedCreateWithoutUserInput> | AuditRecordCreateWithoutUserInput[] | AuditRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditRecordCreateOrConnectWithoutUserInput | AuditRecordCreateOrConnectWithoutUserInput[]
    createMany?: AuditRecordCreateManyUserInputEnvelope
    connect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type BudgetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput> | BudgetCreateWithoutUserInput[] | BudgetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutUserInput | BudgetCreateOrConnectWithoutUserInput[]
    createMany?: BudgetCreateManyUserInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type RegressionBaselineUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RegressionBaselineCreateWithoutUserInput, RegressionBaselineUncheckedCreateWithoutUserInput> | RegressionBaselineCreateWithoutUserInput[] | RegressionBaselineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RegressionBaselineCreateOrConnectWithoutUserInput | RegressionBaselineCreateOrConnectWithoutUserInput[]
    createMany?: RegressionBaselineCreateManyUserInputEnvelope
    connect?: RegressionBaselineWhereUniqueInput | RegressionBaselineWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type BENReceiptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BENReceiptCreateWithoutUserInput, BENReceiptUncheckedCreateWithoutUserInput> | BENReceiptCreateWithoutUserInput[] | BENReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BENReceiptCreateOrConnectWithoutUserInput | BENReceiptCreateOrConnectWithoutUserInput[]
    createMany?: BENReceiptCreateManyUserInputEnvelope
    connect?: BENReceiptWhereUniqueInput | BENReceiptWhereUniqueInput[]
  }

  export type BENSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BENSessionCreateWithoutUserInput, BENSessionUncheckedCreateWithoutUserInput> | BENSessionCreateWithoutUserInput[] | BENSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BENSessionCreateOrConnectWithoutUserInput | BENSessionCreateOrConnectWithoutUserInput[]
    createMany?: BENSessionCreateManyUserInputEnvelope
    connect?: BENSessionWhereUniqueInput | BENSessionWhereUniqueInput[]
  }

  export type ZScanVerificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ZScanVerificationCreateWithoutUserInput, ZScanVerificationUncheckedCreateWithoutUserInput> | ZScanVerificationCreateWithoutUserInput[] | ZScanVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZScanVerificationCreateOrConnectWithoutUserInput | ZScanVerificationCreateOrConnectWithoutUserInput[]
    createMany?: ZScanVerificationCreateManyUserInputEnvelope
    connect?: ZScanVerificationWhereUniqueInput | ZScanVerificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type EnumUserTierFieldUpdateOperationsInput = {
    set?: $Enums.UserTier
  }

  export type UserUpdatepermissionsInput = {
    set?: $Enums.Permission[]
    push?: $Enums.Permission | $Enums.Permission[]
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdatebackupCodesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumBENPersonaFieldUpdateOperationsInput = {
    set?: $Enums.BENPersona
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrganizationUpdateOneWithoutUsersNestedInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    upsert?: OrganizationUpsertWithoutUsersInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUsersInput, OrganizationUpdateWithoutUsersInput>, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AuditRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditRecordCreateWithoutUserInput, AuditRecordUncheckedCreateWithoutUserInput> | AuditRecordCreateWithoutUserInput[] | AuditRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditRecordCreateOrConnectWithoutUserInput | AuditRecordCreateOrConnectWithoutUserInput[]
    upsert?: AuditRecordUpsertWithWhereUniqueWithoutUserInput | AuditRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditRecordCreateManyUserInputEnvelope
    set?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    disconnect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    delete?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    connect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    update?: AuditRecordUpdateWithWhereUniqueWithoutUserInput | AuditRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditRecordUpdateManyWithWhereWithoutUserInput | AuditRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditRecordScalarWhereInput | AuditRecordScalarWhereInput[]
  }

  export type TeamMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type NotificationPreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type BudgetUpdateManyWithoutUserNestedInput = {
    create?: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput> | BudgetCreateWithoutUserInput[] | BudgetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutUserInput | BudgetCreateOrConnectWithoutUserInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutUserInput | BudgetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BudgetCreateManyUserInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutUserInput | BudgetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutUserInput | BudgetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type RegressionBaselineUpdateManyWithoutUserNestedInput = {
    create?: XOR<RegressionBaselineCreateWithoutUserInput, RegressionBaselineUncheckedCreateWithoutUserInput> | RegressionBaselineCreateWithoutUserInput[] | RegressionBaselineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RegressionBaselineCreateOrConnectWithoutUserInput | RegressionBaselineCreateOrConnectWithoutUserInput[]
    upsert?: RegressionBaselineUpsertWithWhereUniqueWithoutUserInput | RegressionBaselineUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RegressionBaselineCreateManyUserInputEnvelope
    set?: RegressionBaselineWhereUniqueInput | RegressionBaselineWhereUniqueInput[]
    disconnect?: RegressionBaselineWhereUniqueInput | RegressionBaselineWhereUniqueInput[]
    delete?: RegressionBaselineWhereUniqueInput | RegressionBaselineWhereUniqueInput[]
    connect?: RegressionBaselineWhereUniqueInput | RegressionBaselineWhereUniqueInput[]
    update?: RegressionBaselineUpdateWithWhereUniqueWithoutUserInput | RegressionBaselineUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RegressionBaselineUpdateManyWithWhereWithoutUserInput | RegressionBaselineUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RegressionBaselineScalarWhereInput | RegressionBaselineScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutUserInput | FeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutUserInput | FeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutUserInput | FeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type BENReceiptUpdateManyWithoutUserNestedInput = {
    create?: XOR<BENReceiptCreateWithoutUserInput, BENReceiptUncheckedCreateWithoutUserInput> | BENReceiptCreateWithoutUserInput[] | BENReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BENReceiptCreateOrConnectWithoutUserInput | BENReceiptCreateOrConnectWithoutUserInput[]
    upsert?: BENReceiptUpsertWithWhereUniqueWithoutUserInput | BENReceiptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BENReceiptCreateManyUserInputEnvelope
    set?: BENReceiptWhereUniqueInput | BENReceiptWhereUniqueInput[]
    disconnect?: BENReceiptWhereUniqueInput | BENReceiptWhereUniqueInput[]
    delete?: BENReceiptWhereUniqueInput | BENReceiptWhereUniqueInput[]
    connect?: BENReceiptWhereUniqueInput | BENReceiptWhereUniqueInput[]
    update?: BENReceiptUpdateWithWhereUniqueWithoutUserInput | BENReceiptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BENReceiptUpdateManyWithWhereWithoutUserInput | BENReceiptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BENReceiptScalarWhereInput | BENReceiptScalarWhereInput[]
  }

  export type BENSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<BENSessionCreateWithoutUserInput, BENSessionUncheckedCreateWithoutUserInput> | BENSessionCreateWithoutUserInput[] | BENSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BENSessionCreateOrConnectWithoutUserInput | BENSessionCreateOrConnectWithoutUserInput[]
    upsert?: BENSessionUpsertWithWhereUniqueWithoutUserInput | BENSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BENSessionCreateManyUserInputEnvelope
    set?: BENSessionWhereUniqueInput | BENSessionWhereUniqueInput[]
    disconnect?: BENSessionWhereUniqueInput | BENSessionWhereUniqueInput[]
    delete?: BENSessionWhereUniqueInput | BENSessionWhereUniqueInput[]
    connect?: BENSessionWhereUniqueInput | BENSessionWhereUniqueInput[]
    update?: BENSessionUpdateWithWhereUniqueWithoutUserInput | BENSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BENSessionUpdateManyWithWhereWithoutUserInput | BENSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BENSessionScalarWhereInput | BENSessionScalarWhereInput[]
  }

  export type ZScanVerificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ZScanVerificationCreateWithoutUserInput, ZScanVerificationUncheckedCreateWithoutUserInput> | ZScanVerificationCreateWithoutUserInput[] | ZScanVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZScanVerificationCreateOrConnectWithoutUserInput | ZScanVerificationCreateOrConnectWithoutUserInput[]
    upsert?: ZScanVerificationUpsertWithWhereUniqueWithoutUserInput | ZScanVerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ZScanVerificationCreateManyUserInputEnvelope
    set?: ZScanVerificationWhereUniqueInput | ZScanVerificationWhereUniqueInput[]
    disconnect?: ZScanVerificationWhereUniqueInput | ZScanVerificationWhereUniqueInput[]
    delete?: ZScanVerificationWhereUniqueInput | ZScanVerificationWhereUniqueInput[]
    connect?: ZScanVerificationWhereUniqueInput | ZScanVerificationWhereUniqueInput[]
    update?: ZScanVerificationUpdateWithWhereUniqueWithoutUserInput | ZScanVerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ZScanVerificationUpdateManyWithWhereWithoutUserInput | ZScanVerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ZScanVerificationScalarWhereInput | ZScanVerificationScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AuditRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditRecordCreateWithoutUserInput, AuditRecordUncheckedCreateWithoutUserInput> | AuditRecordCreateWithoutUserInput[] | AuditRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditRecordCreateOrConnectWithoutUserInput | AuditRecordCreateOrConnectWithoutUserInput[]
    upsert?: AuditRecordUpsertWithWhereUniqueWithoutUserInput | AuditRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditRecordCreateManyUserInputEnvelope
    set?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    disconnect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    delete?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    connect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    update?: AuditRecordUpdateWithWhereUniqueWithoutUserInput | AuditRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditRecordUpdateManyWithWhereWithoutUserInput | AuditRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditRecordScalarWhereInput | AuditRecordScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type BudgetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput> | BudgetCreateWithoutUserInput[] | BudgetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutUserInput | BudgetCreateOrConnectWithoutUserInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutUserInput | BudgetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BudgetCreateManyUserInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutUserInput | BudgetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutUserInput | BudgetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RegressionBaselineCreateWithoutUserInput, RegressionBaselineUncheckedCreateWithoutUserInput> | RegressionBaselineCreateWithoutUserInput[] | RegressionBaselineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RegressionBaselineCreateOrConnectWithoutUserInput | RegressionBaselineCreateOrConnectWithoutUserInput[]
    upsert?: RegressionBaselineUpsertWithWhereUniqueWithoutUserInput | RegressionBaselineUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RegressionBaselineCreateManyUserInputEnvelope
    set?: RegressionBaselineWhereUniqueInput | RegressionBaselineWhereUniqueInput[]
    disconnect?: RegressionBaselineWhereUniqueInput | RegressionBaselineWhereUniqueInput[]
    delete?: RegressionBaselineWhereUniqueInput | RegressionBaselineWhereUniqueInput[]
    connect?: RegressionBaselineWhereUniqueInput | RegressionBaselineWhereUniqueInput[]
    update?: RegressionBaselineUpdateWithWhereUniqueWithoutUserInput | RegressionBaselineUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RegressionBaselineUpdateManyWithWhereWithoutUserInput | RegressionBaselineUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RegressionBaselineScalarWhereInput | RegressionBaselineScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutUserInput | FeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutUserInput | FeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutUserInput | FeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type BENReceiptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BENReceiptCreateWithoutUserInput, BENReceiptUncheckedCreateWithoutUserInput> | BENReceiptCreateWithoutUserInput[] | BENReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BENReceiptCreateOrConnectWithoutUserInput | BENReceiptCreateOrConnectWithoutUserInput[]
    upsert?: BENReceiptUpsertWithWhereUniqueWithoutUserInput | BENReceiptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BENReceiptCreateManyUserInputEnvelope
    set?: BENReceiptWhereUniqueInput | BENReceiptWhereUniqueInput[]
    disconnect?: BENReceiptWhereUniqueInput | BENReceiptWhereUniqueInput[]
    delete?: BENReceiptWhereUniqueInput | BENReceiptWhereUniqueInput[]
    connect?: BENReceiptWhereUniqueInput | BENReceiptWhereUniqueInput[]
    update?: BENReceiptUpdateWithWhereUniqueWithoutUserInput | BENReceiptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BENReceiptUpdateManyWithWhereWithoutUserInput | BENReceiptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BENReceiptScalarWhereInput | BENReceiptScalarWhereInput[]
  }

  export type BENSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BENSessionCreateWithoutUserInput, BENSessionUncheckedCreateWithoutUserInput> | BENSessionCreateWithoutUserInput[] | BENSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BENSessionCreateOrConnectWithoutUserInput | BENSessionCreateOrConnectWithoutUserInput[]
    upsert?: BENSessionUpsertWithWhereUniqueWithoutUserInput | BENSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BENSessionCreateManyUserInputEnvelope
    set?: BENSessionWhereUniqueInput | BENSessionWhereUniqueInput[]
    disconnect?: BENSessionWhereUniqueInput | BENSessionWhereUniqueInput[]
    delete?: BENSessionWhereUniqueInput | BENSessionWhereUniqueInput[]
    connect?: BENSessionWhereUniqueInput | BENSessionWhereUniqueInput[]
    update?: BENSessionUpdateWithWhereUniqueWithoutUserInput | BENSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BENSessionUpdateManyWithWhereWithoutUserInput | BENSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BENSessionScalarWhereInput | BENSessionScalarWhereInput[]
  }

  export type ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ZScanVerificationCreateWithoutUserInput, ZScanVerificationUncheckedCreateWithoutUserInput> | ZScanVerificationCreateWithoutUserInput[] | ZScanVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZScanVerificationCreateOrConnectWithoutUserInput | ZScanVerificationCreateOrConnectWithoutUserInput[]
    upsert?: ZScanVerificationUpsertWithWhereUniqueWithoutUserInput | ZScanVerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ZScanVerificationCreateManyUserInputEnvelope
    set?: ZScanVerificationWhereUniqueInput | ZScanVerificationWhereUniqueInput[]
    disconnect?: ZScanVerificationWhereUniqueInput | ZScanVerificationWhereUniqueInput[]
    delete?: ZScanVerificationWhereUniqueInput | ZScanVerificationWhereUniqueInput[]
    connect?: ZScanVerificationWhereUniqueInput | ZScanVerificationWhereUniqueInput[]
    update?: ZScanVerificationUpdateWithWhereUniqueWithoutUserInput | ZScanVerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ZScanVerificationUpdateManyWithWhereWithoutUserInput | ZScanVerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ZScanVerificationScalarWhereInput | ZScanVerificationScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TeamCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<TeamCreateWithoutOrganizationInput, TeamUncheckedCreateWithoutOrganizationInput> | TeamCreateWithoutOrganizationInput[] | TeamUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOrganizationInput | TeamCreateOrConnectWithoutOrganizationInput[]
    createMany?: TeamCreateManyOrganizationInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type SSOConfigurationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SSOConfigurationCreateWithoutOrganizationInput, SSOConfigurationUncheckedCreateWithoutOrganizationInput> | SSOConfigurationCreateWithoutOrganizationInput[] | SSOConfigurationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SSOConfigurationCreateOrConnectWithoutOrganizationInput | SSOConfigurationCreateOrConnectWithoutOrganizationInput[]
    createMany?: SSOConfigurationCreateManyOrganizationInputEnvelope
    connect?: SSOConfigurationWhereUniqueInput | SSOConfigurationWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<TeamCreateWithoutOrganizationInput, TeamUncheckedCreateWithoutOrganizationInput> | TeamCreateWithoutOrganizationInput[] | TeamUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOrganizationInput | TeamCreateOrConnectWithoutOrganizationInput[]
    createMany?: TeamCreateManyOrganizationInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type SSOConfigurationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SSOConfigurationCreateWithoutOrganizationInput, SSOConfigurationUncheckedCreateWithoutOrganizationInput> | SSOConfigurationCreateWithoutOrganizationInput[] | SSOConfigurationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SSOConfigurationCreateOrConnectWithoutOrganizationInput | SSOConfigurationCreateOrConnectWithoutOrganizationInput[]
    createMany?: SSOConfigurationCreateManyOrganizationInputEnvelope
    connect?: SSOConfigurationWhereUniqueInput | SSOConfigurationWhereUniqueInput[]
  }

  export type EnumPlanTypeFieldUpdateOperationsInput = {
    set?: $Enums.PlanType
  }

  export type EnumOrgStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrgStatus
  }

  export type UserUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TeamUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<TeamCreateWithoutOrganizationInput, TeamUncheckedCreateWithoutOrganizationInput> | TeamCreateWithoutOrganizationInput[] | TeamUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOrganizationInput | TeamCreateOrConnectWithoutOrganizationInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutOrganizationInput | TeamUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: TeamCreateManyOrganizationInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutOrganizationInput | TeamUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutOrganizationInput | TeamUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type SSOConfigurationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SSOConfigurationCreateWithoutOrganizationInput, SSOConfigurationUncheckedCreateWithoutOrganizationInput> | SSOConfigurationCreateWithoutOrganizationInput[] | SSOConfigurationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SSOConfigurationCreateOrConnectWithoutOrganizationInput | SSOConfigurationCreateOrConnectWithoutOrganizationInput[]
    upsert?: SSOConfigurationUpsertWithWhereUniqueWithoutOrganizationInput | SSOConfigurationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SSOConfigurationCreateManyOrganizationInputEnvelope
    set?: SSOConfigurationWhereUniqueInput | SSOConfigurationWhereUniqueInput[]
    disconnect?: SSOConfigurationWhereUniqueInput | SSOConfigurationWhereUniqueInput[]
    delete?: SSOConfigurationWhereUniqueInput | SSOConfigurationWhereUniqueInput[]
    connect?: SSOConfigurationWhereUniqueInput | SSOConfigurationWhereUniqueInput[]
    update?: SSOConfigurationUpdateWithWhereUniqueWithoutOrganizationInput | SSOConfigurationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SSOConfigurationUpdateManyWithWhereWithoutOrganizationInput | SSOConfigurationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SSOConfigurationScalarWhereInput | SSOConfigurationScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<TeamCreateWithoutOrganizationInput, TeamUncheckedCreateWithoutOrganizationInput> | TeamCreateWithoutOrganizationInput[] | TeamUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOrganizationInput | TeamCreateOrConnectWithoutOrganizationInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutOrganizationInput | TeamUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: TeamCreateManyOrganizationInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutOrganizationInput | TeamUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutOrganizationInput | TeamUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type SSOConfigurationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SSOConfigurationCreateWithoutOrganizationInput, SSOConfigurationUncheckedCreateWithoutOrganizationInput> | SSOConfigurationCreateWithoutOrganizationInput[] | SSOConfigurationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SSOConfigurationCreateOrConnectWithoutOrganizationInput | SSOConfigurationCreateOrConnectWithoutOrganizationInput[]
    upsert?: SSOConfigurationUpsertWithWhereUniqueWithoutOrganizationInput | SSOConfigurationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SSOConfigurationCreateManyOrganizationInputEnvelope
    set?: SSOConfigurationWhereUniqueInput | SSOConfigurationWhereUniqueInput[]
    disconnect?: SSOConfigurationWhereUniqueInput | SSOConfigurationWhereUniqueInput[]
    delete?: SSOConfigurationWhereUniqueInput | SSOConfigurationWhereUniqueInput[]
    connect?: SSOConfigurationWhereUniqueInput | SSOConfigurationWhereUniqueInput[]
    update?: SSOConfigurationUpdateWithWhereUniqueWithoutOrganizationInput | SSOConfigurationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SSOConfigurationUpdateManyWithWhereWithoutOrganizationInput | SSOConfigurationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SSOConfigurationScalarWhereInput | SSOConfigurationScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutTeamsInput = {
    create?: XOR<OrganizationCreateWithoutTeamsInput, OrganizationUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTeamsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type TeamMemberCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<OrganizationCreateWithoutTeamsInput, OrganizationUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTeamsInput
    upsert?: OrganizationUpsertWithoutTeamsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutTeamsInput, OrganizationUpdateWithoutTeamsInput>, OrganizationUncheckedUpdateWithoutTeamsInput>
  }

  export type TeamMemberUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutMembersInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeamsInput = {
    create?: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTeamRoleFieldUpdateOperationsInput = {
    set?: $Enums.TeamRole
  }

  export type TeamUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    upsert?: TeamUpsertWithoutMembersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMembersInput, TeamUpdateWithoutMembersInput>, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsInput
    upsert?: UserUpsertWithoutTeamsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamsInput, UserUpdateWithoutTeamsInput>, UserUncheckedUpdateWithoutTeamsInput>
  }

  export type UserCreateNestedOneWithoutAuditsInput = {
    create?: XOR<UserCreateWithoutAuditsInput, UserUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuditCategoryFieldUpdateOperationsInput = {
    set?: $Enums.AuditCategory
  }

  export type EnumAuditStatusFieldUpdateOperationsInput = {
    set?: $Enums.AuditStatus
  }

  export type UserUpdateOneRequiredWithoutAuditsNestedInput = {
    create?: XOR<UserCreateWithoutAuditsInput, UserUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditsInput
    upsert?: UserUpsertWithoutAuditsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditsInput, UserUpdateWithoutAuditsInput>, UserUncheckedUpdateWithoutAuditsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutBudgetsInput = {
    create?: XOR<UserCreateWithoutBudgetsInput, UserUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBudgetsInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutBudgetsNestedInput = {
    create?: XOR<UserCreateWithoutBudgetsInput, UserUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBudgetsInput
    upsert?: UserUpsertWithoutBudgetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBudgetsInput, UserUpdateWithoutBudgetsInput>, UserUncheckedUpdateWithoutBudgetsInput>
  }

  export type UserCreateNestedOneWithoutRegressionBaselinesInput = {
    create?: XOR<UserCreateWithoutRegressionBaselinesInput, UserUncheckedCreateWithoutRegressionBaselinesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRegressionBaselinesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRegressionBaselinesNestedInput = {
    create?: XOR<UserCreateWithoutRegressionBaselinesInput, UserUncheckedCreateWithoutRegressionBaselinesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRegressionBaselinesInput
    upsert?: UserUpsertWithoutRegressionBaselinesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRegressionBaselinesInput, UserUpdateWithoutRegressionBaselinesInput>, UserUncheckedUpdateWithoutRegressionBaselinesInput>
  }

  export type UserCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbacksInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFeedbackTypeFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackType
  }

  export type EnumFeedbackCategoryFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackCategory
  }

  export type EnumFeedbackPriorityFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackPriority
  }

  export type EnumFeedbackStatusFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbacksInput
    upsert?: UserUpsertWithoutFeedbacksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedbacksInput, UserUpdateWithoutFeedbacksInput>, UserUncheckedUpdateWithoutFeedbacksInput>
  }

  export type UserCreateNestedOneWithoutBenReceiptsInput = {
    create?: XOR<UserCreateWithoutBenReceiptsInput, UserUncheckedCreateWithoutBenReceiptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBenReceiptsInput
    connect?: UserWhereUniqueInput
  }

  export type TriTrackHandoffCreateNestedManyWithoutFromReceiptInput = {
    create?: XOR<TriTrackHandoffCreateWithoutFromReceiptInput, TriTrackHandoffUncheckedCreateWithoutFromReceiptInput> | TriTrackHandoffCreateWithoutFromReceiptInput[] | TriTrackHandoffUncheckedCreateWithoutFromReceiptInput[]
    connectOrCreate?: TriTrackHandoffCreateOrConnectWithoutFromReceiptInput | TriTrackHandoffCreateOrConnectWithoutFromReceiptInput[]
    createMany?: TriTrackHandoffCreateManyFromReceiptInputEnvelope
    connect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
  }

  export type TriTrackHandoffCreateNestedManyWithoutToReceiptInput = {
    create?: XOR<TriTrackHandoffCreateWithoutToReceiptInput, TriTrackHandoffUncheckedCreateWithoutToReceiptInput> | TriTrackHandoffCreateWithoutToReceiptInput[] | TriTrackHandoffUncheckedCreateWithoutToReceiptInput[]
    connectOrCreate?: TriTrackHandoffCreateOrConnectWithoutToReceiptInput | TriTrackHandoffCreateOrConnectWithoutToReceiptInput[]
    createMany?: TriTrackHandoffCreateManyToReceiptInputEnvelope
    connect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
  }

  export type TriTrackHandoffUncheckedCreateNestedManyWithoutFromReceiptInput = {
    create?: XOR<TriTrackHandoffCreateWithoutFromReceiptInput, TriTrackHandoffUncheckedCreateWithoutFromReceiptInput> | TriTrackHandoffCreateWithoutFromReceiptInput[] | TriTrackHandoffUncheckedCreateWithoutFromReceiptInput[]
    connectOrCreate?: TriTrackHandoffCreateOrConnectWithoutFromReceiptInput | TriTrackHandoffCreateOrConnectWithoutFromReceiptInput[]
    createMany?: TriTrackHandoffCreateManyFromReceiptInputEnvelope
    connect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
  }

  export type TriTrackHandoffUncheckedCreateNestedManyWithoutToReceiptInput = {
    create?: XOR<TriTrackHandoffCreateWithoutToReceiptInput, TriTrackHandoffUncheckedCreateWithoutToReceiptInput> | TriTrackHandoffCreateWithoutToReceiptInput[] | TriTrackHandoffUncheckedCreateWithoutToReceiptInput[]
    connectOrCreate?: TriTrackHandoffCreateOrConnectWithoutToReceiptInput | TriTrackHandoffCreateOrConnectWithoutToReceiptInput[]
    createMany?: TriTrackHandoffCreateManyToReceiptInputEnvelope
    connect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
  }

  export type EnumReceiptTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReceiptType
  }

  export type NullableEnumTrackTypeFieldUpdateOperationsInput = {
    set?: $Enums.TrackType | null
  }

  export type UserUpdateOneWithoutBenReceiptsNestedInput = {
    create?: XOR<UserCreateWithoutBenReceiptsInput, UserUncheckedCreateWithoutBenReceiptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBenReceiptsInput
    upsert?: UserUpsertWithoutBenReceiptsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBenReceiptsInput, UserUpdateWithoutBenReceiptsInput>, UserUncheckedUpdateWithoutBenReceiptsInput>
  }

  export type TriTrackHandoffUpdateManyWithoutFromReceiptNestedInput = {
    create?: XOR<TriTrackHandoffCreateWithoutFromReceiptInput, TriTrackHandoffUncheckedCreateWithoutFromReceiptInput> | TriTrackHandoffCreateWithoutFromReceiptInput[] | TriTrackHandoffUncheckedCreateWithoutFromReceiptInput[]
    connectOrCreate?: TriTrackHandoffCreateOrConnectWithoutFromReceiptInput | TriTrackHandoffCreateOrConnectWithoutFromReceiptInput[]
    upsert?: TriTrackHandoffUpsertWithWhereUniqueWithoutFromReceiptInput | TriTrackHandoffUpsertWithWhereUniqueWithoutFromReceiptInput[]
    createMany?: TriTrackHandoffCreateManyFromReceiptInputEnvelope
    set?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    disconnect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    delete?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    connect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    update?: TriTrackHandoffUpdateWithWhereUniqueWithoutFromReceiptInput | TriTrackHandoffUpdateWithWhereUniqueWithoutFromReceiptInput[]
    updateMany?: TriTrackHandoffUpdateManyWithWhereWithoutFromReceiptInput | TriTrackHandoffUpdateManyWithWhereWithoutFromReceiptInput[]
    deleteMany?: TriTrackHandoffScalarWhereInput | TriTrackHandoffScalarWhereInput[]
  }

  export type TriTrackHandoffUpdateManyWithoutToReceiptNestedInput = {
    create?: XOR<TriTrackHandoffCreateWithoutToReceiptInput, TriTrackHandoffUncheckedCreateWithoutToReceiptInput> | TriTrackHandoffCreateWithoutToReceiptInput[] | TriTrackHandoffUncheckedCreateWithoutToReceiptInput[]
    connectOrCreate?: TriTrackHandoffCreateOrConnectWithoutToReceiptInput | TriTrackHandoffCreateOrConnectWithoutToReceiptInput[]
    upsert?: TriTrackHandoffUpsertWithWhereUniqueWithoutToReceiptInput | TriTrackHandoffUpsertWithWhereUniqueWithoutToReceiptInput[]
    createMany?: TriTrackHandoffCreateManyToReceiptInputEnvelope
    set?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    disconnect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    delete?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    connect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    update?: TriTrackHandoffUpdateWithWhereUniqueWithoutToReceiptInput | TriTrackHandoffUpdateWithWhereUniqueWithoutToReceiptInput[]
    updateMany?: TriTrackHandoffUpdateManyWithWhereWithoutToReceiptInput | TriTrackHandoffUpdateManyWithWhereWithoutToReceiptInput[]
    deleteMany?: TriTrackHandoffScalarWhereInput | TriTrackHandoffScalarWhereInput[]
  }

  export type TriTrackHandoffUncheckedUpdateManyWithoutFromReceiptNestedInput = {
    create?: XOR<TriTrackHandoffCreateWithoutFromReceiptInput, TriTrackHandoffUncheckedCreateWithoutFromReceiptInput> | TriTrackHandoffCreateWithoutFromReceiptInput[] | TriTrackHandoffUncheckedCreateWithoutFromReceiptInput[]
    connectOrCreate?: TriTrackHandoffCreateOrConnectWithoutFromReceiptInput | TriTrackHandoffCreateOrConnectWithoutFromReceiptInput[]
    upsert?: TriTrackHandoffUpsertWithWhereUniqueWithoutFromReceiptInput | TriTrackHandoffUpsertWithWhereUniqueWithoutFromReceiptInput[]
    createMany?: TriTrackHandoffCreateManyFromReceiptInputEnvelope
    set?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    disconnect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    delete?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    connect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    update?: TriTrackHandoffUpdateWithWhereUniqueWithoutFromReceiptInput | TriTrackHandoffUpdateWithWhereUniqueWithoutFromReceiptInput[]
    updateMany?: TriTrackHandoffUpdateManyWithWhereWithoutFromReceiptInput | TriTrackHandoffUpdateManyWithWhereWithoutFromReceiptInput[]
    deleteMany?: TriTrackHandoffScalarWhereInput | TriTrackHandoffScalarWhereInput[]
  }

  export type TriTrackHandoffUncheckedUpdateManyWithoutToReceiptNestedInput = {
    create?: XOR<TriTrackHandoffCreateWithoutToReceiptInput, TriTrackHandoffUncheckedCreateWithoutToReceiptInput> | TriTrackHandoffCreateWithoutToReceiptInput[] | TriTrackHandoffUncheckedCreateWithoutToReceiptInput[]
    connectOrCreate?: TriTrackHandoffCreateOrConnectWithoutToReceiptInput | TriTrackHandoffCreateOrConnectWithoutToReceiptInput[]
    upsert?: TriTrackHandoffUpsertWithWhereUniqueWithoutToReceiptInput | TriTrackHandoffUpsertWithWhereUniqueWithoutToReceiptInput[]
    createMany?: TriTrackHandoffCreateManyToReceiptInputEnvelope
    set?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    disconnect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    delete?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    connect?: TriTrackHandoffWhereUniqueInput | TriTrackHandoffWhereUniqueInput[]
    update?: TriTrackHandoffUpdateWithWhereUniqueWithoutToReceiptInput | TriTrackHandoffUpdateWithWhereUniqueWithoutToReceiptInput[]
    updateMany?: TriTrackHandoffUpdateManyWithWhereWithoutToReceiptInput | TriTrackHandoffUpdateManyWithWhereWithoutToReceiptInput[]
    deleteMany?: TriTrackHandoffScalarWhereInput | TriTrackHandoffScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBenSessionsInput = {
    create?: XOR<UserCreateWithoutBenSessionsInput, UserUncheckedCreateWithoutBenSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBenSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBenSessionsNestedInput = {
    create?: XOR<UserCreateWithoutBenSessionsInput, UserUncheckedCreateWithoutBenSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBenSessionsInput
    upsert?: UserUpsertWithoutBenSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBenSessionsInput, UserUpdateWithoutBenSessionsInput>, UserUncheckedUpdateWithoutBenSessionsInput>
  }

  export type BENReceiptCreateNestedOneWithoutHandoffsFromInput = {
    create?: XOR<BENReceiptCreateWithoutHandoffsFromInput, BENReceiptUncheckedCreateWithoutHandoffsFromInput>
    connectOrCreate?: BENReceiptCreateOrConnectWithoutHandoffsFromInput
    connect?: BENReceiptWhereUniqueInput
  }

  export type BENReceiptCreateNestedOneWithoutHandoffsToInput = {
    create?: XOR<BENReceiptCreateWithoutHandoffsToInput, BENReceiptUncheckedCreateWithoutHandoffsToInput>
    connectOrCreate?: BENReceiptCreateOrConnectWithoutHandoffsToInput
    connect?: BENReceiptWhereUniqueInput
  }

  export type EnumTrackTypeFieldUpdateOperationsInput = {
    set?: $Enums.TrackType
  }

  export type EnumHandoffStatusFieldUpdateOperationsInput = {
    set?: $Enums.HandoffStatus
  }

  export type BENReceiptUpdateOneRequiredWithoutHandoffsFromNestedInput = {
    create?: XOR<BENReceiptCreateWithoutHandoffsFromInput, BENReceiptUncheckedCreateWithoutHandoffsFromInput>
    connectOrCreate?: BENReceiptCreateOrConnectWithoutHandoffsFromInput
    upsert?: BENReceiptUpsertWithoutHandoffsFromInput
    connect?: BENReceiptWhereUniqueInput
    update?: XOR<XOR<BENReceiptUpdateToOneWithWhereWithoutHandoffsFromInput, BENReceiptUpdateWithoutHandoffsFromInput>, BENReceiptUncheckedUpdateWithoutHandoffsFromInput>
  }

  export type BENReceiptUpdateOneWithoutHandoffsToNestedInput = {
    create?: XOR<BENReceiptCreateWithoutHandoffsToInput, BENReceiptUncheckedCreateWithoutHandoffsToInput>
    connectOrCreate?: BENReceiptCreateOrConnectWithoutHandoffsToInput
    upsert?: BENReceiptUpsertWithoutHandoffsToInput
    disconnect?: BENReceiptWhereInput | boolean
    delete?: BENReceiptWhereInput | boolean
    connect?: BENReceiptWhereUniqueInput
    update?: XOR<XOR<BENReceiptUpdateToOneWithWhereWithoutHandoffsToInput, BENReceiptUpdateWithoutHandoffsToInput>, BENReceiptUncheckedUpdateWithoutHandoffsToInput>
  }

  export type UserCreateNestedOneWithoutZscansInput = {
    create?: XOR<UserCreateWithoutZscansInput, UserUncheckedCreateWithoutZscansInput>
    connectOrCreate?: UserCreateOrConnectWithoutZscansInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutZscansNestedInput = {
    create?: XOR<UserCreateWithoutZscansInput, UserUncheckedCreateWithoutZscansInput>
    connectOrCreate?: UserCreateOrConnectWithoutZscansInput
    upsert?: UserUpsertWithoutZscansInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutZscansInput, UserUpdateWithoutZscansInput>, UserUncheckedUpdateWithoutZscansInput>
  }

  export type SSOConfigurationCreateoauthScopesInput = {
    set: string[]
  }

  export type SSOConfigurationCreatedomainRestrictionInput = {
    set: string[]
  }

  export type OrganizationCreateNestedOneWithoutSsoConfigsInput = {
    create?: XOR<OrganizationCreateWithoutSsoConfigsInput, OrganizationUncheckedCreateWithoutSsoConfigsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSsoConfigsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type EnumSSOProviderFieldUpdateOperationsInput = {
    set?: $Enums.SSOProvider
  }

  export type SSOConfigurationUpdateoauthScopesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SSOConfigurationUpdatedomainRestrictionInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OrganizationUpdateOneRequiredWithoutSsoConfigsNestedInput = {
    create?: XOR<OrganizationCreateWithoutSsoConfigsInput, OrganizationUncheckedCreateWithoutSsoConfigsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSsoConfigsInput
    upsert?: OrganizationUpsertWithoutSsoConfigsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutSsoConfigsInput, OrganizationUpdateWithoutSsoConfigsInput>, OrganizationUncheckedUpdateWithoutSsoConfigsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumUserTierFilter<$PrismaModel = never> = {
    equals?: $Enums.UserTier | EnumUserTierFieldRefInput<$PrismaModel>
    in?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTierFilter<$PrismaModel> | $Enums.UserTier
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumBENPersonaFilter<$PrismaModel = never> = {
    equals?: $Enums.BENPersona | EnumBENPersonaFieldRefInput<$PrismaModel>
    in?: $Enums.BENPersona[] | ListEnumBENPersonaFieldRefInput<$PrismaModel>
    notIn?: $Enums.BENPersona[] | ListEnumBENPersonaFieldRefInput<$PrismaModel>
    not?: NestedEnumBENPersonaFilter<$PrismaModel> | $Enums.BENPersona
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserTier | EnumUserTierFieldRefInput<$PrismaModel>
    in?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTierWithAggregatesFilter<$PrismaModel> | $Enums.UserTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTierFilter<$PrismaModel>
    _max?: NestedEnumUserTierFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumBENPersonaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BENPersona | EnumBENPersonaFieldRefInput<$PrismaModel>
    in?: $Enums.BENPersona[] | ListEnumBENPersonaFieldRefInput<$PrismaModel>
    notIn?: $Enums.BENPersona[] | ListEnumBENPersonaFieldRefInput<$PrismaModel>
    not?: NestedEnumBENPersonaWithAggregatesFilter<$PrismaModel> | $Enums.BENPersona
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBENPersonaFilter<$PrismaModel>
    _max?: NestedEnumBENPersonaFilter<$PrismaModel>
  }

  export type NestedEnumPlanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeFilter<$PrismaModel> | $Enums.PlanType
  }

  export type NestedEnumOrgStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgStatus | EnumOrgStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrgStatus[] | ListEnumOrgStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgStatus[] | ListEnumOrgStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgStatusFilter<$PrismaModel> | $Enums.OrgStatus
  }

  export type NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTypeFilter<$PrismaModel>
    _max?: NestedEnumPlanTypeFilter<$PrismaModel>
  }

  export type NestedEnumOrgStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgStatus | EnumOrgStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrgStatus[] | ListEnumOrgStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgStatus[] | ListEnumOrgStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrgStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrgStatusFilter<$PrismaModel>
    _max?: NestedEnumOrgStatusFilter<$PrismaModel>
  }

  export type NestedEnumTeamRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleFilter<$PrismaModel> | $Enums.TeamRole
  }

  export type NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel> | $Enums.TeamRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamRoleFilter<$PrismaModel>
    _max?: NestedEnumTeamRoleFilter<$PrismaModel>
  }

  export type NestedEnumAuditCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditCategory | EnumAuditCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AuditCategory[] | ListEnumAuditCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditCategory[] | ListEnumAuditCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditCategoryFilter<$PrismaModel> | $Enums.AuditCategory
  }

  export type NestedEnumAuditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusFilter<$PrismaModel> | $Enums.AuditStatus
  }

  export type NestedEnumAuditCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditCategory | EnumAuditCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AuditCategory[] | ListEnumAuditCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditCategory[] | ListEnumAuditCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AuditCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditCategoryFilter<$PrismaModel>
    _max?: NestedEnumAuditCategoryFilter<$PrismaModel>
  }

  export type NestedEnumAuditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditStatusFilter<$PrismaModel>
    _max?: NestedEnumAuditStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeFilter<$PrismaModel> | $Enums.FeedbackType
  }

  export type NestedEnumFeedbackCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackCategory | EnumFeedbackCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackCategoryFilter<$PrismaModel> | $Enums.FeedbackCategory
  }

  export type NestedEnumFeedbackPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackPriority | EnumFeedbackPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackPriorityFilter<$PrismaModel> | $Enums.FeedbackPriority
  }

  export type NestedEnumFeedbackStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackStatus | EnumFeedbackStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackStatusFilter<$PrismaModel> | $Enums.FeedbackStatus
  }

  export type NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedbackTypeFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackCategory | EnumFeedbackCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackCategoryFilter<$PrismaModel>
    _max?: NestedEnumFeedbackCategoryFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackPriority | EnumFeedbackPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackPriorityWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackPriorityFilter<$PrismaModel>
    _max?: NestedEnumFeedbackPriorityFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackStatus | EnumFeedbackStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackStatusWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackStatusFilter<$PrismaModel>
    _max?: NestedEnumFeedbackStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumReceiptTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReceiptType | EnumReceiptTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReceiptType[] | ListEnumReceiptTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReceiptType[] | ListEnumReceiptTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReceiptTypeFilter<$PrismaModel> | $Enums.ReceiptType
  }

  export type NestedEnumTrackTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackType | EnumTrackTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTrackTypeNullableFilter<$PrismaModel> | $Enums.TrackType | null
  }

  export type NestedEnumReceiptTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReceiptType | EnumReceiptTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReceiptType[] | ListEnumReceiptTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReceiptType[] | ListEnumReceiptTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReceiptTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReceiptType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReceiptTypeFilter<$PrismaModel>
    _max?: NestedEnumReceiptTypeFilter<$PrismaModel>
  }

  export type NestedEnumTrackTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackType | EnumTrackTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTrackTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TrackType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTrackTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumTrackTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTrackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackType | EnumTrackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrackTypeFilter<$PrismaModel> | $Enums.TrackType
  }

  export type NestedEnumHandoffStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HandoffStatus | EnumHandoffStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HandoffStatus[] | ListEnumHandoffStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HandoffStatus[] | ListEnumHandoffStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHandoffStatusFilter<$PrismaModel> | $Enums.HandoffStatus
  }

  export type NestedEnumTrackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackType | EnumTrackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrackType[] | ListEnumTrackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrackTypeWithAggregatesFilter<$PrismaModel> | $Enums.TrackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrackTypeFilter<$PrismaModel>
    _max?: NestedEnumTrackTypeFilter<$PrismaModel>
  }

  export type NestedEnumHandoffStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HandoffStatus | EnumHandoffStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HandoffStatus[] | ListEnumHandoffStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HandoffStatus[] | ListEnumHandoffStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHandoffStatusWithAggregatesFilter<$PrismaModel> | $Enums.HandoffStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHandoffStatusFilter<$PrismaModel>
    _max?: NestedEnumHandoffStatusFilter<$PrismaModel>
  }

  export type NestedEnumSSOProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.SSOProvider | EnumSSOProviderFieldRefInput<$PrismaModel>
    in?: $Enums.SSOProvider[] | ListEnumSSOProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.SSOProvider[] | ListEnumSSOProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumSSOProviderFilter<$PrismaModel> | $Enums.SSOProvider
  }

  export type NestedEnumSSOProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SSOProvider | EnumSSOProviderFieldRefInput<$PrismaModel>
    in?: $Enums.SSOProvider[] | ListEnumSSOProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.SSOProvider[] | ListEnumSSOProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumSSOProviderWithAggregatesFilter<$PrismaModel> | $Enums.SSOProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSSOProviderFilter<$PrismaModel>
    _max?: NestedEnumSSOProviderFilter<$PrismaModel>
  }

  export type OrganizationCreateWithoutUsersInput = {
    name: string
    plan?: $Enums.PlanType
    status?: $Enums.OrgStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamCreateNestedManyWithoutOrganizationInput
    ssoConfigs?: SSOConfigurationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    plan?: $Enums.PlanType
    status?: $Enums.OrgStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutOrganizationInput
    ssoConfigs?: SSOConfigurationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutUsersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
  }

  export type SessionCreateWithoutUserInput = {
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: number
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditRecordCreateWithoutUserInput = {
    action: string
    category: $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AuditStatus
    lamport: number
    hashPointer?: string | null
    organizationId?: number | null
    blockHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditRecordUncheckedCreateWithoutUserInput = {
    id?: number
    action: string
    category: $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AuditStatus
    lamport: number
    hashPointer?: string | null
    organizationId?: number | null
    blockHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditRecordCreateOrConnectWithoutUserInput = {
    where: AuditRecordWhereUniqueInput
    create: XOR<AuditRecordCreateWithoutUserInput, AuditRecordUncheckedCreateWithoutUserInput>
  }

  export type AuditRecordCreateManyUserInputEnvelope = {
    data: AuditRecordCreateManyUserInput | AuditRecordCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TeamMemberCreateWithoutUserInput = {
    role?: $Enums.TeamRole
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
  }

  export type TeamMemberUncheckedCreateWithoutUserInput = {
    id?: number
    teamId: number
    role?: $Enums.TeamRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberCreateManyUserInputEnvelope = {
    data: TeamMemberCreateManyUserInput | TeamMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationPreferenceCreateWithoutUserInput = {
    emailEnabled?: boolean
    testComplete?: boolean
    batchComplete?: boolean
    scheduledTestComplete?: boolean
    alertsEnabled?: boolean
    lowScoreThreshold?: number
    highScoreThreshold?: number
    scoreDropAlert?: boolean
    witnessFailureAlert?: boolean
    dailyReport?: boolean
    weeklyReport?: boolean
    monthlyReport?: boolean
    reportTime?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUncheckedCreateWithoutUserInput = {
    id?: number
    emailEnabled?: boolean
    testComplete?: boolean
    batchComplete?: boolean
    scheduledTestComplete?: boolean
    alertsEnabled?: boolean
    lowScoreThreshold?: number
    highScoreThreshold?: number
    scoreDropAlert?: boolean
    witnessFailureAlert?: boolean
    dailyReport?: boolean
    weeklyReport?: boolean
    monthlyReport?: boolean
    reportTime?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceCreateOrConnectWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type BudgetCreateWithoutUserInput = {
    limit: number
    period?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetUncheckedCreateWithoutUserInput = {
    id?: number
    limit: number
    period?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCreateOrConnectWithoutUserInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput>
  }

  export type BudgetCreateManyUserInputEnvelope = {
    data: BudgetCreateManyUserInput | BudgetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RegressionBaselineCreateWithoutUserInput = {
    modelName: string
    modelVersion?: string | null
    testType: string
    avgResponseTime: number
    avgCost: number
    avgQualityScore: number
    avgAccuracy: number
    successRate: number
    alertThreshold?: number
    sampleSize: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegressionBaselineUncheckedCreateWithoutUserInput = {
    id?: number
    modelName: string
    modelVersion?: string | null
    testType: string
    avgResponseTime: number
    avgCost: number
    avgQualityScore: number
    avgAccuracy: number
    successRate: number
    alertThreshold?: number
    sampleSize: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegressionBaselineCreateOrConnectWithoutUserInput = {
    where: RegressionBaselineWhereUniqueInput
    create: XOR<RegressionBaselineCreateWithoutUserInput, RegressionBaselineUncheckedCreateWithoutUserInput>
  }

  export type RegressionBaselineCreateManyUserInputEnvelope = {
    data: RegressionBaselineCreateManyUserInput | RegressionBaselineCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutUserInput = {
    type: $Enums.FeedbackType
    category: $Enums.FeedbackCategory
    priority?: $Enums.FeedbackPriority
    subject: string
    message: string
    url?: string | null
    userAgent?: string | null
    status?: $Enums.FeedbackStatus
    assignedTo?: number | null
    response?: string | null
    respondedAt?: Date | string | null
    respondedBy?: number | null
    sentiment?: string | null
    sentimentScore?: number | null
    upvotes?: number
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type FeedbackUncheckedCreateWithoutUserInput = {
    id?: number
    type: $Enums.FeedbackType
    category: $Enums.FeedbackCategory
    priority?: $Enums.FeedbackPriority
    subject: string
    message: string
    url?: string | null
    userAgent?: string | null
    status?: $Enums.FeedbackStatus
    assignedTo?: number | null
    response?: string | null
    respondedAt?: Date | string | null
    respondedBy?: number | null
    sentiment?: string | null
    sentimentScore?: number | null
    upvotes?: number
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type FeedbackCreateOrConnectWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput>
  }

  export type FeedbackCreateManyUserInputEnvelope = {
    data: FeedbackCreateManyUserInput | FeedbackCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BENReceiptCreateWithoutUserInput = {
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp?: Date | string
    persona?: $Enums.BENPersona
    track?: $Enums.TrackType | null
    payload: JsonNullValueInput | InputJsonValue
    digest: string
    previousDigest?: string | null
    baselineDigest?: string | null
    witnessModel?: string | null
    witnessSignature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    handoffsFrom?: TriTrackHandoffCreateNestedManyWithoutFromReceiptInput
    handoffsTo?: TriTrackHandoffCreateNestedManyWithoutToReceiptInput
  }

  export type BENReceiptUncheckedCreateWithoutUserInput = {
    id?: number
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp?: Date | string
    persona?: $Enums.BENPersona
    track?: $Enums.TrackType | null
    payload: JsonNullValueInput | InputJsonValue
    digest: string
    previousDigest?: string | null
    baselineDigest?: string | null
    witnessModel?: string | null
    witnessSignature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    handoffsFrom?: TriTrackHandoffUncheckedCreateNestedManyWithoutFromReceiptInput
    handoffsTo?: TriTrackHandoffUncheckedCreateNestedManyWithoutToReceiptInput
  }

  export type BENReceiptCreateOrConnectWithoutUserInput = {
    where: BENReceiptWhereUniqueInput
    create: XOR<BENReceiptCreateWithoutUserInput, BENReceiptUncheckedCreateWithoutUserInput>
  }

  export type BENReceiptCreateManyUserInputEnvelope = {
    data: BENReceiptCreateManyUserInput | BENReceiptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BENSessionCreateWithoutUserInput = {
    persona: $Enums.BENPersona
    priority: number
    locked?: boolean
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    startLamport: number
    endLamport?: number | null
    switchReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BENSessionUncheckedCreateWithoutUserInput = {
    id?: number
    persona: $Enums.BENPersona
    priority: number
    locked?: boolean
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    startLamport: number
    endLamport?: number | null
    switchReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BENSessionCreateOrConnectWithoutUserInput = {
    where: BENSessionWhereUniqueInput
    create: XOR<BENSessionCreateWithoutUserInput, BENSessionUncheckedCreateWithoutUserInput>
  }

  export type BENSessionCreateManyUserInputEnvelope = {
    data: BENSessionCreateManyUserInput | BENSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ZScanVerificationCreateWithoutUserInput = {
    totalRules: number
    passed: number
    warnings: number
    critical: number
    results: JsonNullValueInput | InputJsonValue
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ZScanVerificationUncheckedCreateWithoutUserInput = {
    id?: number
    totalRules: number
    passed: number
    warnings: number
    critical: number
    results: JsonNullValueInput | InputJsonValue
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ZScanVerificationCreateOrConnectWithoutUserInput = {
    where: ZScanVerificationWhereUniqueInput
    create: XOR<ZScanVerificationCreateWithoutUserInput, ZScanVerificationUncheckedCreateWithoutUserInput>
  }

  export type ZScanVerificationCreateManyUserInputEnvelope = {
    data: ZScanVerificationCreateManyUserInput | ZScanVerificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutUsersInput = {
    update: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUsersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type OrganizationUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    status?: EnumOrgStatusFieldUpdateOperationsInput | $Enums.OrgStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUpdateManyWithoutOrganizationNestedInput
    ssoConfigs?: SSOConfigurationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    status?: EnumOrgStatusFieldUpdateOperationsInput | $Enums.OrgStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutOrganizationNestedInput
    ssoConfigs?: SSOConfigurationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: IntFilter<"Session"> | number
    userId?: IntFilter<"Session"> | number
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    userAgent?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    lastUsedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type AuditRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditRecordWhereUniqueInput
    update: XOR<AuditRecordUpdateWithoutUserInput, AuditRecordUncheckedUpdateWithoutUserInput>
    create: XOR<AuditRecordCreateWithoutUserInput, AuditRecordUncheckedCreateWithoutUserInput>
  }

  export type AuditRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditRecordWhereUniqueInput
    data: XOR<AuditRecordUpdateWithoutUserInput, AuditRecordUncheckedUpdateWithoutUserInput>
  }

  export type AuditRecordUpdateManyWithWhereWithoutUserInput = {
    where: AuditRecordScalarWhereInput
    data: XOR<AuditRecordUpdateManyMutationInput, AuditRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditRecordScalarWhereInput = {
    AND?: AuditRecordScalarWhereInput | AuditRecordScalarWhereInput[]
    OR?: AuditRecordScalarWhereInput[]
    NOT?: AuditRecordScalarWhereInput | AuditRecordScalarWhereInput[]
    id?: IntFilter<"AuditRecord"> | number
    userId?: IntFilter<"AuditRecord"> | number
    action?: StringFilter<"AuditRecord"> | string
    category?: EnumAuditCategoryFilter<"AuditRecord"> | $Enums.AuditCategory
    details?: JsonNullableFilter<"AuditRecord">
    metadata?: JsonNullableFilter<"AuditRecord">
    status?: EnumAuditStatusFilter<"AuditRecord"> | $Enums.AuditStatus
    lamport?: IntFilter<"AuditRecord"> | number
    hashPointer?: StringNullableFilter<"AuditRecord"> | string | null
    organizationId?: IntNullableFilter<"AuditRecord"> | number | null
    blockHash?: StringNullableFilter<"AuditRecord"> | string | null
    createdAt?: DateTimeFilter<"AuditRecord"> | Date | string
    updatedAt?: DateTimeFilter<"AuditRecord"> | Date | string
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutUserInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamMemberScalarWhereInput = {
    AND?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    OR?: TeamMemberScalarWhereInput[]
    NOT?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    id?: IntFilter<"TeamMember"> | number
    teamId?: IntFilter<"TeamMember"> | number
    userId?: IntFilter<"TeamMember"> | number
    role?: EnumTeamRoleFilter<"TeamMember"> | $Enums.TeamRole
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"TeamMember"> | Date | string
  }

  export type NotificationPreferenceUpsertWithoutUserInput = {
    update: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    where?: NotificationPreferenceWhereInput
  }

  export type NotificationPreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationPreferenceWhereInput
    data: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateWithoutUserInput = {
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    testComplete?: BoolFieldUpdateOperationsInput | boolean
    batchComplete?: BoolFieldUpdateOperationsInput | boolean
    scheduledTestComplete?: BoolFieldUpdateOperationsInput | boolean
    alertsEnabled?: BoolFieldUpdateOperationsInput | boolean
    lowScoreThreshold?: FloatFieldUpdateOperationsInput | number
    highScoreThreshold?: FloatFieldUpdateOperationsInput | number
    scoreDropAlert?: BoolFieldUpdateOperationsInput | boolean
    witnessFailureAlert?: BoolFieldUpdateOperationsInput | boolean
    dailyReport?: BoolFieldUpdateOperationsInput | boolean
    weeklyReport?: BoolFieldUpdateOperationsInput | boolean
    monthlyReport?: BoolFieldUpdateOperationsInput | boolean
    reportTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    testComplete?: BoolFieldUpdateOperationsInput | boolean
    batchComplete?: BoolFieldUpdateOperationsInput | boolean
    scheduledTestComplete?: BoolFieldUpdateOperationsInput | boolean
    alertsEnabled?: BoolFieldUpdateOperationsInput | boolean
    lowScoreThreshold?: FloatFieldUpdateOperationsInput | number
    highScoreThreshold?: FloatFieldUpdateOperationsInput | number
    scoreDropAlert?: BoolFieldUpdateOperationsInput | boolean
    witnessFailureAlert?: BoolFieldUpdateOperationsInput | boolean
    dailyReport?: BoolFieldUpdateOperationsInput | boolean
    weeklyReport?: BoolFieldUpdateOperationsInput | boolean
    monthlyReport?: BoolFieldUpdateOperationsInput | boolean
    reportTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUpsertWithWhereUniqueWithoutUserInput = {
    where: BudgetWhereUniqueInput
    update: XOR<BudgetUpdateWithoutUserInput, BudgetUncheckedUpdateWithoutUserInput>
    create: XOR<BudgetCreateWithoutUserInput, BudgetUncheckedCreateWithoutUserInput>
  }

  export type BudgetUpdateWithWhereUniqueWithoutUserInput = {
    where: BudgetWhereUniqueInput
    data: XOR<BudgetUpdateWithoutUserInput, BudgetUncheckedUpdateWithoutUserInput>
  }

  export type BudgetUpdateManyWithWhereWithoutUserInput = {
    where: BudgetScalarWhereInput
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyWithoutUserInput>
  }

  export type BudgetScalarWhereInput = {
    AND?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    OR?: BudgetScalarWhereInput[]
    NOT?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    id?: IntFilter<"Budget"> | number
    userId?: IntFilter<"Budget"> | number
    limit?: FloatFilter<"Budget"> | number
    period?: StringFilter<"Budget"> | string
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
  }

  export type RegressionBaselineUpsertWithWhereUniqueWithoutUserInput = {
    where: RegressionBaselineWhereUniqueInput
    update: XOR<RegressionBaselineUpdateWithoutUserInput, RegressionBaselineUncheckedUpdateWithoutUserInput>
    create: XOR<RegressionBaselineCreateWithoutUserInput, RegressionBaselineUncheckedCreateWithoutUserInput>
  }

  export type RegressionBaselineUpdateWithWhereUniqueWithoutUserInput = {
    where: RegressionBaselineWhereUniqueInput
    data: XOR<RegressionBaselineUpdateWithoutUserInput, RegressionBaselineUncheckedUpdateWithoutUserInput>
  }

  export type RegressionBaselineUpdateManyWithWhereWithoutUserInput = {
    where: RegressionBaselineScalarWhereInput
    data: XOR<RegressionBaselineUpdateManyMutationInput, RegressionBaselineUncheckedUpdateManyWithoutUserInput>
  }

  export type RegressionBaselineScalarWhereInput = {
    AND?: RegressionBaselineScalarWhereInput | RegressionBaselineScalarWhereInput[]
    OR?: RegressionBaselineScalarWhereInput[]
    NOT?: RegressionBaselineScalarWhereInput | RegressionBaselineScalarWhereInput[]
    id?: IntFilter<"RegressionBaseline"> | number
    userId?: IntFilter<"RegressionBaseline"> | number
    modelName?: StringFilter<"RegressionBaseline"> | string
    modelVersion?: StringNullableFilter<"RegressionBaseline"> | string | null
    testType?: StringFilter<"RegressionBaseline"> | string
    avgResponseTime?: FloatFilter<"RegressionBaseline"> | number
    avgCost?: FloatFilter<"RegressionBaseline"> | number
    avgQualityScore?: FloatFilter<"RegressionBaseline"> | number
    avgAccuracy?: FloatFilter<"RegressionBaseline"> | number
    successRate?: FloatFilter<"RegressionBaseline"> | number
    alertThreshold?: FloatFilter<"RegressionBaseline"> | number
    sampleSize?: IntFilter<"RegressionBaseline"> | number
    isActive?: BoolFilter<"RegressionBaseline"> | boolean
    createdAt?: DateTimeFilter<"RegressionBaseline"> | Date | string
    updatedAt?: DateTimeFilter<"RegressionBaseline"> | Date | string
  }

  export type FeedbackUpsertWithWhereUniqueWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutUserInput, FeedbackUncheckedUpdateWithoutUserInput>
    create: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutUserInput, FeedbackUncheckedUpdateWithoutUserInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutUserInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutUserInput>
  }

  export type FeedbackScalarWhereInput = {
    AND?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    OR?: FeedbackScalarWhereInput[]
    NOT?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    id?: IntFilter<"Feedback"> | number
    userId?: IntFilter<"Feedback"> | number
    type?: EnumFeedbackTypeFilter<"Feedback"> | $Enums.FeedbackType
    category?: EnumFeedbackCategoryFilter<"Feedback"> | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityFilter<"Feedback"> | $Enums.FeedbackPriority
    subject?: StringFilter<"Feedback"> | string
    message?: StringFilter<"Feedback"> | string
    url?: StringNullableFilter<"Feedback"> | string | null
    userAgent?: StringNullableFilter<"Feedback"> | string | null
    status?: EnumFeedbackStatusFilter<"Feedback"> | $Enums.FeedbackStatus
    assignedTo?: IntNullableFilter<"Feedback"> | number | null
    response?: StringNullableFilter<"Feedback"> | string | null
    respondedAt?: DateTimeNullableFilter<"Feedback"> | Date | string | null
    respondedBy?: IntNullableFilter<"Feedback"> | number | null
    sentiment?: StringNullableFilter<"Feedback"> | string | null
    sentimentScore?: FloatNullableFilter<"Feedback"> | number | null
    upvotes?: IntFilter<"Feedback"> | number
    isPublic?: BoolFilter<"Feedback"> | boolean
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeFilter<"Feedback"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Feedback"> | Date | string | null
  }

  export type BENReceiptUpsertWithWhereUniqueWithoutUserInput = {
    where: BENReceiptWhereUniqueInput
    update: XOR<BENReceiptUpdateWithoutUserInput, BENReceiptUncheckedUpdateWithoutUserInput>
    create: XOR<BENReceiptCreateWithoutUserInput, BENReceiptUncheckedCreateWithoutUserInput>
  }

  export type BENReceiptUpdateWithWhereUniqueWithoutUserInput = {
    where: BENReceiptWhereUniqueInput
    data: XOR<BENReceiptUpdateWithoutUserInput, BENReceiptUncheckedUpdateWithoutUserInput>
  }

  export type BENReceiptUpdateManyWithWhereWithoutUserInput = {
    where: BENReceiptScalarWhereInput
    data: XOR<BENReceiptUpdateManyMutationInput, BENReceiptUncheckedUpdateManyWithoutUserInput>
  }

  export type BENReceiptScalarWhereInput = {
    AND?: BENReceiptScalarWhereInput | BENReceiptScalarWhereInput[]
    OR?: BENReceiptScalarWhereInput[]
    NOT?: BENReceiptScalarWhereInput | BENReceiptScalarWhereInput[]
    id?: IntFilter<"BENReceipt"> | number
    receiptType?: EnumReceiptTypeFilter<"BENReceipt"> | $Enums.ReceiptType
    lamportClock?: IntFilter<"BENReceipt"> | number
    realTimestamp?: DateTimeFilter<"BENReceipt"> | Date | string
    userId?: IntNullableFilter<"BENReceipt"> | number | null
    persona?: EnumBENPersonaFilter<"BENReceipt"> | $Enums.BENPersona
    track?: EnumTrackTypeNullableFilter<"BENReceipt"> | $Enums.TrackType | null
    payload?: JsonFilter<"BENReceipt">
    digest?: StringFilter<"BENReceipt"> | string
    previousDigest?: StringNullableFilter<"BENReceipt"> | string | null
    baselineDigest?: StringNullableFilter<"BENReceipt"> | string | null
    witnessModel?: StringNullableFilter<"BENReceipt"> | string | null
    witnessSignature?: StringNullableFilter<"BENReceipt"> | string | null
    metadata?: JsonNullableFilter<"BENReceipt">
    createdAt?: DateTimeFilter<"BENReceipt"> | Date | string
  }

  export type BENSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: BENSessionWhereUniqueInput
    update: XOR<BENSessionUpdateWithoutUserInput, BENSessionUncheckedUpdateWithoutUserInput>
    create: XOR<BENSessionCreateWithoutUserInput, BENSessionUncheckedCreateWithoutUserInput>
  }

  export type BENSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: BENSessionWhereUniqueInput
    data: XOR<BENSessionUpdateWithoutUserInput, BENSessionUncheckedUpdateWithoutUserInput>
  }

  export type BENSessionUpdateManyWithWhereWithoutUserInput = {
    where: BENSessionScalarWhereInput
    data: XOR<BENSessionUpdateManyMutationInput, BENSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type BENSessionScalarWhereInput = {
    AND?: BENSessionScalarWhereInput | BENSessionScalarWhereInput[]
    OR?: BENSessionScalarWhereInput[]
    NOT?: BENSessionScalarWhereInput | BENSessionScalarWhereInput[]
    id?: IntFilter<"BENSession"> | number
    userId?: IntFilter<"BENSession"> | number
    persona?: EnumBENPersonaFilter<"BENSession"> | $Enums.BENPersona
    priority?: IntFilter<"BENSession"> | number
    locked?: BoolFilter<"BENSession"> | boolean
    startedAt?: DateTimeFilter<"BENSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"BENSession"> | Date | string | null
    duration?: IntNullableFilter<"BENSession"> | number | null
    startLamport?: IntFilter<"BENSession"> | number
    endLamport?: IntNullableFilter<"BENSession"> | number | null
    switchReason?: StringNullableFilter<"BENSession"> | string | null
    metadata?: JsonNullableFilter<"BENSession">
  }

  export type ZScanVerificationUpsertWithWhereUniqueWithoutUserInput = {
    where: ZScanVerificationWhereUniqueInput
    update: XOR<ZScanVerificationUpdateWithoutUserInput, ZScanVerificationUncheckedUpdateWithoutUserInput>
    create: XOR<ZScanVerificationCreateWithoutUserInput, ZScanVerificationUncheckedCreateWithoutUserInput>
  }

  export type ZScanVerificationUpdateWithWhereUniqueWithoutUserInput = {
    where: ZScanVerificationWhereUniqueInput
    data: XOR<ZScanVerificationUpdateWithoutUserInput, ZScanVerificationUncheckedUpdateWithoutUserInput>
  }

  export type ZScanVerificationUpdateManyWithWhereWithoutUserInput = {
    where: ZScanVerificationScalarWhereInput
    data: XOR<ZScanVerificationUpdateManyMutationInput, ZScanVerificationUncheckedUpdateManyWithoutUserInput>
  }

  export type ZScanVerificationScalarWhereInput = {
    AND?: ZScanVerificationScalarWhereInput | ZScanVerificationScalarWhereInput[]
    OR?: ZScanVerificationScalarWhereInput[]
    NOT?: ZScanVerificationScalarWhereInput | ZScanVerificationScalarWhereInput[]
    id?: IntFilter<"ZScanVerification"> | number
    userId?: IntNullableFilter<"ZScanVerification"> | number | null
    totalRules?: IntFilter<"ZScanVerification"> | number
    passed?: IntFilter<"ZScanVerification"> | number
    warnings?: IntFilter<"ZScanVerification"> | number
    critical?: IntFilter<"ZScanVerification"> | number
    results?: JsonFilter<"ZScanVerification">
    config?: JsonFilter<"ZScanVerification">
    createdAt?: DateTimeFilter<"ZScanVerification"> | Date | string
  }

  export type UserCreateWithoutOrganizationInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserCreateManyOrganizationInputEnvelope = {
    data: UserCreateManyOrganizationInput | UserCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutOrganizationInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutOrganizationInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutOrganizationInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutOrganizationInput, TeamUncheckedCreateWithoutOrganizationInput>
  }

  export type TeamCreateManyOrganizationInputEnvelope = {
    data: TeamCreateManyOrganizationInput | TeamCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type SSOConfigurationCreateWithoutOrganizationInput = {
    provider: $Enums.SSOProvider
    enabled?: boolean
    samlEntryPoint?: string | null
    samlIssuer?: string | null
    samlCert?: string | null
    samlCallbackUrl?: string | null
    samlLogoutUrl?: string | null
    oauthClientId?: string | null
    oauthClientSecret?: string | null
    oauthAuthUrl?: string | null
    oauthTokenUrl?: string | null
    oauthUserInfoUrl?: string | null
    oauthScopes?: SSOConfigurationCreateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationCreatedomainRestrictionInput | string[]
    jitProvisioning?: boolean
    defaultRole?: $Enums.Role
    defaultTier?: $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type SSOConfigurationUncheckedCreateWithoutOrganizationInput = {
    id?: number
    provider: $Enums.SSOProvider
    enabled?: boolean
    samlEntryPoint?: string | null
    samlIssuer?: string | null
    samlCert?: string | null
    samlCallbackUrl?: string | null
    samlLogoutUrl?: string | null
    oauthClientId?: string | null
    oauthClientSecret?: string | null
    oauthAuthUrl?: string | null
    oauthTokenUrl?: string | null
    oauthUserInfoUrl?: string | null
    oauthScopes?: SSOConfigurationCreateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationCreatedomainRestrictionInput | string[]
    jitProvisioning?: boolean
    defaultRole?: $Enums.Role
    defaultTier?: $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type SSOConfigurationCreateOrConnectWithoutOrganizationInput = {
    where: SSOConfigurationWhereUniqueInput
    create: XOR<SSOConfigurationCreateWithoutOrganizationInput, SSOConfigurationUncheckedCreateWithoutOrganizationInput>
  }

  export type SSOConfigurationCreateManyOrganizationInputEnvelope = {
    data: SSOConfigurationCreateManyOrganizationInput | SSOConfigurationCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
  }

  export type UserUpdateManyWithWhereWithoutOrganizationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    tier?: EnumUserTierFilter<"User"> | $Enums.UserTier
    permissions?: EnumPermissionNullableListFilter<"User">
    orgId?: IntNullableFilter<"User"> | number | null
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    backupCodes?: StringNullableListFilter<"User">
    failedLoginAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordChangedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    ssoProvider?: StringNullableFilter<"User"> | string | null
    ssoId?: StringNullableFilter<"User"> | string | null
    ssoMetadata?: JsonNullableFilter<"User">
    currentPersona?: EnumBENPersonaFilter<"User"> | $Enums.BENPersona
    personaLocked?: BoolFilter<"User"> | boolean
    lamportCounter?: IntFilter<"User"> | number
    lastReceiptId?: IntNullableFilter<"User"> | number | null
  }

  export type TeamUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutOrganizationInput, TeamUncheckedUpdateWithoutOrganizationInput>
    create: XOR<TeamCreateWithoutOrganizationInput, TeamUncheckedCreateWithoutOrganizationInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutOrganizationInput, TeamUncheckedUpdateWithoutOrganizationInput>
  }

  export type TeamUpdateManyWithWhereWithoutOrganizationInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: IntFilter<"Team"> | number
    name?: StringFilter<"Team"> | string
    orgId?: IntFilter<"Team"> | number
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
  }

  export type SSOConfigurationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: SSOConfigurationWhereUniqueInput
    update: XOR<SSOConfigurationUpdateWithoutOrganizationInput, SSOConfigurationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<SSOConfigurationCreateWithoutOrganizationInput, SSOConfigurationUncheckedCreateWithoutOrganizationInput>
  }

  export type SSOConfigurationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: SSOConfigurationWhereUniqueInput
    data: XOR<SSOConfigurationUpdateWithoutOrganizationInput, SSOConfigurationUncheckedUpdateWithoutOrganizationInput>
  }

  export type SSOConfigurationUpdateManyWithWhereWithoutOrganizationInput = {
    where: SSOConfigurationScalarWhereInput
    data: XOR<SSOConfigurationUpdateManyMutationInput, SSOConfigurationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type SSOConfigurationScalarWhereInput = {
    AND?: SSOConfigurationScalarWhereInput | SSOConfigurationScalarWhereInput[]
    OR?: SSOConfigurationScalarWhereInput[]
    NOT?: SSOConfigurationScalarWhereInput | SSOConfigurationScalarWhereInput[]
    id?: IntFilter<"SSOConfiguration"> | number
    orgId?: IntFilter<"SSOConfiguration"> | number
    provider?: EnumSSOProviderFilter<"SSOConfiguration"> | $Enums.SSOProvider
    enabled?: BoolFilter<"SSOConfiguration"> | boolean
    samlEntryPoint?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlIssuer?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlCert?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlCallbackUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    samlLogoutUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthClientId?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthClientSecret?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthAuthUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthTokenUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthUserInfoUrl?: StringNullableFilter<"SSOConfiguration"> | string | null
    oauthScopes?: StringNullableListFilter<"SSOConfiguration">
    domainRestriction?: StringNullableListFilter<"SSOConfiguration">
    jitProvisioning?: BoolFilter<"SSOConfiguration"> | boolean
    defaultRole?: EnumRoleFilter<"SSOConfiguration"> | $Enums.Role
    defaultTier?: EnumUserTierFilter<"SSOConfiguration"> | $Enums.UserTier
    metadata?: JsonNullableFilter<"SSOConfiguration">
    createdBy?: IntFilter<"SSOConfiguration"> | number
    createdAt?: DateTimeFilter<"SSOConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"SSOConfiguration"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"SSOConfiguration"> | Date | string | null
  }

  export type OrganizationCreateWithoutTeamsInput = {
    name: string
    plan?: $Enums.PlanType
    status?: $Enums.OrgStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    ssoConfigs?: SSOConfigurationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutTeamsInput = {
    id?: number
    name: string
    plan?: $Enums.PlanType
    status?: $Enums.OrgStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    ssoConfigs?: SSOConfigurationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutTeamsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutTeamsInput, OrganizationUncheckedCreateWithoutTeamsInput>
  }

  export type TeamMemberCreateWithoutTeamInput = {
    role?: $Enums.TeamRole
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeamsInput
  }

  export type TeamMemberUncheckedCreateWithoutTeamInput = {
    id?: number
    userId: number
    role?: $Enums.TeamRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberCreateManyTeamInputEnvelope = {
    data: TeamMemberCreateManyTeamInput | TeamMemberCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutTeamsInput = {
    update: XOR<OrganizationUpdateWithoutTeamsInput, OrganizationUncheckedUpdateWithoutTeamsInput>
    create: XOR<OrganizationCreateWithoutTeamsInput, OrganizationUncheckedCreateWithoutTeamsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutTeamsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutTeamsInput, OrganizationUncheckedUpdateWithoutTeamsInput>
  }

  export type OrganizationUpdateWithoutTeamsInput = {
    name?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    status?: EnumOrgStatusFieldUpdateOperationsInput | $Enums.OrgStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    ssoConfigs?: SSOConfigurationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutTeamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    status?: EnumOrgStatusFieldUpdateOperationsInput | $Enums.OrgStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    ssoConfigs?: SSOConfigurationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamCreateWithoutMembersInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutTeamsInput
  }

  export type TeamUncheckedCreateWithoutMembersInput = {
    id?: number
    name: string
    orgId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamCreateOrConnectWithoutMembersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutTeamsInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamsInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
  }

  export type TeamUpsertWithoutMembersInput = {
    update: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMembersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type TeamUpdateWithoutMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutTeamsNestedInput
  }

  export type TeamUncheckedUpdateWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    orgId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTeamsInput = {
    update: XOR<UserUpdateWithoutTeamsInput, UserUncheckedUpdateWithoutTeamsInput>
    create: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamsInput, UserUncheckedUpdateWithoutTeamsInput>
  }

  export type UserUpdateWithoutTeamsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditsInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditsInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditsInput, UserUncheckedCreateWithoutAuditsInput>
  }

  export type UserUpsertWithoutAuditsInput = {
    update: XOR<UserUpdateWithoutAuditsInput, UserUncheckedUpdateWithoutAuditsInput>
    create: XOR<UserCreateWithoutAuditsInput, UserUncheckedCreateWithoutAuditsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditsInput, UserUncheckedUpdateWithoutAuditsInput>
  }

  export type UserUpdateWithoutAuditsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBudgetsInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBudgetsInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBudgetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBudgetsInput, UserUncheckedCreateWithoutBudgetsInput>
  }

  export type UserUpsertWithoutBudgetsInput = {
    update: XOR<UserUpdateWithoutBudgetsInput, UserUncheckedUpdateWithoutBudgetsInput>
    create: XOR<UserCreateWithoutBudgetsInput, UserUncheckedCreateWithoutBudgetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBudgetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBudgetsInput, UserUncheckedUpdateWithoutBudgetsInput>
  }

  export type UserUpdateWithoutBudgetsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBudgetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRegressionBaselinesInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRegressionBaselinesInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRegressionBaselinesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRegressionBaselinesInput, UserUncheckedCreateWithoutRegressionBaselinesInput>
  }

  export type UserUpsertWithoutRegressionBaselinesInput = {
    update: XOR<UserUpdateWithoutRegressionBaselinesInput, UserUncheckedUpdateWithoutRegressionBaselinesInput>
    create: XOR<UserCreateWithoutRegressionBaselinesInput, UserUncheckedCreateWithoutRegressionBaselinesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRegressionBaselinesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRegressionBaselinesInput, UserUncheckedUpdateWithoutRegressionBaselinesInput>
  }

  export type UserUpdateWithoutRegressionBaselinesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRegressionBaselinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFeedbacksInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeedbacksInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeedbacksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
  }

  export type UserUpsertWithoutFeedbacksInput = {
    update: XOR<UserUpdateWithoutFeedbacksInput, UserUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedbacksInput, UserUncheckedUpdateWithoutFeedbacksInput>
  }

  export type UserUpdateWithoutFeedbacksInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbacksInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBenReceiptsInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBenReceiptsInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBenReceiptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBenReceiptsInput, UserUncheckedCreateWithoutBenReceiptsInput>
  }

  export type TriTrackHandoffCreateWithoutFromReceiptInput = {
    fromTrack: $Enums.TrackType
    toTrack: $Enums.TrackType
    status?: $Enums.HandoffStatus
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    latencyMs?: number | null
    exceededLimit?: boolean
    payload: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    toReceipt?: BENReceiptCreateNestedOneWithoutHandoffsToInput
  }

  export type TriTrackHandoffUncheckedCreateWithoutFromReceiptInput = {
    id?: number
    fromTrack: $Enums.TrackType
    toTrack: $Enums.TrackType
    status?: $Enums.HandoffStatus
    toReceiptId?: number | null
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    latencyMs?: number | null
    exceededLimit?: boolean
    payload: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffCreateOrConnectWithoutFromReceiptInput = {
    where: TriTrackHandoffWhereUniqueInput
    create: XOR<TriTrackHandoffCreateWithoutFromReceiptInput, TriTrackHandoffUncheckedCreateWithoutFromReceiptInput>
  }

  export type TriTrackHandoffCreateManyFromReceiptInputEnvelope = {
    data: TriTrackHandoffCreateManyFromReceiptInput | TriTrackHandoffCreateManyFromReceiptInput[]
    skipDuplicates?: boolean
  }

  export type TriTrackHandoffCreateWithoutToReceiptInput = {
    fromTrack: $Enums.TrackType
    toTrack: $Enums.TrackType
    status?: $Enums.HandoffStatus
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    latencyMs?: number | null
    exceededLimit?: boolean
    payload: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    fromReceipt: BENReceiptCreateNestedOneWithoutHandoffsFromInput
  }

  export type TriTrackHandoffUncheckedCreateWithoutToReceiptInput = {
    id?: number
    fromTrack: $Enums.TrackType
    toTrack: $Enums.TrackType
    status?: $Enums.HandoffStatus
    fromReceiptId: number
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    latencyMs?: number | null
    exceededLimit?: boolean
    payload: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffCreateOrConnectWithoutToReceiptInput = {
    where: TriTrackHandoffWhereUniqueInput
    create: XOR<TriTrackHandoffCreateWithoutToReceiptInput, TriTrackHandoffUncheckedCreateWithoutToReceiptInput>
  }

  export type TriTrackHandoffCreateManyToReceiptInputEnvelope = {
    data: TriTrackHandoffCreateManyToReceiptInput | TriTrackHandoffCreateManyToReceiptInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBenReceiptsInput = {
    update: XOR<UserUpdateWithoutBenReceiptsInput, UserUncheckedUpdateWithoutBenReceiptsInput>
    create: XOR<UserCreateWithoutBenReceiptsInput, UserUncheckedCreateWithoutBenReceiptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBenReceiptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBenReceiptsInput, UserUncheckedUpdateWithoutBenReceiptsInput>
  }

  export type UserUpdateWithoutBenReceiptsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBenReceiptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TriTrackHandoffUpsertWithWhereUniqueWithoutFromReceiptInput = {
    where: TriTrackHandoffWhereUniqueInput
    update: XOR<TriTrackHandoffUpdateWithoutFromReceiptInput, TriTrackHandoffUncheckedUpdateWithoutFromReceiptInput>
    create: XOR<TriTrackHandoffCreateWithoutFromReceiptInput, TriTrackHandoffUncheckedCreateWithoutFromReceiptInput>
  }

  export type TriTrackHandoffUpdateWithWhereUniqueWithoutFromReceiptInput = {
    where: TriTrackHandoffWhereUniqueInput
    data: XOR<TriTrackHandoffUpdateWithoutFromReceiptInput, TriTrackHandoffUncheckedUpdateWithoutFromReceiptInput>
  }

  export type TriTrackHandoffUpdateManyWithWhereWithoutFromReceiptInput = {
    where: TriTrackHandoffScalarWhereInput
    data: XOR<TriTrackHandoffUpdateManyMutationInput, TriTrackHandoffUncheckedUpdateManyWithoutFromReceiptInput>
  }

  export type TriTrackHandoffScalarWhereInput = {
    AND?: TriTrackHandoffScalarWhereInput | TriTrackHandoffScalarWhereInput[]
    OR?: TriTrackHandoffScalarWhereInput[]
    NOT?: TriTrackHandoffScalarWhereInput | TriTrackHandoffScalarWhereInput[]
    id?: IntFilter<"TriTrackHandoff"> | number
    fromTrack?: EnumTrackTypeFilter<"TriTrackHandoff"> | $Enums.TrackType
    toTrack?: EnumTrackTypeFilter<"TriTrackHandoff"> | $Enums.TrackType
    status?: EnumHandoffStatusFilter<"TriTrackHandoff"> | $Enums.HandoffStatus
    fromReceiptId?: IntFilter<"TriTrackHandoff"> | number
    toReceiptId?: IntNullableFilter<"TriTrackHandoff"> | number | null
    initiatedAt?: DateTimeFilter<"TriTrackHandoff"> | Date | string
    completedAt?: DateTimeNullableFilter<"TriTrackHandoff"> | Date | string | null
    latencyMs?: IntNullableFilter<"TriTrackHandoff"> | number | null
    exceededLimit?: BoolFilter<"TriTrackHandoff"> | boolean
    payload?: JsonFilter<"TriTrackHandoff">
    result?: JsonNullableFilter<"TriTrackHandoff">
    errorMessage?: StringNullableFilter<"TriTrackHandoff"> | string | null
    metadata?: JsonNullableFilter<"TriTrackHandoff">
  }

  export type TriTrackHandoffUpsertWithWhereUniqueWithoutToReceiptInput = {
    where: TriTrackHandoffWhereUniqueInput
    update: XOR<TriTrackHandoffUpdateWithoutToReceiptInput, TriTrackHandoffUncheckedUpdateWithoutToReceiptInput>
    create: XOR<TriTrackHandoffCreateWithoutToReceiptInput, TriTrackHandoffUncheckedCreateWithoutToReceiptInput>
  }

  export type TriTrackHandoffUpdateWithWhereUniqueWithoutToReceiptInput = {
    where: TriTrackHandoffWhereUniqueInput
    data: XOR<TriTrackHandoffUpdateWithoutToReceiptInput, TriTrackHandoffUncheckedUpdateWithoutToReceiptInput>
  }

  export type TriTrackHandoffUpdateManyWithWhereWithoutToReceiptInput = {
    where: TriTrackHandoffScalarWhereInput
    data: XOR<TriTrackHandoffUpdateManyMutationInput, TriTrackHandoffUncheckedUpdateManyWithoutToReceiptInput>
  }

  export type UserCreateWithoutBenSessionsInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBenSessionsInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBenSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBenSessionsInput, UserUncheckedCreateWithoutBenSessionsInput>
  }

  export type UserUpsertWithoutBenSessionsInput = {
    update: XOR<UserUpdateWithoutBenSessionsInput, UserUncheckedUpdateWithoutBenSessionsInput>
    create: XOR<UserCreateWithoutBenSessionsInput, UserUncheckedCreateWithoutBenSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBenSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBenSessionsInput, UserUncheckedUpdateWithoutBenSessionsInput>
  }

  export type UserUpdateWithoutBenSessionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBenSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BENReceiptCreateWithoutHandoffsFromInput = {
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp?: Date | string
    persona?: $Enums.BENPersona
    track?: $Enums.TrackType | null
    payload: JsonNullValueInput | InputJsonValue
    digest: string
    previousDigest?: string | null
    baselineDigest?: string | null
    witnessModel?: string | null
    witnessSignature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutBenReceiptsInput
    handoffsTo?: TriTrackHandoffCreateNestedManyWithoutToReceiptInput
  }

  export type BENReceiptUncheckedCreateWithoutHandoffsFromInput = {
    id?: number
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp?: Date | string
    userId?: number | null
    persona?: $Enums.BENPersona
    track?: $Enums.TrackType | null
    payload: JsonNullValueInput | InputJsonValue
    digest: string
    previousDigest?: string | null
    baselineDigest?: string | null
    witnessModel?: string | null
    witnessSignature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    handoffsTo?: TriTrackHandoffUncheckedCreateNestedManyWithoutToReceiptInput
  }

  export type BENReceiptCreateOrConnectWithoutHandoffsFromInput = {
    where: BENReceiptWhereUniqueInput
    create: XOR<BENReceiptCreateWithoutHandoffsFromInput, BENReceiptUncheckedCreateWithoutHandoffsFromInput>
  }

  export type BENReceiptCreateWithoutHandoffsToInput = {
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp?: Date | string
    persona?: $Enums.BENPersona
    track?: $Enums.TrackType | null
    payload: JsonNullValueInput | InputJsonValue
    digest: string
    previousDigest?: string | null
    baselineDigest?: string | null
    witnessModel?: string | null
    witnessSignature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutBenReceiptsInput
    handoffsFrom?: TriTrackHandoffCreateNestedManyWithoutFromReceiptInput
  }

  export type BENReceiptUncheckedCreateWithoutHandoffsToInput = {
    id?: number
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp?: Date | string
    userId?: number | null
    persona?: $Enums.BENPersona
    track?: $Enums.TrackType | null
    payload: JsonNullValueInput | InputJsonValue
    digest: string
    previousDigest?: string | null
    baselineDigest?: string | null
    witnessModel?: string | null
    witnessSignature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    handoffsFrom?: TriTrackHandoffUncheckedCreateNestedManyWithoutFromReceiptInput
  }

  export type BENReceiptCreateOrConnectWithoutHandoffsToInput = {
    where: BENReceiptWhereUniqueInput
    create: XOR<BENReceiptCreateWithoutHandoffsToInput, BENReceiptUncheckedCreateWithoutHandoffsToInput>
  }

  export type BENReceiptUpsertWithoutHandoffsFromInput = {
    update: XOR<BENReceiptUpdateWithoutHandoffsFromInput, BENReceiptUncheckedUpdateWithoutHandoffsFromInput>
    create: XOR<BENReceiptCreateWithoutHandoffsFromInput, BENReceiptUncheckedCreateWithoutHandoffsFromInput>
    where?: BENReceiptWhereInput
  }

  export type BENReceiptUpdateToOneWithWhereWithoutHandoffsFromInput = {
    where?: BENReceiptWhereInput
    data: XOR<BENReceiptUpdateWithoutHandoffsFromInput, BENReceiptUncheckedUpdateWithoutHandoffsFromInput>
  }

  export type BENReceiptUpdateWithoutHandoffsFromInput = {
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutBenReceiptsNestedInput
    handoffsTo?: TriTrackHandoffUpdateManyWithoutToReceiptNestedInput
  }

  export type BENReceiptUncheckedUpdateWithoutHandoffsFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handoffsTo?: TriTrackHandoffUncheckedUpdateManyWithoutToReceiptNestedInput
  }

  export type BENReceiptUpsertWithoutHandoffsToInput = {
    update: XOR<BENReceiptUpdateWithoutHandoffsToInput, BENReceiptUncheckedUpdateWithoutHandoffsToInput>
    create: XOR<BENReceiptCreateWithoutHandoffsToInput, BENReceiptUncheckedCreateWithoutHandoffsToInput>
    where?: BENReceiptWhereInput
  }

  export type BENReceiptUpdateToOneWithWhereWithoutHandoffsToInput = {
    where?: BENReceiptWhereInput
    data: XOR<BENReceiptUpdateWithoutHandoffsToInput, BENReceiptUncheckedUpdateWithoutHandoffsToInput>
  }

  export type BENReceiptUpdateWithoutHandoffsToInput = {
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutBenReceiptsNestedInput
    handoffsFrom?: TriTrackHandoffUpdateManyWithoutFromReceiptNestedInput
  }

  export type BENReceiptUncheckedUpdateWithoutHandoffsToInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handoffsFrom?: TriTrackHandoffUncheckedUpdateManyWithoutFromReceiptNestedInput
  }

  export type UserCreateWithoutZscansInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutZscansInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutZscansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutZscansInput, UserUncheckedCreateWithoutZscansInput>
  }

  export type UserUpsertWithoutZscansInput = {
    update: XOR<UserUpdateWithoutZscansInput, UserUncheckedUpdateWithoutZscansInput>
    create: XOR<UserCreateWithoutZscansInput, UserUncheckedCreateWithoutZscansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutZscansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutZscansInput, UserUncheckedUpdateWithoutZscansInput>
  }

  export type UserUpdateWithoutZscansInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutZscansInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutSsoConfigsInput = {
    name: string
    plan?: $Enums.PlanType
    status?: $Enums.OrgStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    teams?: TeamCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutSsoConfigsInput = {
    id?: number
    name: string
    plan?: $Enums.PlanType
    status?: $Enums.OrgStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    teams?: TeamUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutSsoConfigsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSsoConfigsInput, OrganizationUncheckedCreateWithoutSsoConfigsInput>
  }

  export type OrganizationUpsertWithoutSsoConfigsInput = {
    update: XOR<OrganizationUpdateWithoutSsoConfigsInput, OrganizationUncheckedUpdateWithoutSsoConfigsInput>
    create: XOR<OrganizationCreateWithoutSsoConfigsInput, OrganizationUncheckedCreateWithoutSsoConfigsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutSsoConfigsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutSsoConfigsInput, OrganizationUncheckedUpdateWithoutSsoConfigsInput>
  }

  export type OrganizationUpdateWithoutSsoConfigsInput = {
    name?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    status?: EnumOrgStatusFieldUpdateOperationsInput | $Enums.OrgStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    teams?: TeamUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutSsoConfigsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    status?: EnumOrgStatusFieldUpdateOperationsInput | $Enums.OrgStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    teams?: TeamUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    audits?: AuditRecordCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    budgets?: BudgetCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptCreateNestedManyWithoutUserInput
    benSessions?: BENSessionCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    orgId?: number | null
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditRecordUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutUserInput
    regressionBaselines?: RegressionBaselineUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    benReceipts?: BENReceiptUncheckedCreateNestedManyWithoutUserInput
    benSessions?: BENSessionUncheckedCreateNestedManyWithoutUserInput
    zscans?: ZScanVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SessionCreateManyUserInput = {
    id?: number
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type AuditRecordCreateManyUserInput = {
    id?: number
    action: string
    category: $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AuditStatus
    lamport: number
    hashPointer?: string | null
    organizationId?: number | null
    blockHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberCreateManyUserInput = {
    id?: number
    teamId: number
    role?: $Enums.TeamRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCreateManyUserInput = {
    id?: number
    limit: number
    period?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegressionBaselineCreateManyUserInput = {
    id?: number
    modelName: string
    modelVersion?: string | null
    testType: string
    avgResponseTime: number
    avgCost: number
    avgQualityScore: number
    avgAccuracy: number
    successRate: number
    alertThreshold?: number
    sampleSize: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackCreateManyUserInput = {
    id?: number
    type: $Enums.FeedbackType
    category: $Enums.FeedbackCategory
    priority?: $Enums.FeedbackPriority
    subject: string
    message: string
    url?: string | null
    userAgent?: string | null
    status?: $Enums.FeedbackStatus
    assignedTo?: number | null
    response?: string | null
    respondedAt?: Date | string | null
    respondedBy?: number | null
    sentiment?: string | null
    sentimentScore?: number | null
    upvotes?: number
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type BENReceiptCreateManyUserInput = {
    id?: number
    receiptType: $Enums.ReceiptType
    lamportClock: number
    realTimestamp?: Date | string
    persona?: $Enums.BENPersona
    track?: $Enums.TrackType | null
    payload: JsonNullValueInput | InputJsonValue
    digest: string
    previousDigest?: string | null
    baselineDigest?: string | null
    witnessModel?: string | null
    witnessSignature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BENSessionCreateManyUserInput = {
    id?: number
    persona: $Enums.BENPersona
    priority: number
    locked?: boolean
    startedAt?: Date | string
    endedAt?: Date | string | null
    duration?: number | null
    startLamport: number
    endLamport?: number | null
    switchReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ZScanVerificationCreateManyUserInput = {
    id?: number
    totalRules: number
    passed: number
    warnings: number
    critical: number
    results: JsonNullValueInput | InputJsonValue
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditRecordUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    category?: EnumAuditCategoryFieldUpdateOperationsInput | $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    lamport?: IntFieldUpdateOperationsInput | number
    hashPointer?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    blockHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditRecordUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    category?: EnumAuditCategoryFieldUpdateOperationsInput | $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    lamport?: IntFieldUpdateOperationsInput | number
    hashPointer?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    blockHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditRecordUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    category?: EnumAuditCategoryFieldUpdateOperationsInput | $Enums.AuditCategory
    details?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    lamport?: IntFieldUpdateOperationsInput | number
    hashPointer?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableIntFieldUpdateOperationsInput | number | null
    blockHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUpdateWithoutUserInput = {
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUpdateWithoutUserInput = {
    limit?: FloatFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    limit?: FloatFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    limit?: FloatFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegressionBaselineUpdateWithoutUserInput = {
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: StringFieldUpdateOperationsInput | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    avgQualityScore?: FloatFieldUpdateOperationsInput | number
    avgAccuracy?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegressionBaselineUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: StringFieldUpdateOperationsInput | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    avgQualityScore?: FloatFieldUpdateOperationsInput | number
    avgAccuracy?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegressionBaselineUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: StringFieldUpdateOperationsInput | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    avgQualityScore?: FloatFieldUpdateOperationsInput | number
    avgAccuracy?: FloatFieldUpdateOperationsInput | number
    successRate?: FloatFieldUpdateOperationsInput | number
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUpdateWithoutUserInput = {
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeedbackUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeedbackUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    assignedTo?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    upvotes?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BENReceiptUpdateWithoutUserInput = {
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handoffsFrom?: TriTrackHandoffUpdateManyWithoutFromReceiptNestedInput
    handoffsTo?: TriTrackHandoffUpdateManyWithoutToReceiptNestedInput
  }

  export type BENReceiptUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handoffsFrom?: TriTrackHandoffUncheckedUpdateManyWithoutFromReceiptNestedInput
    handoffsTo?: TriTrackHandoffUncheckedUpdateManyWithoutToReceiptNestedInput
  }

  export type BENReceiptUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptType?: EnumReceiptTypeFieldUpdateOperationsInput | $Enums.ReceiptType
    lamportClock?: IntFieldUpdateOperationsInput | number
    realTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    track?: NullableEnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType | null
    payload?: JsonNullValueInput | InputJsonValue
    digest?: StringFieldUpdateOperationsInput | string
    previousDigest?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDigest?: NullableStringFieldUpdateOperationsInput | string | null
    witnessModel?: NullableStringFieldUpdateOperationsInput | string | null
    witnessSignature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BENSessionUpdateWithoutUserInput = {
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    priority?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startLamport?: IntFieldUpdateOperationsInput | number
    endLamport?: NullableIntFieldUpdateOperationsInput | number | null
    switchReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BENSessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    priority?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startLamport?: IntFieldUpdateOperationsInput | number
    endLamport?: NullableIntFieldUpdateOperationsInput | number | null
    switchReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BENSessionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    persona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    priority?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startLamport?: IntFieldUpdateOperationsInput | number
    endLamport?: NullableIntFieldUpdateOperationsInput | number | null
    switchReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ZScanVerificationUpdateWithoutUserInput = {
    totalRules?: IntFieldUpdateOperationsInput | number
    passed?: IntFieldUpdateOperationsInput | number
    warnings?: IntFieldUpdateOperationsInput | number
    critical?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZScanVerificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalRules?: IntFieldUpdateOperationsInput | number
    passed?: IntFieldUpdateOperationsInput | number
    warnings?: IntFieldUpdateOperationsInput | number
    critical?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZScanVerificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalRules?: IntFieldUpdateOperationsInput | number
    passed?: IntFieldUpdateOperationsInput | number
    warnings?: IntFieldUpdateOperationsInput | number
    critical?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyOrganizationInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    role?: $Enums.Role
    tier?: $Enums.UserTier
    permissions?: UserCreatepermissionsInput | $Enums.Permission[]
    status?: $Enums.UserStatus
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    backupCodes?: UserCreatebackupCodesInput | string[]
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    passwordChangedAt?: Date | string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: $Enums.BENPersona
    personaLocked?: boolean
    lamportCounter?: number
    lastReceiptId?: number | null
  }

  export type TeamCreateManyOrganizationInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SSOConfigurationCreateManyOrganizationInput = {
    id?: number
    provider: $Enums.SSOProvider
    enabled?: boolean
    samlEntryPoint?: string | null
    samlIssuer?: string | null
    samlCert?: string | null
    samlCallbackUrl?: string | null
    samlLogoutUrl?: string | null
    oauthClientId?: string | null
    oauthClientSecret?: string | null
    oauthAuthUrl?: string | null
    oauthTokenUrl?: string | null
    oauthUserInfoUrl?: string | null
    oauthScopes?: SSOConfigurationCreateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationCreatedomainRestrictionInput | string[]
    jitProvisioning?: boolean
    defaultRole?: $Enums.Role
    defaultTier?: $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type UserUpdateWithoutOrganizationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    budgets?: BudgetUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditRecordUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutUserNestedInput
    regressionBaselines?: RegressionBaselineUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    benReceipts?: BENReceiptUncheckedUpdateManyWithoutUserNestedInput
    benSessions?: BENSessionUncheckedUpdateManyWithoutUserNestedInput
    zscans?: ZScanVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    permissions?: UserUpdatepermissionsInput | $Enums.Permission[]
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: UserUpdatebackupCodesInput | string[]
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    currentPersona?: EnumBENPersonaFieldUpdateOperationsInput | $Enums.BENPersona
    personaLocked?: BoolFieldUpdateOperationsInput | boolean
    lamportCounter?: IntFieldUpdateOperationsInput | number
    lastReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TeamUpdateWithoutOrganizationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SSOConfigurationUpdateWithoutOrganizationInput = {
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    enabled?: BoolFieldUpdateOperationsInput | boolean
    samlEntryPoint?: NullableStringFieldUpdateOperationsInput | string | null
    samlIssuer?: NullableStringFieldUpdateOperationsInput | string | null
    samlCert?: NullableStringFieldUpdateOperationsInput | string | null
    samlCallbackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    samlLogoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthAuthUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthUserInfoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthScopes?: SSOConfigurationUpdateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationUpdatedomainRestrictionInput | string[]
    jitProvisioning?: BoolFieldUpdateOperationsInput | boolean
    defaultRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    defaultTier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SSOConfigurationUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    enabled?: BoolFieldUpdateOperationsInput | boolean
    samlEntryPoint?: NullableStringFieldUpdateOperationsInput | string | null
    samlIssuer?: NullableStringFieldUpdateOperationsInput | string | null
    samlCert?: NullableStringFieldUpdateOperationsInput | string | null
    samlCallbackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    samlLogoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthAuthUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthUserInfoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthScopes?: SSOConfigurationUpdateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationUpdatedomainRestrictionInput | string[]
    jitProvisioning?: BoolFieldUpdateOperationsInput | boolean
    defaultRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    defaultTier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SSOConfigurationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider?: EnumSSOProviderFieldUpdateOperationsInput | $Enums.SSOProvider
    enabled?: BoolFieldUpdateOperationsInput | boolean
    samlEntryPoint?: NullableStringFieldUpdateOperationsInput | string | null
    samlIssuer?: NullableStringFieldUpdateOperationsInput | string | null
    samlCert?: NullableStringFieldUpdateOperationsInput | string | null
    samlCallbackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    samlLogoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthAuthUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthUserInfoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    oauthScopes?: SSOConfigurationUpdateoauthScopesInput | string[]
    domainRestriction?: SSOConfigurationUpdatedomainRestrictionInput | string[]
    jitProvisioning?: BoolFieldUpdateOperationsInput | boolean
    defaultRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    defaultTier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamMemberCreateManyTeamInput = {
    id?: number
    userId: number
    role?: $Enums.TeamRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUpdateWithoutTeamInput = {
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeamsNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TriTrackHandoffCreateManyFromReceiptInput = {
    id?: number
    fromTrack: $Enums.TrackType
    toTrack: $Enums.TrackType
    status?: $Enums.HandoffStatus
    toReceiptId?: number | null
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    latencyMs?: number | null
    exceededLimit?: boolean
    payload: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffCreateManyToReceiptInput = {
    id?: number
    fromTrack: $Enums.TrackType
    toTrack: $Enums.TrackType
    status?: $Enums.HandoffStatus
    fromReceiptId: number
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    latencyMs?: number | null
    exceededLimit?: boolean
    payload: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffUpdateWithoutFromReceiptInput = {
    fromTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    toTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    status?: EnumHandoffStatusFieldUpdateOperationsInput | $Enums.HandoffStatus
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    exceededLimit?: BoolFieldUpdateOperationsInput | boolean
    payload?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    toReceipt?: BENReceiptUpdateOneWithoutHandoffsToNestedInput
  }

  export type TriTrackHandoffUncheckedUpdateWithoutFromReceiptInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    toTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    status?: EnumHandoffStatusFieldUpdateOperationsInput | $Enums.HandoffStatus
    toReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    exceededLimit?: BoolFieldUpdateOperationsInput | boolean
    payload?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffUncheckedUpdateManyWithoutFromReceiptInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    toTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    status?: EnumHandoffStatusFieldUpdateOperationsInput | $Enums.HandoffStatus
    toReceiptId?: NullableIntFieldUpdateOperationsInput | number | null
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    exceededLimit?: BoolFieldUpdateOperationsInput | boolean
    payload?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffUpdateWithoutToReceiptInput = {
    fromTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    toTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    status?: EnumHandoffStatusFieldUpdateOperationsInput | $Enums.HandoffStatus
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    exceededLimit?: BoolFieldUpdateOperationsInput | boolean
    payload?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    fromReceipt?: BENReceiptUpdateOneRequiredWithoutHandoffsFromNestedInput
  }

  export type TriTrackHandoffUncheckedUpdateWithoutToReceiptInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    toTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    status?: EnumHandoffStatusFieldUpdateOperationsInput | $Enums.HandoffStatus
    fromReceiptId?: IntFieldUpdateOperationsInput | number
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    exceededLimit?: BoolFieldUpdateOperationsInput | boolean
    payload?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TriTrackHandoffUncheckedUpdateManyWithoutToReceiptInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    toTrack?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    status?: EnumHandoffStatusFieldUpdateOperationsInput | $Enums.HandoffStatus
    fromReceiptId?: IntFieldUpdateOperationsInput | number
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    exceededLimit?: BoolFieldUpdateOperationsInput | boolean
    payload?: JsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}